# NetRunner: Java Mastery Guide

## Inicializando Sistema...

```
 _   _      _   ____                            
| \ | | ___| |_|  _ \ _   _ _ __  _ __   ___ _ __ 
|  \| |/ _ \ __| |_) | | | | '_ \| '_ \ / _ \ '__|
| |\  |  __/ |_|  _ <| |_| | | | | | | |  __/ |   
|_| \_|\___|\__|_| \_\\__,_|_| |_|_| |_|\___|_|   
                                                  
>> Java Mastery Guide v1.0
>> Inicializando interface neural...
>> Estabelecendo conexÃ£o com a Matrix...
>> Sistema pronto para upload de conhecimento...
```

## Sobre este Guia

Bem-vindo, runner. VocÃª acaba de acessar a interface neural mais avanÃ§ada para dominar a linguagem Java. Este nÃ£o Ã© apenas mais um tutorial - Ã© sua porta de entrada para o submundo do desenvolvimento de software.

### O que vocÃª vai encontrar aqui

* ðŸ”§ Fundamentos SÃ³lidos: Do bÃ¡sico ao avanÃ§ado, construa uma base inquebrÃ¡vel

* ðŸŒ Projetos PrÃ¡ticos: Aplique seus conhecimentos em missÃµes do mundo real

* ðŸš€ Tecnologias Modernas: Frameworks, cloud, seguranÃ§a e muito mais

* ðŸ’¡ PadrÃµes e Boas PrÃ¡ticas: Aprenda a construir cÃ³digo resiliente e escalÃ¡vel

## PrÃ©-requisitos

* Computador com acesso Ã  internet

* Vontade de aprender e experimentar

* DisposiÃ§Ã£o para desafios prÃ¡ticos

* Mente aberta para novos conceitos

## Como Usar este Guia

1. Siga a SequÃªncia: Os mÃ³dulos foram organizados em ordem progressiva de complexidade

2. Pratique: Complete as missÃµes prÃ¡ticas em cada seÃ§Ã£o

3. Experimente: Modifique os exemplos e crie suas prÃ³prias variaÃ§Ãµes

4. Conecte-se: Participe da comunidade e compartilhe seu progresso

## Roadmap de Aprendizado

```MERMAID
graph TD
    A[InicializaÃ§Ã£o] --> B[Protocolos BÃ¡sicos]
    B --> C[Matriz de Controle]
    C --> D[Interface Neural/OOP]
    D --> E[Sistemas AvanÃ§ados]
    E --> F[EspecializaÃ§Ã£o]
```

## Quick Start

```JAVA
public class NetRunner {
    public static void main(String[] args) {
        System.out.println("Iniciando jornada no NetRunner...");
        System.out.println("Preparando ambiente de desenvolvimento...");
        System.out.println("Sistema pronto para comeÃ§ar!");
    }
}
```

## PrÃ³ximos Passos

1. Comece pela seÃ§Ã£o [Sobre o Projeto](about.html)

2. Configure seu [Ambiente de Desenvolvimento](development-environment.html)

3. Inicie sua jornada com [Java BÃ¡sico](java-basics.html)

## Status do Projeto

* VersÃ£o: 1.0

* Status: Ativo

* Java: 17+

Tip:

"O cÃ³digo Ã© apenas o comeÃ§o. O verdadeiro poder estÃ¡ em como vocÃª o utiliza." - NetRunner's Manifesto

[ComeÃ§ar Agora](getting-started.html)



# Iniciando no NetRunner

```
>> Inicializando sequÃªncia de boot...
>> Carregando mÃ³dulos bÃ¡sicos...
>> Preparando ambiente de desenvolvimento...
>> Sistema pronto para upload inicial...
```

## PrÃ©-requisitos do Sistema

### Hardware Recomendado

* Processador: Dual Core ou superior

* MemÃ³ria RAM: 8GB mÃ­nimo (16GB recomendado)

* Armazenamento: 10GB de espaÃ§o livre

* ConexÃ£o com Internet estÃ¡vel

### Software Base

* Sistema Operacional: Windows 10/11, macOS, Linux

* Java Development Kit (JDK) 17 ou superior

* IDE compatÃ­vel (recomendamos IntelliJ IDEA)

* Git para controle de versÃ£o

## Checklist de InicializaÃ§Ã£o

```
CHECKLIST
â”œâ”€â”€ [1] ConfiguraÃ§Ã£o do Ambiente
â”œâ”€â”€ [2] InstalaÃ§Ã£o das Ferramentas
â”œâ”€â”€ [3] VerificaÃ§Ã£o do Sistema
â””â”€â”€ [4] Teste de ConexÃ£o
```

## SequÃªncia de Boot

### 1. PreparaÃ§Ã£o Inicial

Antes de mergulhar no cÃ³digo, certifique-se de:

* Ler o [Sobre o Projeto](about.html)

* Verificar os [PrÃ©-requisitos](prerequisites.html)

* Entender o [Caminho de Aprendizado](learning-path.html)

### 2. Setup do Ambiente

Configure seu ambiente de desenvolvimento:

* [ConfiguraÃ§Ã£o do Sistema Operacional](os-setup.html)

* [VisÃ£o Geral das Ferramentas](tools-overview.html)

### 3. Primeiros Passos

```JAVA
public class FirstConnection {
    public static void main(String[] args) {
        System.out.println("ConexÃ£o estabelecida com NetRunner...");
        System.out.println("Iniciando upload de conhecimento...");
        System.out.println("Bem-vindo Ã  Matrix, runner!");
    }
}
```

## Roadmap Inicial

```MERMAID
graph TD
    A[InÃ­cio] --> B[Setup Ambiente]
    B --> C[Fundamentos Java]
    C --> D[Primeiros Projetos]
    D --> E[EvoluÃ§Ã£o ContÃ­nua]
```

## NavegaÃ§Ã£o do Sistema

### Estrutura do Curso

* MÃ³dulos progressivos

* Projetos prÃ¡ticos em cada seÃ§Ã£o

* ExercÃ­cios de fixaÃ§Ã£o

* Desafios de cÃ³digo

### Como Progredir

1. Complete cada mÃ³dulo sequencialmente

2. Execute todos os exemplos de cÃ³digo

3. FaÃ§a os exercÃ­cios propostos

4. Construa os projetos sugeridos

## Suporte e Recursos

### Canais de Ajuda

* DocumentaÃ§Ã£o oficial

* FÃ³rum da comunidade

* RepositÃ³rio de exemplos

* Canal de dÃºvidas

## PrÃ³ximos Passos

Escolha seu caminho:

1. [Configurar Ambiente de Desenvolvimento](development-environment.html)

2. [Instalar JDK](jdk-installation.html)

3. [Configurar IDE](ide-setup.html)

## Dicas de SobrevivÃªncia

Tip:

"Na Matrix do cÃ³digo, a prÃ¡tica constante Ã© sua melhor arma."

* Mantenha um ritmo consistente de estudos

* Pratique diariamente

* NÃ£o pule etapas fundamentais

* Construa seu prÃ³prio cÃ³digo

* Participe da comunidade

## Checkpoint

Antes de prosseguir, certifique-se de:

* [ ] Ter lido a introduÃ§Ã£o completa

* [ ] Entender a estrutura do curso

* [ ] Verificar os requisitos do sistema

* [ ] Estar pronto para comeÃ§ar a configuraÃ§Ã£o

[ComeÃ§ar ConfiguraÃ§Ã£o do Ambiente](development-environment.html)

Tip:

"Todo runner comeÃ§a com um primeiro comando. FaÃ§a o seu contar."



# Sobre o Projeto NetRunner

```
>> Inicializando mÃ³dulo de apresentaÃ§Ã£o...
>> Carregando manifesto do projeto...
>> Estabelecendo parÃ¢metros base...
```

## Manifesto NetRunner

No cenÃ¡rio atual do desenvolvimento de software, dominar Java nÃ£o Ã© apenas uma habilidade - Ã© uma necessidade. O NetRunner foi concebido como uma interface neural direta para seu aprendizado, mesclando conceitos tÃ©cnicos sÃ³lidos com uma experiÃªncia imersiva Ãºnica.

## Arquitetura do Conhecimento

### Core Components

1. Fundamentos SÃ³lidos

* Sintaxe e estruturas bÃ¡sicas

* Paradigmas de programaÃ§Ã£o

* GestÃ£o de memÃ³ria e recursos

* Debugging e resoluÃ§Ã£o de problemas

2. Desenvolvimento PrÃ¡tico

* Projetos hands-on

* Casos de uso reais

* ImplementaÃ§Ãµes guiadas

* Desafios progressivos

3. EvoluÃ§Ã£o TÃ©cnica

* PadrÃµes de projeto

* Boas prÃ¡ticas

* OtimizaÃ§Ã£o de cÃ³digo

* SeguranÃ§a e performance

## Metodologia de Ensino

### Abordagem Neural

```
INPUT â†’ PROCESSAMENTO â†’ OUTPUT
   â†‘          â†‘            â†‘
Teoria    PrÃ¡tica     Resultado
```

* Teoria Focada: Apenas o essencial, sem fluff

* PrÃ¡tica Intensiva: Aprenda fazendo

* Feedback Loop: Teste, erre, aprenda, repita

### Ciclo de Aprendizado

```MERMAID
graph LR
    A[Conceito] --> B[Exemplo]
    B --> C[PrÃ¡tica]
    C --> D[Desafio]
    D --> E[Review]
    E --> A
```

## Objetivos do Projeto

### Metas Principais

1. CapacitaÃ§Ã£o TÃ©cnica

* DomÃ­nio completo da sintaxe Java

* CompreensÃ£o profunda de OOP

* Habilidades de debugging avanÃ§adas

* PrÃ¡ticas de cÃ³digo limpo

2. Desenvolvimento Profissional

* PreparaÃ§Ã£o para mercado

* Portfolio builder

* ResoluÃ§Ã£o de problemas reais

* Mindset de desenvolvedor

3. EvoluÃ§Ã£o ContÃ­nua

* Updates regulares

* Novos desafios

* ExpansÃ£o de conteÃºdo

* IntegraÃ§Ã£o com tecnologias emergentes

## Stack TecnolÃ³gico

### Core Technologies

```
JAVA STACK
â”œâ”€â”€ Core Java 17+
â”œâ”€â”€ Build Tools
â”‚   â”œâ”€â”€ Maven
â”‚   â””â”€â”€ Gradle
â”œâ”€â”€ Testing
â”‚   â”œâ”€â”€ JUnit
â”‚   â””â”€â”€ Mockito
â””â”€â”€ Frameworks
    â”œâ”€â”€ Spring
    â””â”€â”€ Hibernate
```

## Compromisso com Qualidade

### PadrÃµes de ExcelÃªncia

* CÃ³digo Documentado: Exemplos claros e bem comentados

* Melhores PrÃ¡ticas: Seguindo padrÃµes da indÃºstria

* AtualizaÃ§Ãµes Regulares: ConteÃºdo sempre atual

* Suporte Ativo: Comunidade engajada

## PrÃ³ximos Passos

Agora que vocÃª compreende a essÃªncia do NetRunner, Ã© hora de configurar seu ambiente de desenvolvimento e comeÃ§ar sua jornada.

[Configurar Ambiente de Desenvolvimento](development-environment.html)

Tip:

"A matrix tem seus padrÃµes. Uma vez que vocÃª os entende, o cÃ³digo se torna sua segunda natureza."



# PrÃ©-requisitos do NetRunner

```
>> Escaneando requisitos do sistema...
>> Verificando compatibilidade...
>> Analisando perfil do usuÃ¡rio...
>> RelatÃ³rio de requisitos gerado...
```

## Requisitos TÃ©cnicos

### Hardware MÃ­nimo

| Componente |Requisito MÃ­nimo |Recomendado |
---------------------------------------------
| Processador |Dual Core 2GHz |Quad Core 3GHz+ |
| MemÃ³ria RAM |8GB |16GB+ |
| Armazenamento |10GB livre |20GB+ livre |
| Internet |5Mbps |15Mbps+ |

### Software Base

```
REQUISITOS DE SOFTWARE
â”œâ”€â”€ Sistema Operacional
â”‚   â”œâ”€â”€ Windows 10/11
â”‚   â”œâ”€â”€ macOS Catalina+
â”‚   â””â”€â”€ Linux (kernel 5.0+)
â”œâ”€â”€ Navegador Moderno
â”‚   â”œâ”€â”€ Chrome 90+
â”‚   â”œâ”€â”€ Firefox 88+
â”‚   â””â”€â”€ Edge 90+
â””â”€â”€ Ferramentas Base
    â”œâ”€â”€ Git 2.30+
    â””â”€â”€ Terminal
```

## Conhecimentos PrÃ©vios

### Fundamentais

* LÃ³gica de programaÃ§Ã£o bÃ¡sica

* Conceitos de algoritmos

* Familiaridade com terminal/linha de comando

* NoÃ§Ãµes de versionamento

### Recomendados

* ExperiÃªncia com qualquer linguagem de programaÃ§Ã£o

* Conhecimento bÃ¡sico de redes

* InglÃªs tÃ©cnico para leitura

## VerificaÃ§Ã£o de Requisitos

### Checklist TÃ©cnico

* [ ] Hardware compatÃ­vel

* [ ] SO atualizado

* [ ] EspaÃ§o em disco suficiente

* [ ] ConexÃ£o estÃ¡vel com internet

### Checklist de Conhecimento

* [ ] Entendimento de lÃ³gica de programaÃ§Ã£o

* [ ] Familiaridade com terminal

* [ ] NoÃ§Ãµes de Git

* [ ] Capacidade de leitura tÃ©cnica

## Auto-AvaliaÃ§Ã£o

Execute este diagnÃ³stico bÃ¡sico:

```JAVA
public class SkillCheck {
    public static void main(String[] args) {
        // Se vocÃª entende este cÃ³digo bÃ¡sico
        // vocÃª estÃ¡ no caminho certo
        for (int i = 1; i <= 5; i++) {
            System.out.println("Teste de lÃ³gica #" + i);
        }
    }
}
```

## PreparaÃ§Ã£o Inicial

### 1. VerificaÃ§Ã£o de Sistema

```BASH
# Execute estes comandos no terminal
java -version
git --version
```

### 2. Estudo Preliminar

* Revisar conceitos bÃ¡sicos de programaÃ§Ã£o

* Familiarizar-se com terminal

* Praticar Git bÃ¡sico

## Recursos de Nivelamento

### Material de Estudo

* [LÃ³gica de ProgramaÃ§Ã£o BÃ¡sica](learning-path.html)

* [IntroduÃ§Ã£o a Terminais](terminal-essentials.html)

* [Git Fundamentals](git-basics.html)

### ExercÃ­cios PreparatÃ³rios

1. Criar algoritmos simples

2. Praticar comandos de terminal

3. Fazer operaÃ§Ãµes bÃ¡sicas com Git

## PrÃ³ximos Passos

Se vocÃª atende aos requisitos:

1. [ComeÃ§ar Setup do Ambiente](development-environment.html)

2. [Instalar Ferramentas](tools-overview.html)

3. [Iniciar Jornada](learning-path.html)

Se precisar de reforÃ§o:

1. Revisar material de nivelamento

2. Praticar exercÃ­cios bÃ¡sicos

3. Retornar quando preparado

## Suporte

### Canais de Ajuda

* FÃ³rum da comunidade

* DocumentaÃ§Ã£o oficial

* Tutoriais de nivelamento

* Mentoria da comunidade

[Configurar Ambiente de Desenvolvimento](development-environment.html)

Tip:

"Prepare seu terminal. A Matrix espera apenas aqueles que estÃ£o verdadeiramente prontos."



# Caminho de Aprendizado

```
>> Inicializando mapa neural...
>> Carregando rotas de conhecimento...
>> Calculando trajetÃ³ria Ã³tima...
>> Caminho de desenvolvimento estabelecido...
```

## Roadmap de EvoluÃ§Ã£o

```MERMAID
graph TD
    A[InicializaÃ§Ã£o] --> B[Java BÃ¡sico]
    B --> C[POO & Estruturas]
    C --> D[Recursos AvanÃ§ados]
    D --> E[Frameworks & Tools]
    E --> F[EspecializaÃ§Ã£o]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#00ff00
    style F fill:#1a1a1a,stroke:#00ff00
```

## NÃ­veis de ProgressÃ£o

### NÃ­vel 1: InicializaÃ§Ã£o

```
FASE INICIAL
â”œâ”€â”€ Setup do Ambiente
â”œâ”€â”€ Sintaxe BÃ¡sica
â”œâ”€â”€ VariÃ¡veis e Tipos
â”œâ”€â”€ Operadores
â””â”€â”€ Strings
```

### NÃ­vel 2: Controle de Fluxo

```
CONTROLE
â”œâ”€â”€ Condicionais
â”œâ”€â”€ Loops
â”œâ”€â”€ Switch
â””â”€â”€ Pattern Matching
```

### NÃ­vel 3: Estruturas de Dados

```
ESTRUTURAS
â”œâ”€â”€ Arrays
â”œâ”€â”€ Collections
â”œâ”€â”€ Lists & Sets
â””â”€â”€ Maps & Queues
```

### NÃ­vel 4: POO Fundamental

```
ORIENTAÃ‡ÃƒO A OBJETOS
â”œâ”€â”€ Classes e Objetos
â”œâ”€â”€ Encapsulamento
â”œâ”€â”€ HeranÃ§a
â””â”€â”€ Polimorfismo
```

### NÃ­vel 5: Recursos AvanÃ§ados

```
AVANÃ‡ADO
â”œâ”€â”€ Generics
â”œâ”€â”€ Lambda
â”œâ”€â”€ Streams
â””â”€â”€ Optional
```

## Metodologia de Progresso

### Ciclo de Aprendizado

```MERMAID
graph LR
    A[Teoria] --> B[Exemplo]
    B --> C[PrÃ¡tica]
    C --> D[Projeto]
    D --> E[Review]
    E --> A
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#00ff00
```

## Sistema de MissÃµes

### Projetos por NÃ­vel

1. BÃ¡sico

* Calculadora

* Conversor de Temperatura

* Manipulador de Strings

2. IntermediÃ¡rio

* Sistema BancÃ¡rio

* Gerenciador de Tarefas

* Processador de Dados

3. AvanÃ§ado

* API REST

* MicroserviÃ§o

* Sistema DistribuÃ­do

## MÃ©tricas de Progresso

### Indicadores de EvoluÃ§Ã£o

* Projetos completados

* ExercÃ­cios resolvidos

* Conceitos dominados

* CÃ³digo revisado

### Sistema de Conquistas

```
CONQUISTAS
â”œâ”€â”€ Iniciante [â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘]
â”œâ”€â”€ Desenvolvedor [â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘]
â””â”€â”€ Especialista [â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘]
```

## Recursos de Suporte

### Material Complementar

* DocumentaÃ§Ã£o oficial

* Artigos tÃ©cnicos

* VÃ­deos tutoriais

* ExercÃ­cios prÃ¡ticos

### Ferramentas de Desenvolvimento

* IDEs recomendadas

* Plugins essenciais

* Frameworks populares

* Bibliotecas Ãºteis

## PrÃ³ximas Etapas

### Caminhos de EspecializaÃ§Ã£o

1. Backend Development

2. Cloud Computing

3. Microservices

4. Data Engineering

## Dicas de Progresso

### Boas PrÃ¡ticas

* Code todos os dias

* Revise conceitos regularmente

* Participe da comunidade

* Construa projetos pessoais

### Armadilhas Comuns

* Pular fundamentos

* NÃ£o praticar cÃ³digo

* Ignorar boas prÃ¡ticas

* Evitar desafios

[ComeÃ§ar Jornada](java-basics.html)

Tip:

"O caminho do conhecimento Ã© como a Matrix - infinito em possibilidades, limitado apenas pela sua dedicaÃ§Ã£o."



# Ambiente de Desenvolvimento

```
>> Iniciando configuraÃ§Ã£o do ambiente...
>> Verificando dependÃªncias do sistema...
>> Preparando ferramentas de desenvolvimento...
>> Ambiente base estabelecido...
```

## VisÃ£o Geral

```MERMAID
graph TD
    A[Sistema Operacional] --> B[JDK]
    B --> C[IDE]
    C --> D[Ferramentas Auxiliares]
    D --> E[Ambiente Completo]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#00ff00
```

## Stack de Desenvolvimento

### Componentes Essenciais

```
AMBIENTE BASE
â”œâ”€â”€ JDK 17+
â”œâ”€â”€ IDE
â”‚   â”œâ”€â”€ IntelliJ IDEA
â”‚   â”œâ”€â”€ Eclipse
â”‚   â””â”€â”€ VS Code
â”œâ”€â”€ Git
â””â”€â”€ Terminal
```

### Ferramentas Auxiliares

```
TOOLS
â”œâ”€â”€ Maven/Gradle
â”œâ”€â”€ Docker
â”œâ”€â”€ Postman
â””â”€â”€ DBeaver
```

## ConfiguraÃ§Ã£o por Sistema Operacional

### Windows

```POWERSHELL
# Verificar versÃ£o do Java
java -version

# Verificar versÃ£o do Git
git --version

# Verificar variÃ¡veis de ambiente
echo %JAVA_HOME%
echo %PATH%
```

### macOS/Linux

```BASH
# Verificar versÃ£o do Java
java -version

# Verificar versÃ£o do Git
git --version

# Verificar variÃ¡veis de ambiente
echo $JAVA_HOME
echo $PATH
```

## IDEs Recomendadas

### IntelliJ IDEA

* Community Edition * Gratuita * Recursos essenciais * Plugins bÃ¡sicos

* Ultimate Edition * Recursos avanÃ§ados * Suporte a frameworks * Ferramentas profissionais

### VS Code

* Leve e rÃ¡pido

* ExtensÃ­vel

* Multiplataforma

* Gratuito

### Eclipse

* IDE tradicional

* Grande comunidade

* Plugins diversos

* Gratuito

## Plugins Essenciais

### Para Produtividade

```
PLUGINS
â”œâ”€â”€ Code Completion
â”œâ”€â”€ Git Integration
â”œâ”€â”€ Code Analysis
â””â”€â”€ Theme Tools
```

### Para Qualidade

```
QUALITY
â”œâ”€â”€ SonarLint
â”œâ”€â”€ CheckStyle
â”œâ”€â”€ PMD
â””â”€â”€ SpotBugs
```

## ConfiguraÃ§Ãµes Recomendadas

### Editor Settings

```JSON
{
    "editor.formatOnSave": true,
    "java.format.enabled": true,
    "java.completion.enabled": true,
    "java.debug.settings.hotCodeReplace": "auto"
}
```

### Git Config

```BASH
git config --global user.name "Seu Nome"
git config --global user.email "seu@email.com"
git config --global core.editor "code --wait"
```

## VerificaÃ§Ã£o do Ambiente

### Checklist de InstalaÃ§Ã£o

* [ ] JDK instalado e configurado

* [ ] IDE instalada e configurada

* [ ] Git instalado e configurado

* [ ] Terminal configurado

* [ ] Plugins essenciais instalados

### Teste do Ambiente

```JAVA
public class EnvironmentTest {
    public static void main(String[] args) {
        System.out.println("Java Version: " + 
            System.getProperty("java.version"));
        System.out.println("Java Home: " + 
            System.getProperty("java.home"));
        System.out.println("OS: " + 
            System.getProperty("os.name"));
    }
}
```

## PrÃ³ximos Passos

1. [Configurar Sistema Operacional](os-setup.html)

2. [Explorar Ferramentas](tools-overview.html)

3. [ComeÃ§ar a Programar](java-basics.html)

## Troubleshooting

### Problemas Comuns

1. Java nÃ£o encontrado

* Verificar instalaÃ§Ã£o

* Conferir PATH

* Reinstalar se necessÃ¡rio

2. IDE nÃ£o reconhece JDK

* Verificar configuraÃ§Ãµes

* Reconfigurar JAVA_HOME

* Reinstalar JDK

3. Git nÃ£o configurado

* Executar configuraÃ§Ãµes bÃ¡sicas

* Verificar credenciais

* Testar conexÃ£o com repositÃ³rio

[Configurar Sistema Operacional](os-setup.html)

Tip:

"Um ambiente bem configurado Ã© como ter acesso direto Ã  Matrix - tudo flui naturalmente."



# ConfiguraÃ§Ã£o do Sistema Operacional

```
>> Iniciando diagnÃ³stico do sistema...
>> Verificando compatibilidade...
>> Ajustando configuraÃ§Ãµes base...
>> Sistema preparado para desenvolvimento...
```

## Requisitos por Sistema

### Windows

```
WINDOWS SETUP
â”œâ”€â”€ Windows 10/11
â”œâ”€â”€ PowerShell 5.1+
â”œâ”€â”€ Windows Terminal
â””â”€â”€ WSL2 (recomendado)
```

### macOS

```
MACOS SETUP
â”œâ”€â”€ Catalina (10.15)+
â”œâ”€â”€ Terminal/iTerm2
â”œâ”€â”€ Homebrew
â””â”€â”€ Command Line Tools
```

### Linux

```
LINUX SETUP
â”œâ”€â”€ Kernel 5.0+
â”œâ”€â”€ Terminal
â”œâ”€â”€ Package Manager
â””â”€â”€ Build Tools
```

## ConfiguraÃ§Ã£o do Windows

### 1. Habilitar WSL2

```POWERSHELL
# Habilitar WSL
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart

# Habilitar VirtualizaÃ§Ã£o
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart

# Definir WSL2 como padrÃ£o
wsl --set-default-version 2
```

### 2. Windows Terminal

```
TERMINAL FEATURES
â”œâ”€â”€ Multi-tabs
â”œâ”€â”€ Temas personalizados
â”œâ”€â”€ Split panes
â””â”€â”€ IntegraÃ§Ã£o WSL
```

### 3. VariÃ¡veis de Ambiente

```POWERSHELL
# Adicionar ao Path
[Environment]::SetEnvironmentVariable(
    "Path",
    [Environment]::GetEnvironmentVariable("Path", "Machine") + ";C:\your\path",
    "Machine"
)
```

## ConfiguraÃ§Ã£o do macOS

### 1. Homebrew

```BASH
# Instalar Homebrew
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Verificar instalaÃ§Ã£o
brew doctor
```

### 2. Command Line Tools

```BASH
# Instalar Command Line Tools
xcode-select --install

# Verificar instalaÃ§Ã£o
xcode-select -p
```

### 3. Terminal Enhancement

```BASH
# Instalar iTerm2
brew install --cask iterm2

# Instalar Oh My Zsh
sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
```

## ConfiguraÃ§Ã£o do Linux

### 1. Pacotes Essenciais

```BASH
# Ubuntu/Debian
sudo apt update
sudo apt install build-essential curl wget git

# Fedora
sudo dnf groupinstall "Development Tools"
sudo dnf install curl wget git
```

### 2. Terminal Setup

```BASH
# Instalar e configurar ZSH
sudo apt install zsh
chsh -s $(which zsh)

# Instalar Oh My Zsh
sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
```

## ConfiguraÃ§Ãµes Comuns

### 1. Git Global

```BASH
# ConfiguraÃ§Ã£o bÃ¡sica
git config --global user.name "Seu Nome"
git config --global user.email "seu@email.com"

# Editor padrÃ£o
git config --global core.editor "code --wait"
```

### 2. SSH Keys

```BASH
# Gerar nova chave SSH
ssh-keygen -t ed25519 -C "seu@email.com"

# Iniciar ssh-agent
eval "$(ssh-agent -s)"

# Adicionar chave
ssh-add ~/.ssh/id_ed25519
```

## PersonalizaÃ§Ã£o

### Terminal Theme

```JSON
{
    "colorScheme": "Cyberpunk",
    "fontFace": "Cascadia Code",
    "fontSize": 12,
    "useAcrylic": true,
    "acrylicOpacity": 0.8
}
```

### Aliases Ãšteis

```BASH
# Git aliases
alias gs='git status'
alias ga='git add'
alias gc='git commit'
alias gp='git push'

# Navigation
alias ll='ls -la'
alias ..='cd ..'
alias ...='cd ../..'
```

## Ambientes de Desenvolvimento Isolados

### SDKMAN! com Docker

```
FROM ubuntu:22.04

# Instalar dependÃªncias
RUN apt-get update && apt-get install -y \
    curl \
    zip \
    unzip

# Instalar SDKMAN!
RUN curl -s "https://get.sdkman.io" | bash
ENV SDKMAN_DIR="/root/.sdkman"

# Configurar ambiente
COPY .sdkmanrc /app/.sdkmanrc
WORKDIR /app

# Instalar SDKs
RUN bash -c "source $SDKMAN_DIR/bin/sdkman-init.sh && \
    sdk env install"
```

### Gerenciamento de VersÃµes por Projeto

```
PROJECT STRUCTURE
â”œâ”€â”€ .sdkmanrc        # VersÃµes do projeto
â”œâ”€â”€ .java-version    # Alternativa para Java
â””â”€â”€ docker-compose.yml
```

### Exemplo de docker-compose.yml

```YAML
version: '3.8'
services:
  java-dev:
    build: .
    volumes:
      - .:/app
    environment:
      - SDKMAN_DIR=/root/.sdkman
```

### Scripts de AutomaÃ§Ã£o

```BASH
#!/bin/bash
# setup-dev.sh

# Verificar SDKMAN!
if ! command -v sdk &> /dev/null; then
    echo "Instalando SDKMAN!..."
    curl -s "https://get.sdkman.io" | bash
fi

# Carregar SDKMAN!
source "$HOME/.sdkman/bin/sdkman-init.sh"

# Instalar versÃµes do projeto
if [ -f .sdkmanrc ]; then
    echo "Configurando ambiente do projeto..."
    sdk env install
fi
```

### IntegraÃ§Ã£o com IDEs

```
IDE INTEGRATION
â”œâ”€â”€ IntelliJ IDEA
â”‚   â””â”€â”€ Project SDK
â”œâ”€â”€ Eclipse
â”‚   â””â”€â”€ Installed JREs
â””â”€â”€ VS Code
    â””â”€â”€ Java Runtime
```

### VerificaÃ§Ã£o de Ambiente

```BASH
# Verificar todas as versÃµes instaladas
sdk current

# Listar candidatos instalados
sdk list

# Verificar ambiente do projeto
sdk env
```

## VerificaÃ§Ã£o

### Checklist Final

* [ ] Sistema atualizado

* [ ] Terminal configurado

* [ ] Git instalado

* [ ] SSH configurado

* [ ] Aliases definidos

### Teste de Ambiente

```BASH
# Verificar versÃµes
java -version
git --version
node --version

# Testar SSH
ssh -T git@github.com
```

## Troubleshooting

### Problemas Comuns

1. WSL nÃ£o inicia

* Verificar virtualizaÃ§Ã£o no BIOS

* Reinstalar WSL

* Atualizar Windows

2. Homebrew falha

* Verificar permissÃµes

* Atualizar macOS

* Reinstalar Xcode CLI

3. Linux packages quebrados

* Limpar cache

* Atualizar repositÃ³rios

* Verificar dependÃªncias

[Explorar Ferramentas](tools-overview.html)

Tip:

"Configure seu sistema como um verdadeiro netrunner - cada detalhe importa na Matrix."



# VisÃ£o Geral das Ferramentas

```
NETRUNNER TOOLKIT
â”œâ”€â”€ Development
â”‚   â”œâ”€â”€ JDK
â”‚   â”œâ”€â”€ IDE
â”‚   â””â”€â”€ Build Tools
â”œâ”€â”€ Version Control
â”‚   â”œâ”€â”€ Git
â”‚   â””â”€â”€ GitHub/GitLab
â”œâ”€â”€ Containers
â”‚   â”œâ”€â”€ Docker
â”‚   â””â”€â”€ Kubernetes
â””â”€â”€ Cloud Tools
    â”œâ”€â”€ AWS CLI
    â”œâ”€â”€ Azure CLI
    â””â”€â”€ GCloud SDK
```

## Ferramentas Essenciais

### JDK (Java Development Kit)

```
JDK DISTRIBUTIONS
â”œâ”€â”€ Oracle JDK
â”œâ”€â”€ OpenJDK
â”œâ”€â”€ Amazon Corretto
â”œâ”€â”€ Eclipse Temurin
â””â”€â”€ GraalVM
```

#### Gerenciadores de VersÃ£o

* SDKMAN! - Gerenciamento de SDKs

* Jabba - Alternativa multiplataforma

* jEnv - EspecÃ­fico para Unix

### IDEs (Integrated Development Environment)

```
IDE OPTIONS
â”œâ”€â”€ IntelliJ IDEA
â”‚   â”œâ”€â”€ Community Edition
â”‚   â””â”€â”€ Ultimate Edition
â”œâ”€â”€ Eclipse
â”‚   â””â”€â”€ Enterprise Edition
â”œâ”€â”€ VS Code
â”‚   â””â”€â”€ Java Extensions
â””â”€â”€ NetBeans
```

#### Recursos Principais

* Debugging avanÃ§ado

* IntegraÃ§Ã£o com ferramentas

* RefatoraÃ§Ã£o inteligente

* Suporte a frameworks

### Build Tools

```
BUILD SYSTEMS
â”œâ”€â”€ Maven
â”‚   â”œâ”€â”€ Dependency Management
â”‚   â””â”€â”€ Lifecycle Management
â”œâ”€â”€ Gradle
â”‚   â”œâ”€â”€ Groovy DSL
â”‚   â””â”€â”€ Kotlin DSL
â””â”€â”€ Ant (Legacy)
```

## Ferramentas de Controle de VersÃ£o

### Git

```
GIT ESSENTIALS
â”œâ”€â”€ Controle de versÃ£o
â”œâ”€â”€ Branching
â”œâ”€â”€ Merging
â””â”€â”€ ColaboraÃ§Ã£o
```

### Interfaces Git

```
GIT GUI TOOLS
â”œâ”€â”€ GitKraken
â”œâ”€â”€ SourceTree
â”œâ”€â”€ GitHub Desktop
â””â”€â”€ IDE Integration
```

## Ferramentas de Container

### Docker

```
DOCKER STACK
â”œâ”€â”€ Docker Engine
â”œâ”€â”€ Docker Compose
â”œâ”€â”€ Docker Hub
â””â”€â”€ Docker Desktop
```

### Container Registry

```
REGISTRY OPTIONS
â”œâ”€â”€ Docker Hub
â”œâ”€â”€ GitHub Packages
â”œâ”€â”€ AWS ECR
â””â”€â”€ Azure Container Registry
```

## Ferramentas Cloud

### CLI Tools

```
CLOUD TOOLS
â”œâ”€â”€ AWS CLI
â”œâ”€â”€ Azure CLI
â”œâ”€â”€ Google Cloud SDK
â””â”€â”€ Heroku CLI
```

### Cloud IDEs

```
CLOUD DEVELOPMENT
â”œâ”€â”€ GitHub Codespaces
â”œâ”€â”€ GitPod
â”œâ”€â”€ Cloud9
â””â”€â”€ Eclipse Che
```

## Ferramentas de Produtividade

### Terminal

```
TERMINAL SETUP
â”œâ”€â”€ Windows Terminal
â”œâ”€â”€ iTerm2 (macOS)
â”œâ”€â”€ Terminator (Linux)
â””â”€â”€ Shell
    â”œâ”€â”€ Bash
    â”œâ”€â”€ Zsh
    â””â”€â”€ Fish
```

### ExtensÃµes Recomendadas

#### VS Code

```
VS CODE EXTENSIONS
â”œâ”€â”€ Java Extension Pack
â”œâ”€â”€ Spring Boot Tools
â”œâ”€â”€ Debugger for Java
â””â”€â”€ Test Runner
```

#### IntelliJ IDEA

```
INTELLIJ PLUGINS
â”œâ”€â”€ Lombok
â”œâ”€â”€ SonarLint
â”œâ”€â”€ GitToolBox
â””â”€â”€ Rainbow Brackets
```

## Ferramentas de Teste

### Testing Framework

```
TEST TOOLS
â”œâ”€â”€ JUnit
â”œâ”€â”€ TestNG
â”œâ”€â”€ Mockito
â””â”€â”€ AssertJ
```

### AnÃ¡lise de CÃ³digo

```
CODE QUALITY
â”œâ”€â”€ SonarQube
â”œâ”€â”€ CheckStyle
â”œâ”€â”€ PMD
â””â”€â”€ SpotBugs
```

## Ferramentas de DocumentaÃ§Ã£o

### Documentation

```
DOCUMENTATION
â”œâ”€â”€ JavaDoc
â”œâ”€â”€ Swagger/OpenAPI
â”œâ”€â”€ AsciiDoc
â””â”€â”€ Markdown
```

## Setup Inicial

### Checklist de InstalaÃ§Ã£o

* [ ] JDK via SDKMAN!

* [ ] IDE principal

* [ ] Git

* [ ] Docker

* [ ] Cloud CLI necessÃ¡ria

* [ ] Terminal configurado

### ConfiguraÃ§Ã£o Recomendada

```BASH
# Instalar JDK
sdk install java

# Configurar Git
git config --global user.name "Seu Nome"
git config --global user.email "seu@email.com"

# Verificar Docker
docker --version
```

## ManutenÃ§Ã£o

### AtualizaÃ§Ãµes Regulares

```
UPDATE ROUTINE
â”œâ”€â”€ JDK patches
â”œâ”€â”€ IDE updates
â”œâ”€â”€ Docker images
â””â”€â”€ Dependencies
```

### Backup de ConfiguraÃ§Ãµes

```
BACKUP ESSENTIALS
â”œâ”€â”€ IDE settings
â”œâ”€â”€ Git config
â”œâ”€â”€ Docker config
â””â”€â”€ Terminal preferences
```

## Troubleshooting

### Problemas Comuns

1. Conflitos de VersÃ£o Java

* Usar SDKMAN! para gerenciar versÃµes

* Verificar JAVA_HOME

* Limpar caches

2. Problemas IDE

* Limpar caches

* Atualizar Ã­ndices

* Reinstalar plugins

3. Issues Docker

* Verificar serviÃ§o

* Limpar volumes

* Reset configuraÃ§Ãµes

[ComeÃ§ar InstalaÃ§Ã£o JDK](jdk-installation.html)

Tip:

"Um netrunner Ã© tÃ£o bom quanto suas ferramentas. Escolha-as sabiamente."



# Setup do Ambiente de Desenvolvimento

```
SYSTEM INITIALIZATION
â”œâ”€â”€ JDK Setup
â”œâ”€â”€ IDE Config
â”œâ”€â”€ Git Setup
â”œâ”€â”€ Docker Init
â”œâ”€â”€ Cloud Tools
â””â”€â”€ Terminal Setup
```

## VisÃ£o Geral

### Requisitos MÃ­nimos

```
MINIMUM SPECS
â”œâ”€â”€ CPU: 2+ cores
â”œâ”€â”€ RAM: 8GB+
â”œâ”€â”€ Storage: 10GB+
â””â”€â”€ Internet: 10Mbps+
```

### Componentes Principais

* Java Development Kit (JDK)

* Ambiente de Desenvolvimento Integrado (IDE)

* Sistema de Controle de VersÃ£o

* Ferramentas de ContainerizaÃ§Ã£o

* CLIs de Cloud

* Terminal Configurado

## Ordem de InstalaÃ§Ã£o

### SequÃªncia Recomendada

1. [InstalaÃ§Ã£o do JDK](jdk-installation.html)

2. [ConfiguraÃ§Ã£o da IDE](ide-setup.html)

3. [BÃ¡sico do Git](git-basics.html)

4. [Essenciais do Terminal](terminal-essentials.html)

5. [BÃ¡sico do Docker](docker-basics.html)

6. [Setup Cloud](cloud-setup.html)

## VerificaÃ§Ã£o de Ambiente

### Checklist de ValidaÃ§Ã£o

```BASH
# Verificar Java
java --version

# Verificar Git
git --version

# Verificar Docker
docker --version

# Verificar Cloud CLI
aws --version  # ou
az --version   # ou
gcloud --version
```

## PrÃ³ximos Passos

### ConfiguraÃ§Ã£o AvanÃ§ada

* PersonalizaÃ§Ã£o da IDE

* ConfiguraÃ§Ã£o do Git

* Setup de Containers

* IntegraÃ§Ã£o Cloud

[Iniciar InstalaÃ§Ã£o do JDK](jdk-installation.html)

Tip:

"A preparaÃ§Ã£o adequada Ã© metade da batalha. Configure seu ambiente com precisÃ£o."



# InstalaÃ§Ã£o do JDK

```
JDK INSTALLATION
â”œâ”€â”€ SDKMAN! Setup
â”œâ”€â”€ JDK Selection
â”œâ”€â”€ Environment Config
â””â”€â”€ Validation
```

## SDKMAN!

### InstalaÃ§Ã£o do SDKMAN!

```BASH
# Download e instalaÃ§Ã£o
curl -s "https://get.sdkman.io" | bash

# Recarregar shell
source "$HOME/.sdkman/bin/sdkman-init.sh"

# Verificar instalaÃ§Ã£o
sdk version
```

### Comandos BÃ¡sicos

```
SDKMAN COMMANDS
â”œâ”€â”€ sdk list java     # Listar versÃµes
â”œâ”€â”€ sdk install java  # Instalar JDK
â”œâ”€â”€ sdk use java     # Usar versÃ£o
â””â”€â”€ sdk default java # Definir padrÃ£o
```

## InstalaÃ§Ã£o do JDK

### Escolha da DistribuiÃ§Ã£o

```
JDK OPTIONS
â”œâ”€â”€ Oracle JDK
â”‚   â””â”€â”€ LicenÃ§a comercial
â”œâ”€â”€ OpenJDK
â”‚   â””â”€â”€ Open source
â”œâ”€â”€ Amazon Corretto
â”‚   â””â”€â”€ AWS optimized
â”œâ”€â”€ Eclipse Temurin
â”‚   â””â”€â”€ AdoptOpenJDK successor
â””â”€â”€ GraalVM
    â””â”€â”€ Native compilation
```

### InstalaÃ§Ã£o via SDKMAN!

```BASH
# Listar versÃµes disponÃ­veis
sdk list java

# Instalar JDK LTS
sdk install java 17.0.8-tem

# Definir como padrÃ£o
sdk default java 17.0.8-tem
```

## ConfiguraÃ§Ã£o do Ambiente

### VariÃ¡veis de Ambiente

```BASH
# Verificar JAVA_HOME
echo $JAVA_HOME

# Verificar PATH
echo $PATH | grep java
```

### ConfiguraÃ§Ã£o Manual (se necessÃ¡rio)

```BASH
# Para Bash/Zsh
echo "export JAVA_HOME=$HOME/.sdkman/candidates/java/current" >> ~/.bashrc
echo "export PATH=\$JAVA_HOME/bin:\$PATH" >> ~/.bashrc

# Para Fish
set -Ux JAVA_HOME $HOME/.sdkman/candidates/java/current
set -Ux PATH $JAVA_HOME/bin $PATH
```

## VerificaÃ§Ã£o da InstalaÃ§Ã£o

### Testes BÃ¡sicos

```BASH
# Verificar versÃ£o Java
java --version

# Verificar compilador
javac --version

# Testar compilaÃ§Ã£o
echo 'public class Test { public static void main(String[] args) { System.out.println("Hello, NetRunner!"); } }' > Test.java
javac Test.java
java Test
```

## Multi-versÃ£o

### Gerenciamento de VersÃµes

```BASH
# Instalar mÃºltiplas versÃµes
sdk install java 11.0.20-tem
sdk install java 17.0.8-tem
sdk install java 21-tem

# Alternar entre versÃµes
sdk use java 11.0.20-tem  # TemporÃ¡rio
sdk default java 17.0.8-tem  # Permanente
```

### ConfiguraÃ§Ã£o por Projeto

```BASH
# Criar arquivo de configuraÃ§Ã£o
echo "java=17.0.8-tem" > .sdkmanrc

# Ativar ambiente do projeto
sdk env
```

## Troubleshooting

### Problemas Comuns

1. SDKMAN! nÃ£o instala

* Verificar curl instalado

* Verificar permissÃµes

* Verificar conexÃ£o

2. JDK nÃ£o encontrado

* Recarregar terminal

* Verificar PATH

* Verificar JAVA_HOME

3. Conflitos de versÃ£o

* Usar `sdk flush`

* Remover versÃ£o: `sdk rm java`

* Reinstalar SDKMAN!

## PrÃ³ximos Passos

### ConfiguraÃ§Ã£o IDE

* Configurar Project SDK

* Importar projetos

* Configurar build tools

[Configurar IDE](ide-setup.html)

Tip:

"A base de todo netrunner Ã© um JDK bem configurado. Escolha suas armas com sabedoria."



# ConfiguraÃ§Ã£o da IDE

```
IDE SETUP
â”œâ”€â”€ IntelliJ IDEA
â”œâ”€â”€ Eclipse
â”œâ”€â”€ VS Code
â””â”€â”€ NetBeans
```

## IntelliJ IDEA

### InstalaÃ§Ã£o

```
INTELLIJ VARIANTS
â”œâ”€â”€ Community Edition
â”‚   â””â”€â”€ Open Source
â””â”€â”€ Ultimate Edition
    â””â”€â”€ Trial/Licensed
```

```BASH
# Linux (snap)
sudo snap install intellij-idea-community --classic

# macOS (brew)
brew install --cask intellij-idea-ce

# Windows
winget install JetBrains.IntelliJ.IDEA.Community
```

### Plugins Essenciais

```
CORE PLUGINS
â”œâ”€â”€ Java Development
â”œâ”€â”€ Git Integration
â”œâ”€â”€ Maven/Gradle
â””â”€â”€ Docker
```

### ConfiguraÃ§Ã£o Inicial

```
INITIAL SETUP
â”œâ”€â”€ Project SDK
â”œâ”€â”€ Code Style
â”œâ”€â”€ File Templates
â””â”€â”€ Live Templates
```

## Visual Studio Code

### InstalaÃ§Ã£o

```BASH
# Linux
sudo snap install code --classic

# macOS
brew install --cask visual-studio-code

# Windows
winget install Microsoft.VisualStudioCode
```

### ExtensÃµes Java

```
EXTENSIONS
â”œâ”€â”€ Extension Pack for Java
â”œâ”€â”€ Spring Boot Extension Pack
â”œâ”€â”€ Java Test Runner
â””â”€â”€ Debugger for Java
```

### ConfiguraÃ§Ãµes Recomendadas

```JSON
{
    "java.home": "/path/to/jdk",
    "java.format.settings.url": "eclipse-formatter.xml",
    "java.completion.importOrder": [
        "java",
        "javax",
        "com",
        "org"
    ]
}
```

## Eclipse

### InstalaÃ§Ã£o

```
ECLIPSE PACKAGES
â”œâ”€â”€ Eclipse IDE for Java
â”œâ”€â”€ Eclipse IDE for Enterprise
â””â”€â”€ Eclipse IDE for Web
```

```BASH
# Linux
sudo snap install eclipse --classic

# macOS
brew install --cask eclipse-java

# Windows
winget install Eclipse.Java
```

### Plugins Recomendados

```
ECLIPSE PLUGINS
â”œâ”€â”€ EGit
â”œâ”€â”€ Spring Tools
â”œâ”€â”€ CodeMix
â””â”€â”€ Darkest Dark Theme
```

## ConfiguraÃ§Ãµes AvanÃ§adas

### PersonalizaÃ§Ã£o

```
CUSTOMIZATION
â”œâ”€â”€ Theme Setup
â”œâ”€â”€ Keymap Config
â”œâ”€â”€ Code Templates
â””â”€â”€ Live Templates
```

### IntegraÃ§Ã£o Git

```
GIT SETUP
â”œâ”€â”€ SSH Keys
â”œâ”€â”€ GitHub Integration
â”œâ”€â”€ GitLab Integration
â””â”€â”€ Bitbucket Integration
```

### Debug & Profiling

```
DEBUG TOOLS
â”œâ”€â”€ Remote Debug
â”œâ”€â”€ Memory Analyzer
â”œâ”€â”€ CPU Profiler
â””â”€â”€ Thread Dump
```

## Produtividade

### Atalhos Essenciais

```
SHORTCUTS
â”œâ”€â”€ Code Completion
â”‚   â”œâ”€â”€ Ctrl+Space
â”‚   â””â”€â”€ Alt+Enter
â”œâ”€â”€ Navigation
â”‚   â”œâ”€â”€ Ctrl+Click
â”‚   â””â”€â”€ Alt+F7
â”œâ”€â”€ Refactoring
â”‚   â”œâ”€â”€ Shift+F6
â”‚   â””â”€â”€ Ctrl+Alt+M
â””â”€â”€ Debug
    â”œâ”€â”€ F8
    â””â”€â”€ F9
```

### Templates

```JAVA
// Live Template: psvm
public static void main(String[] args) {
    
}

// Live Template: sout
System.out.println();

// Live Template: fori
for (int i = 0; i < ; i++) {
    
}
```

## Troubleshooting

### Problemas Comuns

1. IDE nÃ£o reconhece JDK

* Verificar JAVA_HOME

* Reconfigurar Project SDK

* Invalidar caches

2. Performance lenta

* Aumentar heap memory

* Desabilitar plugins

* Limpar Ã­ndices

3. Problemas de indexaÃ§Ã£o

* Invalidar caches

* Reconstruir Ã­ndices

* Verificar exclusÃµes

## ConfiguraÃ§Ã£o do Projeto

### Estrutura BÃ¡sica

```
PROJECT STRUCTURE
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/
â”‚   â”‚   â”œâ”€â”€ java/
â”‚   â”‚   â””â”€â”€ resources/
â”‚   â””â”€â”€ test/
â”‚       â”œâ”€â”€ java/
â”‚       â””â”€â”€ resources/
â”œâ”€â”€ pom.xml
â””â”€â”€ .gitignore
```

### Build Tools

```
BUILD CONFIG
â”œâ”€â”€ Maven
â”‚   â””â”€â”€ pom.xml
â””â”€â”€ Gradle
    â””â”€â”€ build.gradle
```

## PrÃ³ximos Passos

### Workflow Setup

* Configurar formataÃ§Ã£o de cÃ³digo

* Definir templates de projeto

* Configurar integraÃ§Ã£o contÃ­nua

* Preparar ambiente de debug

[Configurar Git](git-basics.html)

Tip:

"Uma IDE bem configurada Ã© como ter um deck cyberdeck personalizado - aumenta exponencialmente sua eficiÃªncia na Matrix."



# Git BÃ¡sico

```
GIT FUNDAMENTALS
â”œâ”€â”€ Setup Inicial
â”œâ”€â”€ OperaÃ§Ãµes BÃ¡sicas
â”œâ”€â”€ Branching
â”œâ”€â”€ Remote Operations
â””â”€â”€ Best Practices
```

## InstalaÃ§Ã£o e Setup

### InstalaÃ§Ã£o

```BASH
# Linux (Debian/Ubuntu)
sudo apt install git

# macOS
brew install git

# Windows
winget install Git.Git
```

### ConfiguraÃ§Ã£o Inicial

```BASH
# Identidade
git config --global user.name "Seu Nome"
git config --global user.email "seu@email.com"

# Editor padrÃ£o
git config --global core.editor "code --wait"  # VS Code
# git config --global core.editor "vim"        # Vim
# git config --global core.editor "nano"       # Nano

# Configurar branch padrÃ£o
git config --global init.defaultBranch main
```

## OperaÃ§Ãµes BÃ¡sicas

### Ciclo de Vida

```
FILE STATUS
â”œâ”€â”€ Untracked
â”œâ”€â”€ Staged
â”œâ”€â”€ Committed
â””â”€â”€ Modified
```

### Comandos Essenciais

```BASH
# Iniciar repositÃ³rio
git init

# Status do repositÃ³rio
git status

# Adicionar arquivos
git add <arquivo>      # Arquivo especÃ­fico
git add .              # Todos os arquivos

# Commit
git commit -m "mensagem"
git commit -am "mensagem"  # Add + Commit

# HistÃ³rico
git log
git log --oneline
git log --graph
```

## Branches

### OperaÃ§Ãµes com Branches

```BASH
# Listar branches
git branch

# Criar branch
git branch feature/nova-funcionalidade

# Mudar de branch
git checkout feature/nova-funcionalidade
# ou
git switch feature/nova-funcionalidade

# Criar e mudar
git checkout -b feature/nova-funcionalidade
```

### Merge e Rebase

```BASH
# Merge
git checkout main
git merge feature/nova-funcionalidade

# Rebase
git checkout feature/nova-funcionalidade
git rebase main
```

## OperaÃ§Ãµes Remotas

### ConfiguraÃ§Ã£o Remota

```BASH
# Adicionar remote
git remote add origin https://github.com/user/repo.git

# Listar remotes
git remote -v

# Remover remote
git remote remove origin
```

### SincronizaÃ§Ã£o

```BASH
# Push
git push origin main

# Pull
git pull origin main

# Fetch
git fetch origin

# Clone
git clone https://github.com/user/repo.git
```

## Gitflow

### Estrutura de Branches

```
BRANCH STRUCTURE
â”œâ”€â”€ main
â”œâ”€â”€ develop
â”œâ”€â”€ feature/*
â”œâ”€â”€ release/*
â”œâ”€â”€ hotfix/*
â””â”€â”€ bugfix/*
```

### Workflow BÃ¡sico

```
WORKFLOW
â”œâ”€â”€ Criar feature branch
â”œâ”€â”€ Desenvolver
â”œâ”€â”€ Commit changes
â”œâ”€â”€ Push to remote
â””â”€â”€ Create pull request
```

## Boas PrÃ¡ticas

### Commits

```
COMMIT PATTERNS
â”œâ”€â”€ Conventional Commits
â”‚   â”œâ”€â”€ feat: nova feature
â”‚   â”œâ”€â”€ fix: correÃ§Ã£o
â”‚   â”œâ”€â”€ docs: documentaÃ§Ã£o
â”‚   â”œâ”€â”€ style: formataÃ§Ã£o
â”‚   â”œâ”€â”€ refactor: refatoraÃ§Ã£o
â”‚   â”œâ”€â”€ test: testes
â”‚   â””â”€â”€ chore: manutenÃ§Ã£o
â””â”€â”€ Atomic Commits
```

### .gitignore

```BASH
# Java
*.class
*.jar
target/

# IDEs
.idea/
.vscode/
*.iml

# Logs
*.log
logs/

# OS
.DS_Store
Thumbs.db
```

## Git AvanÃ§ado

### Stash

```BASH
# Salvar alteraÃ§Ãµes
git stash

# Listar stashes
git stash list

# Aplicar stash
git stash apply
git stash pop

# Limpar stash
git stash clear
```

### Reset e Revert

```BASH
# Reset
git reset --soft HEAD~1   # MantÃ©m alteraÃ§Ãµes
git reset --hard HEAD~1   # Remove alteraÃ§Ãµes

# Revert
git revert HEAD          # Reverte Ãºltimo commit
```

## Troubleshooting

### Problemas Comuns

1. Conflitos de Merge

```BASH
# Abortar merge
git merge --abort

# Resolver manualmente
# Editar arquivos
git add .
git commit
```

2. Branch Errada

```BASH
# Mover alteraÃ§Ãµes
git stash
git checkout branch-correta
git stash pop
```

3. Commit Errado

```BASH
# Desfazer Ãºltimo commit
git reset --soft HEAD~1

# Alterar mensagem
git commit --amend
```

## Ferramentas Visuais

### GUI Clients

```
GUI OPTIONS
â”œâ”€â”€ GitKraken
â”œâ”€â”€ SourceTree
â”œâ”€â”€ GitHub Desktop
â””â”€â”€ Git GUI
```

## PrÃ³ximos Passos

### Aprofundamento

* Explorar Git hooks

* Configurar CI/CD

* Aprender rebase interativo

* Estudar estratÃ©gias de branching

[Essenciais do Terminal](terminal-essentials.html)

Tip:

"No submundo digital, o controle de versÃ£o Ã© sua linha do tempo pessoal - cada commit Ã© um checkpoint que vocÃª pode revisitar."



# Essenciais do Terminal

```
TERMINAL MASTERY
â”œâ”€â”€ BÃ¡sico
â”œâ”€â”€ NavegaÃ§Ã£o
â”œâ”€â”€ ManipulaÃ§Ã£o
â”œâ”€â”€ Processos
â””â”€â”€ CustomizaÃ§Ã£o
```

## Comandos Fundamentais

### NavegaÃ§Ã£o

```BASH
# Listar arquivos
ls
ls -la

# Mudar diretÃ³rio
cd path/to/dir
cd ..
cd ~

# Mostrar diretÃ³rio atual
pwd
```

### ManipulaÃ§Ã£o de Arquivos

```BASH
# Criar
touch arquivo.txt
mkdir pasta

# Copiar
cp origem destino
cp -r pasta1 pasta2

# Mover/Renomear
mv origem destino

# Remover
rm arquivo.txt
rm -r pasta
```

### VisualizaÃ§Ã£o

```BASH
# Ver conteÃºdo
cat arquivo.txt
less arquivo.txt
head arquivo.txt
tail arquivo.txt

# Buscar
grep "texto" arquivo.txt
find . -name "*.java"
```

## PermissÃµes

### Gerenciamento

```BASH
# Visualizar
ls -l

# Modificar
chmod +x script.sh
chmod 755 arquivo

# Mudar proprietÃ¡rio
chown usuario:grupo arquivo
```

## Processos

### Gerenciamento

```BASH
# Listar processos
ps aux
top

# Background
comando &
bg
fg

# Terminar processo
kill PID
killall processo
```

## Redirecionamento

### Input/Output

```BASH
# Redirecionamento
comando > output.txt
comando >> output.txt
comando < input.txt

# Pipes
comando1 | comando2
```

## Ambiente

### VariÃ¡veis

```BASH
# Exibir
echo $PATH
env

# Definir
export JAVA_HOME=/path/to/java
```

## CustomizaÃ§Ã£o

### Shell RC

```BASH
# .bashrc ou .zshrc
alias ll='ls -la'
alias gs='git status'

# Path
export PATH=$PATH:/novo/caminho
```

## Atalhos

### Keyboard Shortcuts

```
SHORTCUTS
â”œâ”€â”€ Ctrl + C  (Cancelar)
â”œâ”€â”€ Ctrl + L  (Limpar)
â”œâ”€â”€ Ctrl + R  (Buscar histÃ³rico)
â”œâ”€â”€ Ctrl + A  (InÃ­cio da linha)
â””â”€â”€ Ctrl + E  (Fim da linha)
```

## Scripts

### Shell Scripts

```BASH
#!/bin/bash

# Exemplo bÃ¡sico
echo "Iniciando script..."
for i in {1..5}; do
    echo "IteraÃ§Ã£o $i"
done
```

## Ferramentas AvanÃ§adas

### Power Tools

```
POWER TOOLS
â”œâ”€â”€ tmux    (Terminal Multiplexer)
â”œâ”€â”€ vim     (Editor)
â”œâ”€â”€ htop    (Process Viewer)
â””â”€â”€ fzf     (Fuzzy Finder)
```

## Troubleshooting

### Debug

```BASH
# Debug modo
set -x

# Verificar status
echo $?

# Ver logs
tail -f /var/log/syslog
```

## PrÃ³ximos Passos

### Aprofundamento

* Shell scripting avanÃ§ado

* AutomaÃ§Ã£o com cron

* Terminal multiplexing

* CustomizaÃ§Ã£o avanÃ§ada

[BÃ¡sico do Docker](docker-basics.html)

Tip:

"O terminal Ã© sua interface direta com a Matrix - domine-o, e vocÃª controlarÃ¡ o sistema."



# Docker BÃ¡sico

```
DOCKER ESSENTIALS
â”œâ”€â”€ Conceitos
â”œâ”€â”€ InstalaÃ§Ã£o
â”œâ”€â”€ Comandos BÃ¡sicos
â”œâ”€â”€ Docker Compose
â””â”€â”€ Best Practices
```

## Fundamentos

### Conceitos BÃ¡sicos

```
DOCKER COMPONENTS
â”œâ”€â”€ Images
â”œâ”€â”€ Containers
â”œâ”€â”€ Volumes
â”œâ”€â”€ Networks
â””â”€â”€ Registry
```

### InstalaÃ§Ã£o

```BASH
# Linux (Ubuntu)
curl -fsSL https://get.docker.com | sh

# Windows/Mac
# Baixar Docker Desktop do site oficial
```

## Comandos Essenciais

### Gerenciamento de Containers

```BASH
# Executar container
docker run hello-world
docker run -d -p 8080:80 nginx

# Listar containers
docker ps
docker ps -a

# OperaÃ§Ãµes
docker start container_id
docker stop container_id
docker restart container_id
docker rm container_id
```

### Imagens

```BASH
# Listar imagens
docker images

# Pull de imagem
docker pull ubuntu:latest

# Remover imagem
docker rmi imagem_id

# Build de imagem
docker build -t app:1.0 .
```

## Dockerfile

### Estrutura BÃ¡sica

```
# Base image
FROM openjdk:17-jdk-slim

# Metadados
LABEL maintainer="netrunner@corp.net"

# DiretÃ³rio de trabalho
WORKDIR /app

# Copiar arquivos
COPY target/*.jar app.jar

# Porta
EXPOSE 8080

# Comando de execuÃ§Ã£o
CMD ["java", "-jar", "app.jar"]
```

## Docker Compose

### docker-compose.yml

```YAML
version: '3.8'
services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - DB_HOST=db
    depends_on:
      - db
  
  db:
    image: postgres:13
    environment:
      - POSTGRES_PASSWORD=secret
```

### Comandos Compose

```BASH
# Iniciar serviÃ§os
docker-compose up -d

# Parar serviÃ§os
docker-compose down

# Logs
docker-compose logs
```

## Redes

### Network Commands

```BASH
# Criar rede
docker network create mynet

# Listar redes
docker network ls

# Conectar container
docker network connect mynet container_id
```

## Volumes

### Volume Management

```BASH
# Criar volume
docker volume create mydata

# Listar volumes
docker volume ls

# Usar volume
docker run -v mydata:/data nginx
```

## Troubleshooting

### Problemas Comuns

```BASH
# Verificar logs
docker logs container_id

# Inspecionar container
docker inspect container_id

# Entrar no container
docker exec -it container_id bash
```

## SeguranÃ§a

### Best Practices

```
SECURITY CHECKLIST
â”œâ”€â”€ Usar imagens oficiais
â”œâ”€â”€ Manter containers atualizados
â”œâ”€â”€ Limitar recursos
â”œâ”€â”€ Usar usuÃ¡rios nÃ£o-root
â””â”€â”€ Escanear vulnerabilidades
```

## Monitoramento

### Ferramentas

```
MONITORING TOOLS
â”œâ”€â”€ Docker Stats
â”œâ”€â”€ Prometheus
â”œâ”€â”€ Grafana
â””â”€â”€ cAdvisor
```

## PrÃ³ximos Passos

### Aprofundamento

* OrquestraÃ§Ã£o com Kubernetes

* CI/CD com Docker

* Docker Swarm

* MicroserviÃ§os

[Setup Cloud](cloud-setup.html)

Tip:

"Containers sÃ£o como cÃ¡psulas de dados na Matrix - isolados, portÃ¡teis e prontos para deployment."



# Setup Cloud

```
CLOUD SETUP
â”œâ”€â”€ Providers
â”œâ”€â”€ CLI Tools
â”œâ”€â”€ Authentication
â””â”€â”€ Basic Services
```

## Cloud Providers

### Principais Provedores

```
CLOUD OPTIONS
â”œâ”€â”€ AWS
â”œâ”€â”€ Azure
â”œâ”€â”€ Google Cloud
â””â”€â”€ Oracle Cloud
```

## CLI Setup

### AWS CLI

```BASH
# Instalar AWS CLI
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install

# Configurar
aws configure
```

### Azure CLI

```BASH
# Instalar Azure CLI
curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

# Login
az login
```

### Google Cloud SDK

```BASH
# Instalar Google Cloud SDK
curl https://sdk.cloud.google.com | bash

# Inicializar
gcloud init
```

## AutenticaÃ§Ã£o

### Credenciais

```
AUTH METHODS
â”œâ”€â”€ Access Keys
â”œâ”€â”€ Service Accounts
â”œâ”€â”€ IAM Roles
â””â”€â”€ MFA
```

### ConfiguraÃ§Ã£o

```BASH
# AWS Credentials
aws configure set aws_access_key_id YOUR_KEY
aws configure set aws_secret_access_key YOUR_SECRET

# GCloud Auth
gcloud auth login
gcloud config set project YOUR_PROJECT
```

## ServiÃ§os BÃ¡sicos

### Storage

```
STORAGE SERVICES
â”œâ”€â”€ AWS S3
â”œâ”€â”€ Azure Blob
â””â”€â”€ Google Cloud Storage
```

### Compute

```
COMPUTE SERVICES
â”œâ”€â”€ EC2/VM
â”œâ”€â”€ Container Services
â””â”€â”€ Serverless
```

## Networking

### VPC Setup

```
NETWORK CONFIG
â”œâ”€â”€ VPC/VNET
â”œâ”€â”€ Subnets
â”œâ”€â”€ Security Groups
â””â”€â”€ Load Balancers
```

## Monitoramento

### Ferramentas Cloud

```
MONITORING
â”œâ”€â”€ CloudWatch
â”œâ”€â”€ Azure Monitor
â””â”€â”€ Cloud Monitoring
```

## SeguranÃ§a

### Best Practices

```
SECURITY CHECKLIST
â”œâ”€â”€ MFA Ativado
â”œâ”€â”€ Least Privilege
â”œâ”€â”€ Encryption
â””â”€â”€ Logging
```

## Cost Management

### Controle de Custos

```
COST CONTROL
â”œâ”€â”€ Budgets
â”œâ”€â”€ Alerts
â”œâ”€â”€ Resource Tags
â””â”€â”€ Cost Explorer
```

## PrÃ³ximos Passos

### Aprofundamento

* Infrastructure as Code

* Cloud Native Development

* Serverless Architecture

* Multi-Cloud Strategy

[ComeÃ§ar com Java](java-basics.html)

Tip:

"A nuvem Ã© a nova fronteira da Matrix - um territÃ³rio vasto de recursos virtualizados prontos para serem explorados."



# Fundamentos Java

```
JAVA BASICS
â”œâ”€â”€ Estrutura
â”œâ”€â”€ Sintaxe
â”œâ”€â”€ Tipos
â”œâ”€â”€ Operadores
â””â”€â”€ Strings
```

## Estrutura de um Programa

### Anatomia BÃ¡sica

```JAVA
// Arquivo: HelloMatrix.java
public class HelloMatrix {
    public static void main(String[] args) {
        System.out.println("Iniciando conexÃ£o com a Matrix...");
    }
}
```

### Componentes Principais

```
JAVA STRUCTURE
â”œâ”€â”€ Package Declaration
â”œâ”€â”€ Imports
â”œâ”€â”€ Class Declaration
â”œâ”€â”€ Fields
â””â”€â”€ Methods
```

## ConvenÃ§Ãµes de CÃ³digo

### Nomenclatura

```
NAMING CONVENTIONS
â”œâ”€â”€ Classes        (PascalCase)
â”œâ”€â”€ Methods        (camelCase)
â”œâ”€â”€ Variables      (camelCase)
â”œâ”€â”€ Constants      (UPPER_SNAKE_CASE)
â””â”€â”€ Packages       (lowercase)
```

## CompilaÃ§Ã£o e ExecuÃ§Ã£o

### Processo

```
COMPILATION FLOW
Source (.java) â†’ Bytecode (.class) â†’ JVM â†’ Execution
```

### Comandos

```BASH
# Compilar
javac HelloMatrix.java

# Executar
java HelloMatrix
```

## Estrutura de Arquivos

### OrganizaÃ§Ã£o

```
PROJECT STRUCTURE
src/
â”œâ”€â”€ com/
â”‚   â””â”€â”€ netrunner/
â”‚       â””â”€â”€ core/
â”‚           â””â”€â”€ HelloMatrix.java
â””â”€â”€ resources/
    â””â”€â”€ config.properties
```

## ComentÃ¡rios

### Tipos

```JAVA
// ComentÃ¡rio de linha Ãºnica

/*
   ComentÃ¡rio de
   mÃºltiplas linhas
*/

/**
 * DocumentaÃ§Ã£o JavaDoc
 * @author NetRunner
 * @version 1.0
 */
```

## Palavras-Chave

### Keywords Principais

```
KEYWORDS
â”œâ”€â”€ Controle     (if, else, for, while)
â”œâ”€â”€ Modificadores (public, private, static)
â”œâ”€â”€ Tipos        (class, interface, enum)
â””â”€â”€ Outros       (new, return, this, super)
```

## Ambiente de Desenvolvimento

### Ferramentas Essenciais

```
DEV ENVIRONMENT
â”œâ”€â”€ JDK
â”œâ”€â”€ IDE
â”œâ”€â”€ Build Tools
â””â”€â”€ Version Control
```

## Debug e Logs

### TÃ©cnicas BÃ¡sicas

```JAVA
// Print debugging
System.out.println("Debug: " + variable);

// Logging bÃ¡sico
Logger logger = Logger.getLogger(HelloMatrix.class.getName());
logger.info("Iniciando aplicaÃ§Ã£o...");
```

## Boas PrÃ¡ticas

### PrincÃ­pios

```
BEST PRACTICES
â”œâ”€â”€ Clean Code
â”œâ”€â”€ DRY (Don't Repeat Yourself)
â”œâ”€â”€ KISS (Keep It Simple)
â””â”€â”€ SOLID Principles
```

## PrÃ³ximos Passos

### TÃ³picos Seguintes

* Sintaxe detalhada

* VariÃ¡veis e tipos

* Operadores

* Strings e manipulaÃ§Ã£o

* Projetos prÃ¡ticos

[Sintaxe Java](syntax.html)

Tip:

"Java Ã© como o cÃ³digo base da Matrix - estruturado, robusto e onipresente."

## SubseÃ§Ãµes

* [Sintaxe](syntax.html)

* [VariÃ¡veis](variables.html)

* [Operadores](operators.html)

* [Strings](strings.html)

* [Projetos BÃ¡sicos](basic-projects.html)



# Sintaxe Java

```
SYNTAX STRUCTURE
â”œâ”€â”€ DeclaraÃ§Ãµes
â”œâ”€â”€ Blocos
â”œâ”€â”€ ExpressÃµes
â””â”€â”€ Statements
```

## Estrutura BÃ¡sica

### Classe

```JAVA
public class MatrixCode {
    // Membros da classe aqui
}
```

### MÃ©todo

```JAVA
public void hackSystem() {
    // CÃ³digo do mÃ©todo aqui
}
```

## DeclaraÃ§Ãµes

### VariÃ¡veis

```JAVA
// DeclaraÃ§Ã£o simples
tipo nome;

// DeclaraÃ§Ã£o com inicializaÃ§Ã£o
tipo nome = valor;

// Exemplos
int contador = 0;
String mensagem = "ConexÃ£o estabelecida";
boolean sistemaBloqueado = false;
```

### Constantes

```JAVA
// Constante
final double PI = 3.14159;

// Constante estÃ¡tica
public static final String VERSION = "1.0.0";
```

## Blocos de CÃ³digo

### Estrutura

```JAVA
{
    // Bloco de cÃ³digo
    // Pode conter mÃºltiplas linhas
}
```

### Escopo

```JAVA
public void exemplo() {
    int x = 1; // Escopo do mÃ©todo
    {
        int y = 2; // Escopo do bloco
        // y Ã© acessÃ­vel aqui
    }
    // y nÃ£o Ã© acessÃ­vel aqui
    // x Ã© acessÃ­vel em todo o mÃ©todo
}
```

## Statements

### Tipos

```JAVA
// Statement simples
System.out.println("Executando...");

// Statement composto
if (status == "online") {
    System.out.println("Conectado");
    iniciarOperacao();
}
```

## ExpressÃµes

### Componentes

```JAVA
// ExpressÃµes aritmÃ©ticas
resultado = 10 + 5 * 2;

// ExpressÃµes lÃ³gicas
boolean acessoPermitido = nivel >= 5 && !bloqueado;

// ExpressÃµes de string
String nomeCompleto = nome + " " + sobrenome;
```

## Identificadores

### Regras

```
IDENTIFIER RULES
â”œâ”€â”€ ComeÃ§ar com letra, $ ou _
â”œâ”€â”€ Pode conter nÃºmeros
â”œâ”€â”€ Case-sensitive
â””â”€â”€ Sem palavras reservadas
```

### Exemplos

```JAVA
// VÃ¡lidos
String usuarioNome;
int _contador;
double $taxa;

// InvÃ¡lidos
int 123numero;     // ComeÃ§a com nÃºmero
String class;      // Palavra reservada
```

## Palavras Reservadas

### Keywords

```
RESERVED WORDS
â”œâ”€â”€ Tipos      (boolean, byte, char...)
â”œâ”€â”€ Controle   (if, else, for, while...)
â”œâ”€â”€ Acesso     (public, private, protected...)
â””â”€â”€ Outros     (new, return, this, super...)
```

## Separadores

### Caracteres Especiais

```
SEPARATORS
â”œâ”€â”€ { }    Blocos
â”œâ”€â”€ [ ]    Arrays
â”œâ”€â”€ ( )    ParÃ¢metros
â”œâ”€â”€ ;      Fim de statement
â”œâ”€â”€ ,      Separador
â””â”€â”€ .      Acesso a membros
```

## ConvenÃ§Ãµes

### Estilo de CÃ³digo

```
CODE STYLE
â”œâ”€â”€ Classes        PascalCase
â”œâ”€â”€ MÃ©todos        camelCase
â”œâ”€â”€ VariÃ¡veis      camelCase
â”œâ”€â”€ Constantes     UPPER_SNAKE_CASE
â””â”€â”€ Pacotes        lowercase
```

## Exemplos PrÃ¡ticos

### Classe Completa

```JAVA
package com.netrunner.core;

public class SecuritySystem {
    private static final int MAX_ATTEMPTS = 3;
    private int attemptCount;
    
    public SecuritySystem() {
        this.attemptCount = 0;
    }
    
    public boolean authenticate(String code) {
        attemptCount++;
        if (attemptCount > MAX_ATTEMPTS) {
            lockSystem();
            return false;
        }
        return validateCode(code);
    }
    
    private void lockSystem() {
        System.out.println("Sistema bloqueado!");
    }
    
    private boolean validateCode(String code) {
        return code.equals("MATRIX_1999");
    }
}
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [VariÃ¡veis](variables.html)

* [Operadores](operators.html)

* [Estruturas de Controle](control-flow.html)

[VariÃ¡veis](variables.html)

Tip:

"A sintaxe Ã© o protocolo que mantÃ©m a Matrix funcionando. Domine-a, e vocÃª dominarÃ¡ o sistema."



# VariÃ¡veis em Java

```
VARIABLES
â”œâ”€â”€ Tipos Primitivos
â”œâ”€â”€ Tipos de ReferÃªncia
â”œâ”€â”€ Type Casting
â””â”€â”€ Palavra-chave var
```

## Conceitos BÃ¡sicos

### DefiniÃ§Ã£o

Uma variÃ¡vel Ã© um local na memÃ³ria que armazena dados. Em Java, toda variÃ¡vel tem:

* Nome (identificador)

* Tipo

* Valor

### DeclaraÃ§Ã£o

```JAVA
// Sintaxe bÃ¡sica
tipoDaVariavel nomeDaVariavel;

// Com inicializaÃ§Ã£o
tipoDaVariavel nomeDaVariavel = valor;
```

## Categorias Principais

### Tipos Primitivos

```
PRIMITIVE TYPES
â”œâ”€â”€ NÃºmeros Inteiros (byte, short, int, long)
â”œâ”€â”€ NÃºmeros Decimais (float, double)
â”œâ”€â”€ Caractere (char)
â””â”€â”€ Booleano (boolean)
```

### Tipos de ReferÃªncia

```
REFERENCE TYPES
â”œâ”€â”€ Classes
â”œâ”€â”€ Interfaces
â”œâ”€â”€ Arrays
â””â”€â”€ Enums
```

## Escopo

### NÃ­veis

```
SCOPE LEVELS
â”œâ”€â”€ Classe (campos)
â”œâ”€â”€ MÃ©todo (variÃ¡veis locais)
â””â”€â”€ Bloco (variÃ¡veis de bloco)
```

### Exemplo

```JAVA
public class DataMatrix {
    private int nivelAcesso; // Escopo de classe
    
    public void processarDados() {
        int contador = 0; // Escopo de mÃ©todo
        
        for (int i = 0; i < 10; i++) { // i tem escopo de bloco
            // cÃ³digo aqui
        }
    }
}
```

## Modificadores

### Constantes

```JAVA
// Constante de classe
public static final int MAX_CONEXOES = 100;

// Constante local
final double PI = 3.14159;
```

### VariÃ¡veis EstÃ¡ticas

```JAVA
public class Sistema {
    static int contadorGlobal; // Compartilhada por todas instÃ¢ncias
    int contadorLocal; // EspecÃ­fica para cada instÃ¢ncia
}
```

## Boas PrÃ¡ticas

### Nomenclatura

```JAVA
// Bom
int userId;
String firstName;
boolean isActive;

// Evitar
int a;
String x;
boolean flag;
```

### InicializaÃ§Ã£o

```JAVA
// Valores padrÃ£o
int numero; // 0
boolean status; // false
String texto; // null

// InicializaÃ§Ã£o explÃ­cita (recomendado)
int numero = 0;
boolean status = false;
String texto = "";
```

## SubseÃ§Ãµes

* [Tipos Primitivos](primitive-types.html)

* [Tipos de ReferÃªncia](reference-types.html)

* [Type Casting](type-casting.html)

* [Palavra-chave var](var-keyword.html)

[Tipos Primitivos](primitive-types.html)

Tip:

"VariÃ¡veis sÃ£o como terminais na Matrix - pontos de acesso para manipular a realidade digital."



# Tipos Primitivos

```
PRIMITIVE DATA TYPES
â”œâ”€â”€ Inteiros
â”‚   â”œâ”€â”€ byte  (8 bits)
â”‚   â”œâ”€â”€ short (16 bits)
â”‚   â”œâ”€â”€ int   (32 bits)
â”‚   â””â”€â”€ long  (64 bits)
â”œâ”€â”€ Decimais
â”‚   â”œâ”€â”€ float  (32 bits)
â”‚   â””â”€â”€ double (64 bits)
â”œâ”€â”€ Caractere
â”‚   â””â”€â”€ char   (16 bits)
â””â”€â”€ LÃ³gico
    â””â”€â”€ boolean (1 bit)
```

## Tipos NumÃ©ricos Inteiros

### byte

```JAVA
// Range: -128 atÃ© 127
byte nivelPoder = 100;
byte codigoStatus = -50;
```

### short

```JAVA
// Range: -32,768 atÃ© 32,767
short populacao = 30000;
short temperatura = -200;
```

### int

```JAVA
// Range: -2^31 atÃ© 2^31-1
int usuarios = 1000000;
int pontuacao = 2147483647;
```

### long

```JAVA
// Range: -2^63 atÃ© 2^63-1
long populacaoMundial = 7800000000L;
long distanciaEspacial = 9223372036854775807L;
```

## Tipos NumÃ©ricos Decimais

### float

```JAVA
// PrecisÃ£o: 6-7 dÃ­gitos decimais
float taxa = 19.99f;
float temperatura = -273.15f;
```

### double

```JAVA
// PrecisÃ£o: 15-16 dÃ­gitos decimais
double pi = 3.141592653589793;
double velocidadeLuz = 299792458.0;
```

## Tipo Caractere

### char

```JAVA
// Unicode 16-bit
char nivel = 'A';
char simbolo = '$';
char unicode = '\u0041'; // 'A'
```

## Tipo Booleano

### boolean

```JAVA
// Valores: true ou false
boolean sistemaAtivo = true;
boolean acessoPermitido = false;
```

## Valores PadrÃ£o

### InicializaÃ§Ã£o AutomÃ¡tica

```
DEFAULT VALUES
â”œâ”€â”€ byte, short, int, long â†’ 0
â”œâ”€â”€ float, double â†’ 0.0
â”œâ”€â”€ char â†’ '\u0000'
â””â”€â”€ boolean â†’ false
```

## Limites e Constantes

### Valores MÃ¡ximos e MÃ­nimos

```JAVA
// Constantes Ãºteis
byte maxByte = Byte.MAX_VALUE;    // 127
int minInt = Integer.MIN_VALUE;   // -2147483648
long maxLong = Long.MAX_VALUE;    // 9223372036854775807
```

## Literais NumÃ©ricos

### RepresentaÃ§Ãµes

```JAVA
// Decimal
int decimal = 1234;

// Hexadecimal
int hexadecimal = 0xFF; // 255

// BinÃ¡rio
int binario = 0b1010; // 10

// Octal
int octal = 0757; // 495
```

## Separador de DÃ­gitos

### Uso do Underscore

```JAVA
// Melhorando legibilidade
long cartaoCredito = 1234_5678_9012_3456L;
int milhao = 1_000_000;
```

## ConsideraÃ§Ãµes de Performance

### Escolha do Tipo

```
PERFORMANCE TIPS
â”œâ”€â”€ Use int para loops
â”œâ”€â”€ Prefira double a float
â”œâ”€â”€ byte/short para arrays grandes
â””â”€â”€ boolean para flags
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [Tipos de ReferÃªncia](reference-types.html)

* [Type Casting](type-casting.html)

* [Operadores](operators.html)

[Tipos de ReferÃªncia](reference-types.html)

Tip:

"Os tipos primitivos sÃ£o como os Ã¡tomos da Matrix - as unidades fundamentais que compÃµem toda a realidade digital."



# Tipos de ReferÃªncia

```
REFERENCE TYPES
â”œâ”€â”€ Classes
â”œâ”€â”€ Interfaces
â”œâ”€â”€ Arrays
â””â”€â”€ Enums
```

## Classes

### DefiniÃ§Ã£o e Uso

```JAVA
// DeclaraÃ§Ã£o
String mensagem = new String("ConexÃ£o estabelecida");
StringBuilder buffer = new StringBuilder();

// Null Ã© permitido
String dados = null;
```

### Classes Comuns

```JAVA
// Wrapper classes
Integer numero = 42;
Double valor = 3.14;
Boolean flag = true;

// UtilitÃ¡rios
Date data = new Date();
Random gerador = new Random();
```

## Arrays

### DeclaraÃ§Ã£o e InicializaÃ§Ã£o

```JAVA
// Arrays unidimensionais
int[] numeros = new int[5];
String[] comandos = {"LOGIN", "EXECUTE", "LOGOUT"};

// Arrays multidimensionais
int[][] matriz = new int[3][3];
```

### ManipulaÃ§Ã£o

```JAVA
// Acessando elementos
int primeiro = numeros[0];

// Modificando elementos
numeros[1] = 42;

// Comprimento
int tamanho = numeros.length;
```

## Enums

### DefiniÃ§Ã£o

```JAVA
public enum NivelAcesso {
    ADMIN,
    USUARIO,
    CONVIDADO
}
```

### Uso

```JAVA
NivelAcesso nivel = NivelAcesso.ADMIN;

switch (nivel) {
    case ADMIN:
        System.out.println("Acesso total");
        break;
    case USUARIO:
        System.out.println("Acesso parcial");
        break;
    case CONVIDADO:
        System.out.println("Acesso limitado");
        break;
}
```

## Interfaces

### ImplementaÃ§Ã£o

```JAVA
public interface Conexao {
    void conectar();
    void desconectar();
}

public class ConexaoSegura implements Conexao {
    @Override
    public void conectar() {
        // ImplementaÃ§Ã£o
    }

    @Override
    public void desconectar() {
        // ImplementaÃ§Ã£o
    }
}
```

## DiferenÃ§as dos Primitivos

### CaracterÃ­sticas

```
REFERENCE VS PRIMITIVE
â”œâ”€â”€ Armazenamento (Heap vs Stack)
â”œâ”€â”€ Null permitido
â”œâ”€â”€ MÃ©todos disponÃ­veis
â””â”€â”€ Overhead de memÃ³ria
```

### Exemplo

```JAVA
// Primitivo
int x = 10;

// ReferÃªncia
Integer y = 10;
y.toString(); // MÃ©todos disponÃ­veis
y = null; // Permitido
```

## Garbage Collection

### Ciclo de Vida

```
OBJECT LIFECYCLE
â”œâ”€â”€ CriaÃ§Ã£o (new)
â”œâ”€â”€ ReferenciaÃ§Ã£o
â”œâ”€â”€ DesreferenciaÃ§Ã£o
â””â”€â”€ Coleta de lixo
```

### Exemplo

```JAVA
String texto = new String("temp"); // Objeto criado
texto = null; // Objeto elegÃ­vel para GC
```

## Collections Framework

### Tipos Principais

```JAVA
// List
List<String> lista = new ArrayList<>();

// Set
Set<Integer> conjunto = new HashSet<>();

// Map
Map<String, Integer> mapa = new HashMap<>();
```

## Boas PrÃ¡ticas

### RecomendaÃ§Ãµes

```
BEST PRACTICES
â”œâ”€â”€ Inicialize referÃªncias
â”œâ”€â”€ Use interfaces apropriadas
â”œâ”€â”€ Verifique null
â””â”€â”€ Libere recursos
```

### Exemplo

```JAVA
// VerificaÃ§Ã£o de null
if (objeto != null) {
    objeto.metodo();
}

// Try-with-resources
try (Scanner scanner = new Scanner(System.in)) {
    // Uso do scanner
}
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [Type Casting](type-casting.html)

* [Palavra-chave var](var-keyword.html)

* [Collections](collections-overview.html)

[Type Casting](type-casting.html)

Tip:

"Os tipos de referÃªncia sÃ£o como os programas da Matrix - entidades complexas que manipulam a realidade digital."



# Type Casting em Java

```
TYPE CASTING
â”œâ”€â”€ ImplÃ­cito (Widening)
â”œâ”€â”€ ExplÃ­cito (Narrowing)
â”œâ”€â”€ ReferÃªncia
â””â”€â”€ Autoboxing/Unboxing
```

## Casting ImplÃ­cito

### Widening Casting

```
WIDENING PATH
byte â†’ short â†’ int â†’ long â†’ float â†’ double
        char â†—
```

### Exemplos

```JAVA
// ConversÃµes automÃ¡ticas
byte byteNum = 100;
int intNum = byteNum; // byte para int

int intValue = 10;
double doubleValue = intNum; // int para double
```

## Casting ExplÃ­cito

### Narrowing Casting

```
NARROWING PATH
double â†’ float â†’ long â†’ int â†’ short â†’ byte
                        â†˜ char
```

### Exemplos

```JAVA
// ConversÃµes manuais
double doubleNum = 9.78;
int intNum = (int) doubleNum; // double para int

int largeNum = 130;
byte byteNum = (byte) largeNum; // int para byte
```

## Casting de ReferÃªncia

### Upcasting

```JAVA
// Classe pai para filho
class Animal {}
class Gato extends Animal {}

Animal animal = new Gato(); // Upcast automÃ¡tico
```

### Downcasting

```JAVA
// Filho para pai (requer verificaÃ§Ã£o)
Animal animal = new Gato();
if (animal instanceof Gato) {
    Gato gato = (Gato) animal; // Downcast explÃ­cito
}
```

## Autoboxing e Unboxing

### Autoboxing

```JAVA
// Primitivo para Wrapper
int primitivo = 42;
Integer wrapper = primitivo; // Autoboxing
```

### Unboxing

```JAVA
// Wrapper para primitivo
Integer wrapper = 42;
int primitivo = wrapper; // Unboxing
```

## VerificaÃ§Ãµes de Tipo

### instanceof

```JAVA
Object obj = "teste";
if (obj instanceof String) {
    String str = (String) obj;
    System.out.println(str.length());
}
```

### Pattern Matching (Java 16+)

```JAVA
Object obj = "teste";
if (obj instanceof String str) {
    System.out.println(str.length());
}
```

## ConversÃµes Comuns

### String Conversions

```JAVA
// String para nÃºmero
String strNum = "42";
int num = Integer.parseInt(strNum);
double dNum = Double.parseDouble("3.14");

// NÃºmero para String
String str1 = String.valueOf(42);
String str2 = Integer.toString(42);
```

## Perda de Dados

### Exemplos

```JAVA
// Perda de precisÃ£o
int x = 128;
byte b = (byte) x; // Overflow: -128

double pi = 3.14159;
int iPi = (int) pi; // Truncado: 3
```

## Boas PrÃ¡ticas

### RecomendaÃ§Ãµes

```
CASTING GUIDELINES
â”œâ”€â”€ Prefira casting implÃ­cito
â”œâ”€â”€ Verifique antes de downcast
â”œâ”€â”€ Evite casting numÃ©rico arriscado
â””â”€â”€ Use mÃ©todos de conversÃ£o apropriados
```

### Exemplo Seguro

```JAVA
// VerificaÃ§Ã£o de range
long longValue = 42L;
if (longValue >= Integer.MIN_VALUE && 
    longValue <= Integer.MAX_VALUE) {
    int intValue = (int) longValue;
}
```

## Casos Especiais

### Char Casting

```JAVA
// Char para nÃºmero
char ch = 'A';
int ascii = ch; // 65

// NÃºmero para char
int num = 66;
char character = (char) num; // 'B'
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [Palavra-chave var](var-keyword.html)

* [Operadores](operators.html)

* [Tipos de Dados](variables.html)

[Palavra-chave var](var-keyword.html)

Tip:

"O type casting Ã© como hackear a Matrix - transformando dados de uma forma para outra."



# Palavra-chave var

```
VAR KEYWORD
â”œâ”€â”€ InferÃªncia de Tipo
â”œâ”€â”€ RestriÃ§Ãµes
â”œâ”€â”€ Usos Comuns
â””â”€â”€ Boas PrÃ¡ticas
```

## IntroduÃ§Ã£o

### O que Ã© var?

```JAVA
// InferÃªncia de tipo local
var mensagem = "ConexÃ£o estabelecida";
var contador = 0;
var lista = new ArrayList<String>();
```

## InferÃªncia de Tipo

### Como Funciona

```JAVA
// O compilador infere o tipo
var numero = 42; // int
var texto = "Matrix"; // String
var decimal = 3.14; // double
```

### Tipos Inferidos

```JAVA
// Tipos complexos
var mapa = new HashMap<String, Integer>();
var executor = Executors.newFixedThreadPool(10);
var padrao = Pattern.compile("\\w+");
```

## RestriÃ§Ãµes

### Onde NÃ£o Usar

```JAVA
// NÃ£o permitido:
var campo; // Sem inicializaÃ§Ã£o
var = "valor"; // Sem nome
var[] array = new int[10]; // Arrays
var mÃ©todo() { } // Retorno de mÃ©todo
```

### LimitaÃ§Ãµes

```
RESTRICTIONS
â”œâ”€â”€ VariÃ¡veis de classe
â”œâ”€â”€ ParÃ¢metros de mÃ©todo
â”œâ”€â”€ Retorno de mÃ©todo
â””â”€â”€ Catch blocks
```

## Usos Comuns

### Loops

```JAVA
// IteraÃ§Ã£o em collections
for (var item : lista) {
    System.out.println(item);
}

// Loop tradicional
for (var i = 0; i < 10; i++) {
    // cÃ³digo
}
```

### Lambda

```JAVA
// Com var em parÃ¢metros (Java 11+)
Consumer<String> consumer = (@NonNull var s) -> 
    System.out.println(s);
```

### Try-with-resources

```JAVA
try (var arquivo = new FileInputStream
```



# Operadores em Java

## VisÃ£o Geral

```
OPERATOR TYPES
â”œâ”€â”€ AritmÃ©ticos (+, -, *, /, %)
â”œâ”€â”€ LÃ³gicos (&&, ||, !)
â””â”€â”€ Bit a Bit (&, |, ^, ~, <<, >>, >>>)
```

## Categorias Principais

### ClassificaÃ§Ã£o

```
OPERATOR CATEGORIES
â”œâ”€â”€ UnÃ¡rios (++, --, !, ~)
â”œâ”€â”€ BinÃ¡rios (+, -, *, /, &, |)
â””â”€â”€ TernÃ¡rio (?:)
```

## PrecedÃªncia

### Ordem de ExecuÃ§Ã£o

```
PRECEDENCE ORDER
â”œâ”€â”€ UnÃ¡rios (++, --, !)
â”œâ”€â”€ Multiplicativos (*, /, %)
â”œâ”€â”€ Aditivos (+, -)
â”œâ”€â”€ Shift (<<, >>, >>>)
â”œâ”€â”€ Relacionais (<, >, <=, >=)
â”œâ”€â”€ Igualdade (==, !=)
â”œâ”€â”€ Bit a Bit (&, ^, |)
â”œâ”€â”€ LÃ³gicos (&&, ||)
â””â”€â”€ AtribuiÃ§Ã£o (=, +=, -=, etc)
```

## PrÃ³ximos Passos

### TÃ³picos Detalhados

* [Operadores AritmÃ©ticos](arithmetic.html)

* [Operadores LÃ³gicos](logical.html)

* [Operadores Bit a Bit](bitwise.html)

[Operadores AritmÃ©ticos](arithmetic.html)

Tip:

"Os operadores sÃ£o como os comandos bÃ¡sicos da Matrix - eles transformam e manipulam os dados em sua forma mais fundamental."



# Operadores AritmÃ©ticos

## Operadores BÃ¡sicos

### OperaÃ§Ãµes Fundamentais

```JAVA
// AdiÃ§Ã£o
int soma = 5 + 3;        // 8

// SubtraÃ§Ã£o
int diferenca = 10 - 4;  // 6

// MultiplicaÃ§Ã£o
int produto = 3 * 4;     // 12

// DivisÃ£o
int quociente = 15 / 3;  // 5

// MÃ³dulo (resto)
int resto = 17 % 5;      // 2
```

## Incremento e Decremento

### PrÃ© e PÃ³s

```JAVA
int x = 5;
int y = ++x;  // x = 6, y = 6 (prÃ©-incremento)
int z = x++;  // z = 6, x = 7 (pÃ³s-incremento)

int a = 5;
int b = --a;  // a = 4, b = 4 (prÃ©-decremento)
int c = a--;  // c = 4, a = 3 (pÃ³s-decremento)
```

## Operadores Compostos

### AtribuiÃ§Ã£o com OperaÃ§Ã£o

```JAVA
int valor = 10;
valor += 5;   // valor = valor + 5
valor -= 3;   // valor = valor - 3
valor *= 2;   // valor = valor * 2
valor /= 4;   // valor = valor / 4
valor %= 3;   // valor = valor % 3
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [Operadores LÃ³gicos](logical.html)

* [Operadores Bit a Bit](bitwise.html)

* [ExpressÃµes](null)

[Operadores LÃ³gicos](logical.html)



# Operadores LÃ³gicos

## Operadores BÃ¡sicos

### Booleanos

```JAVA
// AND lÃ³gico (&&)
boolean and = true && false;  // false

// OR lÃ³gico (||)
boolean or = true || false;   // true

// NOT lÃ³gico (!)
boolean not = !true;         // false
```

## Curto-Circuito

### AvaliaÃ§Ã£o Otimizada

```JAVA
// AND com curto-circuito
if (obj != null && obj.getValue() > 0) {
    // Segundo termo sÃ³ Ã© avaliado se obj != null
}

// OR com curto-circuito
if (cache.containsKey(key) || loadFromDatabase()) {
    // loadFromDatabase() sÃ³ Ã© chamado se necessÃ¡rio
}
```

## Operadores Bit a Bit Booleanos

### OperaÃ§Ãµes sem Curto-Circuito

```JAVA
// AND bit a bit (&)
boolean bitwiseAnd = true & false;

// OR bit a bit (|)
boolean bitwiseOr = true | false;

// XOR bit a bit (^)
boolean xor = true ^ false;
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [Operadores Bit a Bit](bitwise.html)

* [Estruturas Condicionais](conditionals.html)

* [ExpressÃµes Booleanas](null)

[Operadores Bit a Bit](bitwise.html)



# Operadores Bit a Bit

## Operadores BÃ¡sicos

### ManipulaÃ§Ã£o de Bits

```JAVA
// AND bit a bit (&)
int and = 12 & 5;   // 1100 & 0101 = 0100 (4)

// OR bit a bit (|)
int or = 12 | 5;    // 1100 | 0101 = 1101 (13)

// XOR bit a bit (^)
int xor = 12 ^ 5;   // 1100 ^ 0101 = 1001 (9)

// NOT bit a bit (~)
int not = ~12;      // ~1100 = ...11110011
```

## Operadores de Deslocamento

### Shift de Bits

```JAVA
// Shift left (<<)
int left = 8 << 2;    // 1000 -> 100000 (32)

// Shift right (>>)
int right = 8 >> 2;   // 1000 -> 0010 (2)

// Shift right sem sinal (>>>)
int unsignedRight = -8 >>> 2;  // Preenche com 0
```

## AplicaÃ§Ãµes PrÃ¡ticas

### Uso Comum

```JAVA
// Flags de bit
int FLAG_READ = 1;     // 0001
int FLAG_WRITE = 2;    // 0010
int FLAG_EXECUTE = 4;  // 0100

// Combinando flags
int permissions = FLAG_READ | FLAG_WRITE;  // 0011

// Verificando flags
boolean canRead = (permissions & FLAG_READ) != 0;
```

### OtimizaÃ§Ãµes

```JAVA
// MultiplicaÃ§Ã£o por 2
int multiply = num << 1;  // Equivalente a num * 2

// DivisÃ£o por 2
int divide = num >> 1;    // Equivalente a num / 2

// AlternÃ¢ncia de bit
int toggleBit = num ^ (1 << position);
```

## MÃ¡scaras de Bits

### TÃ©cnicas de Mascaramento

```JAVA
// MÃ¡scara para Ãºltimos 8 bits
int mask = 0xFF;

// Aplicando mÃ¡scara
int lastByte = number & mask;

// Limpando bits
int clearBits = number & ~mask;
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [Tipos Primitivos](primitive-types.html)

* [Operadores LÃ³gicos](logical.html)

* [ManipulaÃ§Ã£o de Bits](null)

[Tipos Primitivos](primitive-types.html)

Tip:

"Os operadores bit a bit sÃ£o como os comandos de baixo nÃ­vel da Matrix - manipulando a realidade digital bit por bit."



# Strings em Java

## VisÃ£o Geral

```
STRING CONCEPTS
â”œâ”€â”€ Imutabilidade
â”œâ”€â”€ Pool de Strings
â”œâ”€â”€ ConcatenaÃ§Ã£o
â””â”€â”€ ComparaÃ§Ã£o
```

## CriaÃ§Ã£o de Strings

### Formas de InicializaÃ§Ã£o

```JAVA
// Literal
String comando = "EXECUTE";

// Construtor
String status = new String("ONLINE");

// Pool vs Heap
String s1 = "MATRIX";         // Pool de Strings
String s2 = new String("MATRIX"); // Heap
```

## OperaÃ§Ãµes BÃ¡sicas

### ManipulaÃ§Ã£o

```JAVA
String codigo = "NET_RUNNER";
int tamanho = codigo.length();     // 10
char primeiro = codigo.charAt(0);   // 'N'
String sub = codigo.substring(0,3); // "NET"
```

## PrÃ³ximos Passos

### TÃ³picos Detalhados

* [MÃ©todos de String](string-methods.html)

* [StringBuilder](string-builder.html)

* [FormataÃ§Ã£o de Strings](string-formatting.html)

[MÃ©todos de String](string-methods.html)

Tip:

"Strings sÃ£o como os dados criptografados da Matrix - precisam ser manipulados com precisÃ£o e eficiÃªncia."



# MÃ©todos de String

## MÃ©todos de Busca

### LocalizaÃ§Ã£o

```JAVA
String texto = "CYBERPUNK_2077";

// Busca
int posicao = texto.indexOf("PUNK");    // 5
int ultimo = texto.lastIndexOf("7");     // 12
boolean contem = texto.contains("CYBER"); // true
```

## MÃ©todos de TransformaÃ§Ã£o

### ModificaÃ§Ã£o

```JAVA
String codigo = "NetRunner";

// TransformaÃ§Ãµes
String maiusculo = codigo.toUpperCase(); // "NETRUNNER"
String minusculo = codigo.toLowerCase(); // "netrunner"
String semEspacos = codigo.trim();      // Remove espaÃ§os
String[] partes = codigo.split("R");    // ["Net", "unner"]
```

## MÃ©todos de ComparaÃ§Ã£o

### VerificaÃ§Ã£o

```JAVA
String s1 = "MATRIX";
String s2 = "matrix";

// ComparaÃ§Ãµes
boolean igual = s1.equals(s2);           // false
boolean ignoraCase = s1.equalsIgnoreCase(s2); // true
int comparacao = s1.compareTo(s2);       // ComparaÃ§Ã£o lexicogrÃ¡fica
```

## MÃ©todos de SubstituiÃ§Ã£o

### AlteraÃ§Ã£o

```JAVA
String log = "Error:404:NotFound";

// SubstituiÃ§Ãµes
String novo = log.replace(":", "-");     // "Error-404-NotFound"
String primeiro = log.replaceFirst(":", "-"); // "Error-404:NotFound"
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [StringBuilder](string-builder.html)

* [FormataÃ§Ã£o de Strings](string-formatting.html)

* [ExpressÃµes Regulares](null)

[StringBuilder](string-builder.html)



# StringBuilder

## Conceitos BÃ¡sicos

### CriaÃ§Ã£o

```JAVA
// InicializaÃ§Ã£o
StringBuilder buffer = new StringBuilder();
StringBuilder preset = new StringBuilder("INIT:");
StringBuilder sized = new StringBuilder(32);
```

## OperaÃ§Ãµes Principais

### ManipulaÃ§Ã£o

```JAVA
StringBuilder log = new StringBuilder();

// AdiÃ§Ã£o
log.append("STATUS: ")    // ConcatenaÃ§Ã£o
   .append("ONLINE")      // Encadeamento
   .append(" - ")
   .append(2077);

// InserÃ§Ã£o
log.insert(0, "[LOG] ");  // InÃ­cio
log.insert(6, "DEBUG ");  // Meio

// RemoÃ§Ã£o
log.delete(0, 5);         // Range
log.deleteCharAt(10);     // Caractere Ãºnico

// ReversÃ£o
log.reverse();            // Inverte a string
```

## Performance

### ComparaÃ§Ã£o com String

```JAVA
// MÃ¡ prÃ¡tica (String)
String result = "";
for (int i = 0; i < 1000; i++) {
    result += "Data";  // Cria nova String cada vez
}

// Boa prÃ¡tica (StringBuilder)
StringBuilder builder = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    builder.append("Data");  // Modifica o mesmo objeto
}
String result = builder.toString();
```

## MÃ©todos Ãšteis

### Funcionalidades Adicionais

```JAVA
StringBuilder cmd = new StringBuilder("EXECUTE");

// Capacidade
int cap = cmd.capacity();     // Capacidade atual
cmd.ensureCapacity(100);      // Garante capacidade mÃ­nima

// ModificaÃ§Ã£o
cmd.setCharAt(0, 'e');       // Modifica caractere
cmd.setLength(4);            // Trunca ou expande
cmd.replace(0, 2, "RE");     // Substitui range
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [FormataÃ§Ã£o de Strings](string-formatting.html)

* [StringBuffer](null)

* [Performance](null)

[FormataÃ§Ã£o de Strings](string-formatting.html)



# FormataÃ§Ã£o de Strings

## String.format()

### Sintaxe BÃ¡sica

```JAVA
// FormataÃ§Ã£o bÃ¡sica
String msg = String.format("UsuÃ¡rio: %s, ID: %d", "Neo", 1337);

// NÃºmeros
String num = String.format("%.2f", 3.14159);  // "3.14"
String hex = String.format("%x", 255);        // "ff"
```

## System.out.printf()

### SaÃ­da Formatada

```JAVA
// ImpressÃ£o formatada
System.out.printf("Status: %s%n", "ONLINE");

// MÃºltiplos argumentos
System.out.printf("X: %d, Y: %d%n", 10, 20);
```

## Especificadores de Formato

### Tipos Comuns

```JAVA
// Strings e caracteres
%s  // String
%c  // Caractere
%n  // Nova linha

// NÃºmeros
%d  // Inteiro decimal
%f  // Ponto flutuante
%e  // NotaÃ§Ã£o cientÃ­fica
%x  // Hexadecimal
```

## Flags de FormataÃ§Ã£o

### Modificadores

```JAVA
// Alinhamento e preenchimento
String align = String.format("|%-10s|", "LEFT");   // Alinha Ã  esquerda
String pad = String.format("%05d", 42);            // "00042"

// NÃºmeros
String prec = String.format("%.3f", 3.14159);      // "3.142"
String group = String.format("%,d", 1000000);      // "1,000,000"
```

## MessageFormat

### FormataÃ§Ã£o Complexa

```JAVA
import java.text.MessageFormat;

// PadrÃ£o de mensagem
String pattern = "User {0} logged in at {1}";
String msg = MessageFormat.format(pattern, "Trinity", "12:00");

// NÃºmeros e datas
MessageFormat mf = new MessageFormat("Balance: {0,number,currency}");
String balance = mf.format(new Object[]{1234.56});
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [InternacionalizaÃ§Ã£o](null)

* [FormataÃ§Ã£o de Datas](null)

* [FormataÃ§Ã£o de NÃºmeros](null)

[InternacionalizaÃ§Ã£o](null)

Tip:

"A formataÃ§Ã£o de strings Ã© como a interface da Matrix - a forma como apresentamos os dados ao mundo real."



# Projetos BÃ¡sicos

Os projetos nesta seÃ§Ã£o aplicam os conceitos fundamentais de Java em cenÃ¡rios prÃ¡ticos inspirados no universo cyberpunk.

## VisÃ£o Geral dos Projetos

```MERMAID
graph LR
    A[Matrix Code Generator] --> D[VisualizaÃ§Ã£o de Dados]
    B[Cyber Deck Simulator] --> E[Interface de Comando]
    C[Data Encryptor] --> F[SeguranÃ§a de Dados]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#33ccff
    style E fill:#1a1a1a,stroke:#33ccff
    style F fill:#1a1a1a,stroke:#33ccff
```

## Objetivos de Aprendizado

### Matrix Code Generator

* ManipulaÃ§Ã£o de strings e caracteres

* Loops e controle de fluxo

* TemporizaÃ§Ã£o bÃ¡sica

* SaÃ­da formatada no console

* Arrays unidimensionais e bidimensionais

### Cyber Deck Simulator

* Entrada e saÃ­da do usuÃ¡rio

* Estruturas condicionais

* Comandos e argumentos

* FormataÃ§Ã£o de terminal

* Processamento de strings

### Data Encryptor

* OperaÃ§Ãµes com bytes

* Algoritmos bÃ¡sicos

* ManipulaÃ§Ã£o de arquivos

* GeraÃ§Ã£o de chaves

* ConversÃ£o de tipos

## Habilidades Desenvolvidas

| Projeto |Conceitos Principais |Dificuldade |
----------------------------------------------
| Matrix Code Generator |Strings, Arrays, Loops |â­â­ |
| Cyber Deck Simulator |I/O, Condicionais |â­â­ |
| Data Encryptor |Bytes, Arquivos |â­â­â­ |

## PrÃ©-requisitos

```JAVA
// Conhecimentos necessÃ¡rios
public class Prerequisites {
    // Sintaxe bÃ¡sica
    String[] fundamentals = {
        "VariÃ¡veis",
        "Tipos de dados",
        "Operadores",
        "Estruturas de controle"
    };
    
    // Ambiente de desenvolvimento
    boolean ready = hasJDK() && hasIDE();
}
```

## Estrutura dos Projetos

```
PROJETO
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/
â”‚   â”‚   â””â”€â”€ java/
â”‚   â”‚       â””â”€â”€ com/
â”‚   â”‚           â””â”€â”€ netrunner/
â”‚   â”‚               â””â”€â”€ project/
â”‚   â”‚                   â”œâ”€â”€ Main.java
â”‚   â”‚                   â””â”€â”€ core/
â”‚   â””â”€â”€ test/
â”‚       â””â”€â”€ java/
â””â”€â”€ README.md
```

## Dicas de ImplementaÃ§Ã£o

* Comece com uma versÃ£o bÃ¡sica funcional

* Adicione recursos gradualmente

* Teste cada nova funcionalidade

* Mantenha o cÃ³digo organizado

* Documente as partes importantes

## Desafios Extras

### Matrix Code Generator

* Adicionar cores diferentes

* Implementar velocidades variÃ¡veis

* Criar padrÃµes personalizados

### Cyber Deck Simulator

* Adicionar novos comandos

* Implementar histÃ³rico

* Criar aliases para comandos

### Data Encryptor

* Suportar mÃºltiplos algoritmos

* Adicionar compressÃ£o

* Implementar assinaturas digitais

## Recursos Adicionais

### ReferÃªncias

* [Java Documentation](https://docs.oracle.com/en/java/)

* [Console Colors](https://stackoverflow.com/questions/5762491/how-to-print-color-in-console-using-system-out-println)

* [File Handling in Java](https://www.w3schools.com/java/java_files.asp)

### Ferramentas Ãšteis

* Terminal: [JLine](https://github.com/jline/jline3)

* Criptografia: [Bouncy Castle](https://www.bouncycastle.org/)

* Logging: [SLF4J](http://www.slf4j.org/)

## PrÃ³ximos Passos

ApÃ³s completar estes projetos bÃ¡sicos, vocÃª estarÃ¡ preparado para:

* Explorar projetos mais complexos

* Aprender sobre design patterns

* Trabalhar com bibliotecas externas

* Desenvolver aplicaÃ§Ãµes mais robustas

```

## ConclusÃ£o

Estes projetos fornecem uma base sÃ³lida em programaÃ§Ã£o Java atravÃ©s de aplicaÃ§Ãµes prÃ¡ticas e envolventes. Cada projeto pode ser expandido e personalizado de acordo com seus interesses e necessidades de aprendizado.
```



# Calculadora BÃ¡sica

## Conceitos Aplicados

* VariÃ¡veis primitivas (`int`, `double`)

* Operadores aritmÃ©ticos

* Type casting

* Palavra-chave `var`

## ImplementaÃ§Ã£o Base

```JAVA
public class Calculator {
    // Usando tipos primitivos para armazenar resultados
    private double result;
    
    // DemonstraÃ§Ã£o de operadores aritmÃ©ticos bÃ¡sicos
    public double add(double a, double b) {
        result = a + b;
        return result;
    }
    
    public double subtract(double a, double b) {
        result = a - b;
        return result;
    }
    
    // Exemplo de casting implÃ­cito
    public double multiply(int a, double b) {
        result = a * b; // int Ã© automaticamente convertido para double
        return result;
    }
    
    // DemonstraÃ§Ã£o de var com inferÃªncia de tipo
    public double divide(double a, double b) {
        var quotient = a / b; // var infere double
        result = quotient;
        return result;
    }
}
```

## ExercÃ­cios Propostos

1. Implementar operaÃ§Ãµes com diferentes tipos numÃ©ricos

2. Praticar conversÃµes explÃ­citas entre tipos

3. Explorar precedÃªncia de operadores

4. Usar var em diferentes contextos

## Desafios

1. Adicionar operaÃ§Ãµes com nÃºmeros inteiros e decimais

2. Implementar conversÃµes entre tipos numÃ©ricos

3. Criar operaÃ§Ãµes com diferentes precedÃªncias



# Conversor de Temperatura

## Conceitos Aplicados

* Tipos primitivos (`double`)

* Operadores aritmÃ©ticos

* Type casting

* Operadores lÃ³gicos

## ImplementaÃ§Ã£o Base

```JAVA
public class TemperatureConverter {
    // DemonstraÃ§Ã£o de constantes com tipos primitivos
    private static final double ABSOLUTE_ZERO_C = -273.15;
    
    // Uso de operadores aritmÃ©ticos e type casting
    public double celsiusToFahrenheit(double celsius) {
        return (celsius * 9/5) + 32;
    }
    
    public double fahrenheitToCelsius(double fahrenheit) {
        return (fahrenheit - 32) * 5/9;
    }
    
    // DemonstraÃ§Ã£o de operadores lÃ³gicos
    public boolean isValidTemperature(double celsius) {
        return celsius >= ABSOLUTE_ZERO_C;
    }
}
```

## ExercÃ­cios Propostos

1. Trabalhar com diferentes escalas de precisÃ£o

2. Implementar validaÃ§Ãµes usando operadores lÃ³gicos

3. Praticar conversÃµes entre tipos numÃ©ricos

4. Explorar formataÃ§Ã£o de nÃºmeros decimais

## Desafios

1. Adicionar validaÃ§Ãµes de temperatura

2. Implementar arredondamento de resultados

3. Criar verificaÃ§Ãµes de limites fÃ­sicos



# Manipulador de Strings

## Conceitos Aplicados

* String como tipo de referÃªncia

* MÃ©todos de String

* StringBuilder

* String formatting

## ImplementaÃ§Ã£o Base

```JAVA
public class StringManipulator {
    // DemonstraÃ§Ã£o de String como tipo de referÃªncia
    private String text;
    
    public StringManipulator(String text) {
        this.text = text;
    }
    
    // Uso de mÃ©todos de String
    public String toUpperCase() {
        return text.toUpperCase();
    }
    
    // DemonstraÃ§Ã£o de StringBuilder
    public String reverse() {
        StringBuilder builder = new StringBuilder(text);
        return builder.reverse().toString();
    }
    
    // Exemplo de String formatting
    public String format() {
        return String.format("Texto: %s, Tamanho: %d", 
                           text, text.length());
    }
}
```

## ExercÃ­cios Propostos

1. Explorar mÃ©todos da classe String

2. Praticar concatenaÃ§Ã£o com StringBuilder

3. Implementar diferentes formatos de string

4. Trabalhar com substrings e caracteres

## Desafios

1. Criar diferentes formatos de saÃ­da

2. Implementar manipulaÃ§Ãµes de texto

3. Otimizar operaÃ§Ãµes com StringBuilder



# Controle de Fluxo

![Control Flow Banner](control-flow-banner.png)

```
>> Inicializando mÃ³dulo de controle...
>> Carregando padrÃµes de decisÃ£o...
>> Estabelecendo loops de execuÃ§Ã£o...
```

## VisÃ£o Geral

O controle de fluxo Ã© fundamental para direcionar a execuÃ§Ã£o do seu cÃ³digo. Como um netrunner navegando pela matrix, vocÃª precisa tomar decisÃµes e repetir aÃ§Ãµes de forma eficiente.

```MERMAID
graph TD
    A[Entrada] --> B{DecisÃ£o}
    B -->|CondiÃ§Ã£o 1| C[ExecuÃ§Ã£o A]
    B -->|CondiÃ§Ã£o 2| D[ExecuÃ§Ã£o B]
    C --> E[PrÃ³ximo Passo]
    D --> E
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#00ff00
```

## Elementos Principais

### 1. Estruturas Condicionais

* if/else

* switch/case

* operador ternÃ¡rio

### 2. Estruturas de RepetiÃ§Ã£o

* while

* do-while

* for

* for-each

### 3. Controle de Fluxo

* break

* continue

* return

## Exemplo PrÃ¡tico

```JAVA
public class AccessControl {
    private static final int MAX_ATTEMPTS = 3;
    
    public void validateAccess(String code) {
        int attempts = 0;
        
        while (attempts < MAX_ATTEMPTS) {
            if (code.equals("MATRIX")) {
                System.out.println("Acesso concedido");
                return;
            } else {
                attempts++;
                if (attempts == MAX_ATTEMPTS) {
                    System.out.println("Sistema bloqueado");
                    break;
                }
                System.out.println("Tentativa " + attempts);
                continue;
            }
        }
    }
}
```

## PadrÃµes de Uso

### Estrutura Condicional

```JAVA
if (condicao) {
    // cÃ³digo para condiÃ§Ã£o verdadeira
} else if (outraCondicao) {
    // cÃ³digo para outra condiÃ§Ã£o
} else {
    // cÃ³digo para nenhuma condiÃ§Ã£o verdadeira
}
```

### Loop com For

```JAVA
for (int i = 0; i < 10; i++) {
    // cÃ³digo a ser repetido
    if (condicaoParada) {
        break;
    }
}
```

### Switch Expression (Java 14+)

```JAVA
String status = switch (code) {
    case 200 -> "Success";
    case 404 -> "Not Found";
    case 500 -> "Server Error";
    default -> "Unknown";
};
```

## Boas PrÃ¡ticas

1. Clareza nas CondiÃ§Ãµes

* Use nomes descritivos

* Evite negaÃ§Ãµes complexas

* Mantenha condiÃ§Ãµes simples

2. Estrutura dos Loops

* Defina condiÃ§Ãµes de parada claras

* Evite loops infinitos

* Use o tipo correto de loop

3. OtimizaÃ§Ã£o

* Minimize aninhamentos

* Use break/continue com critÃ©rio

* Prefira switch para mÃºltiplas condiÃ§Ãµes

## PrÃ³ximos Passos

Explore cada conceito em detalhes:

* [Condicionais](conditionals.html)

* [Loops](loops.html)

* [Switch Expressions](switch-expressions.html)

* [Pattern Matching](pattern-matching.html)

[Condicionais](conditionals.html)

Tip:

"O controle de fluxo Ã© como navegar pela Matrix - vocÃª precisa saber quando dobrar as regras e quando quebrÃ¡-las."



# Estruturas Condicionais

```
>> Inicializando sistema de decisÃ£o...
>> Carregando Ã¡rvores lÃ³gicas...
>> Estabelecendo caminhos de execuÃ§Ã£o...
```

## VisÃ£o Geral

As estruturas condicionais sÃ£o como os checkpoints da Matrix - elas determinam quais caminhos seu cÃ³digo pode seguir.

## Estruturas BÃ¡sicas

### 1. if-else

```JAVA
if (condicao) {
    // cÃ³digo executado se verdadeiro
} else {
    // cÃ³digo executado se falso
}
```

#### Exemplo PrÃ¡tico

```JAVA
int securityLevel = 5;
if (securityLevel >= 4) {
    System.out.println("Acesso concedido ao mainframe");
} else {
    System.out.println("Acesso negado");
}
```

### 2. else-if

```JAVA
if (condicao1) {
    // cÃ³digo para condiÃ§Ã£o 1
} else if (condicao2) {
    // cÃ³digo para condiÃ§Ã£o 2
} else {
    // cÃ³digo padrÃ£o
}
```

#### Exemplo PrÃ¡tico

```JAVA
int threatLevel = 3;
if (threatLevel == 1) {
    System.out.println("Alerta Verde");
} else if (threatLevel == 2) {
    System.out.println("Alerta Amarelo");
} else {
    System.out.println("Alerta Vermelho");
}
```

### 3. Operador TernÃ¡rio

```JAVA
resultado = (condicao) ? valorSeVerdadeiro : valorSeFalso;
```

#### Exemplo PrÃ¡tico

```JAVA
int energia = 50;
String status = (energia > 20) ? "Online" : "Offline";
```

## Operadores de ComparaÃ§Ã£o

| Operador |DescriÃ§Ã£o |
-----------------------
| `==` |Igual a |
| `!=` |Diferente de |
| `>` |Maior que |
| `<` |Menor que |
| `>=` |Maior ou igual |
| `<=` |Menor ou igual |

## Operadores LÃ³gicos

| Operador |DescriÃ§Ã£o |
-----------------------
| `&&` |AND lÃ³gico |
| `\\|\\|` |OR lÃ³gico |
| `!` |NOT lÃ³gico |

## Boas PrÃ¡ticas

1. Clareza nas CondiÃ§Ãµes

```JAVA
// Ruim
if (x == 1 && y == 2 || z == 3 && !w) { }

// Bom
boolean isValidX = (x == 1);
boolean isValidY = (y == 2);
boolean isValidZ = (z == 3 && !w);
if (isValidX && isValidY || isValidZ) { }
```

2. Evite Aninhamento Excessivo

```JAVA
// Evite
if (a) {
    if (b) {
        if (c) {
            // cÃ³digo
        }
    }
}

// Prefira
if (!a || !b || !c) return;
// cÃ³digo
```

3. Use Chaves Sempre

```JAVA
// Evite
if (condicao) comando;

// Prefira
if (condicao) {
    comando;
}
```

## PadrÃµes AvanÃ§ados

### Switch Expression (Java 14+)

```JAVA
String mensagem = switch (nivelAcesso) {
    case 1 -> "Acesso BÃ¡sico";
    case 2 -> "Acesso IntermediÃ¡rio";
    case 3 -> "Acesso Total";
    default -> "Sem Acesso";
};
```

### Pattern Matching (Preview)

```JAVA
if (obj instanceof String s && s.length() > 5) {
    System.out.println("String longa: " + s);
}
```

## ExercÃ­cios PrÃ¡ticos

1. Sistema de AutenticaÃ§Ã£o

```JAVA
public boolean verificarAcesso(String usuario, int nivel) {
    if (usuario == null || usuario.isEmpty()) {
        return false;
    }
    return nivel >= 3 && usuario.startsWith("ADMIN_");
}
```

2. Validador de Status

```JAVA
public String verificarStatus(int memoria, int cpu) {
    if (memoria < 10 || cpu > 90) {
        return "CRÃTICO";
    } else if (memoria < 30 || cpu > 70) {
        return "ALERTA";
    }
    return "NORMAL";
}
```

## PrÃ³ximos Passos

* Explore estruturas de repetiÃ§Ã£o em [Loops](loops.html)

* Aprenda sobre expressÃµes switch em [Switch Expressions](switch-expressions.html)

* Descubra pattern matching em [Pattern Matching](pattern-matching.html)

[Loops](loops.html)



# Estruturas de RepetiÃ§Ã£o

```
>> Iniciando ciclos de execuÃ§Ã£o...
>> Configurando iteradores...
>> Estabelecendo pontos de controle...
```

## VisÃ£o Geral

Loops sÃ£o como rotinas de hack - eles permitem executar operaÃ§Ãµes repetitivas de forma eficiente e controlada.

## Tipos de Loops

### 1. for Loop

```JAVA
for (inicializaÃ§Ã£o; condiÃ§Ã£o; incremento) {
    // cÃ³digo a ser repetido
}
```

#### Exemplo PrÃ¡tico

```JAVA
for (int i = 0; i < 5; i++) {
    System.out.println("Tentativa de acesso: " + i);
}
```

### 2. while Loop

```JAVA
while (condiÃ§Ã£o) {
    // cÃ³digo a ser repetido
}
```

#### Exemplo PrÃ¡tico

```JAVA
int tentativas = 0;
while (tentativas < 3) {
    System.out.println("Tentando conexÃ£o...");
    tentativas++;
}
```

### 3. do-while Loop

```JAVA
do {
    // cÃ³digo a ser repetido
} while (condiÃ§Ã£o);
```

#### Exemplo PrÃ¡tico

```JAVA
int senha;
do {
    senha = gerarSenha();
} while (!validarSenha(senha));
```

### 4. for-each Loop

```JAVA
for (tipo elemento : coleÃ§Ã£o) {
    // cÃ³digo a ser repetido
}
```

#### Exemplo PrÃ¡tico

```JAVA
String[] servidores = {"Alpha", "Beta", "Gamma"};
for (String servidor : servidores) {
    System.out.println("Verificando servidor: " + servidor);
}
```

## Controle de Loop

### break

Interrompe a execuÃ§Ã£o do loop completamente.

```JAVA
for (int i = 0; i < 100; i++) {
    if (detectarIntruso()) {
        break; // Sai do loop imediatamente
    }
}
```

### continue

Pula para a prÃ³xima iteraÃ§Ã£o do loop.

```JAVA
for (int porta = 0; porta < 1024; porta++) {
    if (!portaVulneravel(porta)) {
        continue; // Verifica prÃ³xima porta
    }
    atacarPorta(porta);
}
```

## PadrÃµes de Uso

### 1. Loop Infinito Controlado

```JAVA
while (true) {
    if (condicaoParada()) {
        break;
    }
    // processamento
}
```

### 2. Loop com MÃºltiplas VariÃ¡veis

```JAVA
for (int i = 0, j = 10; i < j; i++, j--) {
    System.out.printf("i: %d, j: %d%n", i, j);
}
```

### 3. Loop Aninhado

```JAVA
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        System.out.printf("[%d,%d] ", i, j);
    }
    System.out.println();
}
```

## Boas PrÃ¡ticas

1. Use o Loop Adequado

```JAVA
// Para nÃºmero conhecido de iteraÃ§Ãµes
for (int i = 0; i < tamanho; i++) { }

// Para condiÃ§Ã£o desconhecida
while (temDados()) { }

// Para arrays/collections
for (Elemento e : colecao) { }
```

2. Evite Loop Infinito Acidental

```JAVA
// Ruim - possÃ­vel loop infinito
while (x > 0) {
    // esqueceu de modificar x
}

// Bom
while (x > 0) {
    x--;
    // processamento
}
```

3. Mantenha Loops Simples

```JAVA
// Evite
for (int i = 0; i < 100; i++) {
    // muito cÃ³digo aqui
}

// Prefira
for (int i = 0; i < 100; i++) {
    processarItem(i);
}
```

## Exemplos AvanÃ§ados

### 1. Loop com Timer

```JAVA
long inicio = System.currentTimeMillis();
long limite = 5000; // 5 segundos

while (System.currentTimeMillis() - inicio < limite) {
    // processamento limitado por tempo
}
```

### 2. Loop com Retry

```JAVA
int maxTentativas = 3;
int tentativa = 0;

while (tentativa < maxTentativas) {
    try {
        conectar();
        break;
    } catch (Exception e) {
        tentativa++;
        if (tentativa == maxTentativas) {
            throw new RuntimeException("Falha na conexÃ£o");
        }
    }
}
```

### 3. Loop com Buffer

```JAVA
StringBuilder buffer = new StringBuilder();
for (int i = 0; i < dados.length; i++) {
    buffer.append(dados[i]);
    if (buffer.length() >= 1000) {
        processarBuffer(buffer.toString());
        buffer.setLength(0);
    }
}
```

## ExercÃ­cios PrÃ¡ticos

1. Scanner de Portas

```JAVA
public void scanearPortas(int inicio, int fim) {
    for (int porta = inicio; porta <= fim; porta++) {
        if (portaAberta(porta)) {
            System.out.println("Porta " + porta + " estÃ¡ aberta");
        }
    }
}
```

2. Processador de Dados

```JAVA
public void processarDados(List<String> dados) {
    int processados = 0;
    while (!dados.isEmpty()) {
        String dado = dados.remove(0);
        processar(dado);
        processados++;
        if (processados % 100 == 0) {
            System.out.println("Progresso: " + processados);
        }
    }
}
```

## PrÃ³ximos Passos

* Aprenda sobre condicionais em [Conditionals](conditionals.html)

* Explore expressÃµes switch em [Switch Expressions](switch-expressions.html)

* Descubra pattern matching em [Pattern Matching](pattern-matching.html)

[Pattern Matching](pattern-matching.html)



# Switch Expressions

```
>> Inicializando sistema de expressÃµes switch...
>> Carregando padrÃµes de correspondÃªncia...
>> Estabelecendo rotas de decisÃ£o...
```

## IntroduÃ§Ã£o

O switch expression Ã© uma feature moderna do Java que oferece uma forma mais concisa e segura de escrever estruturas de decisÃ£o mÃºltipla.

## Sintaxe BÃ¡sica

### Switch Expression Tradicional

```JAVA
String status = switch (statusCode) {
    case 200 -> "OK";
    case 404 -> "Not Found";
    case 500 -> "Internal Server Error";
    default -> "Unknown Status";
};
```

### Switch com MÃºltiplos Casos

```JAVA
String category = switch (score) {
    case 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100 -> "A";
    case 80, 81, 82, 83, 84, 85, 86, 87, 88, 89 -> "B";
    case 70, 71, 72, 73, 74, 75, 76, 77, 78, 79 -> "C";
    default -> "F";
};
```

## Recursos AvanÃ§ados

### Yield

```JAVA
String message = switch (level) {
    case "INFO" -> {
        logInfo();
        yield "Information message";
    }
    case "WARNING" -> {
        logWarning();
        yield "Warning message";
    }
    case "ERROR" -> {
        logError();
        yield "Error message";
    }
    default -> "Unknown level";
};
```

### Pattern Matching (Preview)

```JAVA
String typeCheck = switch (obj) {
    case String s -> "Text: " + s;
    case Integer i -> "Number: " + i;
    case Long l -> "Long: " + l;
    case null -> "Null value";
    default -> "Unknown type";
};
```

## Boas PrÃ¡ticas

1. Expressividade

* Use nomes descritivos para variÃ¡veis

* Mantenha casos relacionados agrupados

* Evite lÃ³gica complexa dentro dos casos

2. OrganizaÃ§Ã£o

* Ordene os casos de forma lÃ³gica

* Agrupe casos similares

* Use comentÃ¡rios para documentar casos complexos

3. Manutenibilidade

* Evite fallthrough entre casos

* Sempre inclua um caso default

* Mantenha a lÃ³gica simples e direta

## Exemplos PrÃ¡ticos

### Processador de Status HTTP

```JAVA
HttpResponse processStatus(int code) {
    return switch (code) {
        case 200, 201, 202 -> new SuccessResponse();
        case 400, 401, 403 -> new ClientErrorResponse();
        case 500, 502, 503 -> new ServerErrorResponse();
        default -> new UnknownResponse();
    };
}
```

### Calculadora Simples

```JAVA
double calculate(double a, double b, String operator) {
    return switch (operator) {
        case "+" -> a + b;
        case "-" -> a - b;
        case "*" -> a * b;
        case "/" -> {
            if (b == 0) {
                throw new ArithmeticException("DivisÃ£o por zero");
            }
            yield a / b;
        }
        default -> throw new IllegalArgumentException("Operador invÃ¡lido");
    };
}
```

## Troubleshooting

### Problemas Comuns

1. Esquecimento do Default

```JAVA
// Incorreto - CompilaÃ§Ã£o falha
String result = switch (value) {
    case 1 -> "Um";
    case 2 -> "Dois";
}; // Erro: falta caso default

// Correto
String result = switch (value) {
    case 1 -> "Um";
    case 2 -> "Dois";
    default -> "Outro";
};
```

1. Mistura de Arrow e Block

```JAVA
// Incorreto - Sintaxe inconsistente
String result = switch (value) {
    case 1 -> "Um"
    case 2: yield "Dois";
};

// Correto
String result = switch (value) {
    case 1 -> "Um";
    case 2 -> "Dois";
};
```

## ExercÃ­cios PrÃ¡ticos

1. Conversor de Dia da Semana

```JAVA
String getDayName(int day) {
    return switch (day) {
        case 1 -> "Domingo";
        case 2 -> "Segunda";
        case 3 -> "TerÃ§a";
        case 4 -> "Quarta";
        case 5 -> "Quinta";
        case 6 -> "Sexta";
        case 7 -> "SÃ¡bado";
        default -> "Dia invÃ¡lido";
    };
}
```

1. Classificador de Notas

```JAVA
String classifyGrade(double grade) {
    return switch ((int) grade / 10) {
        case 10, 9 -> "A";
        case 8 -> "B";
        case 7 -> "C";
        case 6 -> "D";
        default -> "F";
    };
}
```

## PrÃ³ximos Passos

* Explore pattern matching em [Pattern Matching](pattern-matching.html)

* Pratique com exercÃ­cios em [Control Flow Projects](control-flow-projects.html)

* Aprenda sobre expressÃµes lambda em [Lambda](null)

[Pattern Matching](pattern-matching.html)



# Pattern Matching

```
>> Inicializando sistema de correspondÃªncia de padrÃµes...
>> Carregando tipos de dados...
>> Estabelecendo regras de matching...
```

## IntroduÃ§Ã£o

Pattern Matching Ã© uma feature moderna do Java que permite testar e extravar valores de objetos de forma mais elegante e segura.

## Pattern Matching com instanceof

### Sintaxe Tradicional vs. Nova

```JAVA
// Forma antiga
if (obj instanceof String) {
    String str = (String) obj;
    System.out.println(str.length());
}

// Pattern Matching
if (obj instanceof String str) {
    System.out.println(str.length());
}
```

### Uso com NegaÃ§Ã£o

```JAVA
if (!(obj instanceof String str)) {
    return;
}
// str estÃ¡ disponÃ­vel aqui
System.out.println(str.length());
```

## Pattern Matching em Switch (Preview)

### Matching por Tipo

```JAVA
String formatted = switch (obj) {
    case String str -> "String: " + str.toUpperCase();
    case Integer num -> "Int: " + num.toString();
    case Double d -> "Double: " + String.format("%.2f", d);
    case null -> "null";
    default -> "Unknown: " + obj.toString();
};
```

### Guarded Patterns

```JAVA
String checkNumber = switch (num) {
    case Integer i when i < 0 -> "Negativo";
    case Integer i when i > 0 -> "Positivo";
    case Integer i -> "Zero";
    default -> "NÃ£o Ã© um nÃºmero";
};
```

## Casos de Uso AvanÃ§ados

### Hierarquia de Classes

```JAVA
public sealed interface Shape 
    permits Circle, Rectangle, Triangle {}

record Circle(double radius) implements Shape {}
record Rectangle(double width, double height) implements Shape {}
record Triangle(double base, double height) implements Shape {}

double calculateArea(Shape shape) {
    return switch (shape) {
        case Circle c -> Math.PI * c.radius() * c.radius();
        case Rectangle r -> r.width() * r.height();
        case Triangle t -> (t.base() * t.height()) / 2;
    };
}
```

### Processamento de Dados

```JAVA
String processData(Object data) {
    return switch (data) {
        case String s when s.length() > 10 -> "String longa: " + s.substring(0, 10) + "...";
        case String s -> "String: " + s;
        case List<?> list when list.isEmpty() -> "Lista vazia";
        case List<?> list -> "Lista com " + list.size() + " elementos";
        case Map<?, ?> map -> "Map com " + map.size() + " entradas";
        case null -> "Dado nulo";
        default -> "Tipo nÃ£o suportado";
    };
}
```

## Boas PrÃ¡ticas

1. Clareza

* Use nomes descritivos para variÃ¡veis de pattern

* Mantenha padrÃµes simples e diretos

* Documente casos complexos

2. OrganizaÃ§Ã£o

* Ordene casos do mais especÃ­fico para o mais genÃ©rico

* Agrupe padrÃµes relacionados

* Use guards para refinar a lÃ³gica

3. Performance

* Evite operaÃ§Ãµes pesadas em guards

* Considere a ordem dos padrÃµes

* Mantenha o cÃ³digo eficiente

## Exemplos PrÃ¡ticos

### Validador de Dados

```JAVA
String validateInput(Object input) {
    return switch (input) {
        case String s when s.isBlank() -> "String vazia";
        case String s when s.matches("\\d+") -> "NÃºmero vÃ¡lido: " + s;
        case String s -> "Texto vÃ¡lido: " + s;
        case Integer i when i >= 0 -> "NÃºmero positivo: " + i;
        case Integer i -> "NÃºmero negativo: " + i;
        case null -> "Input nulo";
        default -> "Input invÃ¡lido";
    };
}
```

### Processador de Eventos

```JAVA
void processEvent(Event event) {
    switch (event) {
        case UserEvent u when u.isAdmin() -> handleAdminEvent(u);
        case UserEvent u -> handleUserEvent(u);
        case SystemEvent s when s.isCritical() -> handleCriticalSystemEvent(s);
        case SystemEvent s -> handleSystemEvent(s);
        case null -> throw new IllegalArgumentException("Evento nulo");
        default -> handleUnknownEvent(event);
    }
}
```

## Troubleshooting

### Problemas Comuns

1. Ordem dos Patterns

```JAVA
// Incorreto - PadrÃ£o inalcanÃ§Ã¡vel
switch (obj) {
    case Object o -> "Objeto";    // Captura tudo
    case String s -> "String";    // Nunca alcanÃ§ado
}

// Correto
switch (obj) {
    case String s -> "String";    // Mais especÃ­fico primeiro
    case Object o -> "Objeto";    // Mais genÃ©rico depois
}
```

1. Null Handling

```JAVA
// Incorreto - NullPointerException possÃ­vel
switch (obj) {
    case String s -> s.length();
    default -> 0;
}

// Correto
switch (obj) {
    case null -> 0;
    case String s -> s.length();
    default -> 0;
}
```

## ExercÃ­cios PrÃ¡ticos

1. Analisador de Dados

```JAVA
String analyzeData(Object data) {
    return switch (data) {
        case String s when s.contains("@") -> "Email: " + s;
        case String s when s.matches("\\d{10}") -> "Telefone: " + s;
        case String s -> "Texto: " + s;
        case Integer i -> "NÃºmero: " + i;
        case List<?> l -> "Lista[" + l.size() + "]";
        case null -> "NULO";
        default -> "Desconhecido";
    };
}
```

1. Calculadora de Formas

```JAVA
record Point(int x, int y) {}
record Circle(Point center, double radius) {}
record Rectangle(Point topLeft, double width, double height) {}

String describeShape(Object shape) {
    return switch (shape) {
        case Circle c -> 
            String.format("CÃ­rculo em (%d,%d) com raio %.2f",
                c.center().x(), c.center().y(), c.radius());
        case Rectangle r -> 
            String.format("RetÃ¢ngulo em (%d,%d) de %.2fx%.2f",
                r.topLeft().x(), r.topLeft().y(), r.width(), r.height());
        case null -> "Forma nula";
        default -> "Forma nÃ£o reconhecida";
    };
}
```

## PrÃ³ximos Passos

* Explore expressÃµes switch em [Switch Expressions](switch-expressions.html)

* Pratique com projetos em [Control Flow Projects](control-flow-projects.html)

* Aprenda sobre sealed classes em [Sealed Classes](null)

[Control Flow Projects](control-flow-projects.html)



# Projetos de Controle de Fluxo

```
>> Iniciando simulaÃ§Ã£o de projetos...
>> Carregando cenÃ¡rios de teste...
>> Executando casos de uso...
```

## VisÃ£o Geral

Esta seÃ§Ã£o apresenta trÃªs projetos prÃ¡ticos que demonstram diferentes aspectos do controle de fluxo em Java, todos ambientados em um contexto cyberpunk.

```MERMAID
graph TD
    A[Projetos de Controle] --> B[Jogo de NÃºmeros]
    A --> C[Sistema de Menu]
    A --> D[MÃ¡quina de Estados]
    
    B --> E[if/else]
    B --> F[while]
    
    C --> G[switch]
    C --> H[break]
    
    D --> I[switch/case]
    D --> J[estados]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#33ccff
    style F fill:#1a1a1a,stroke:#33ccff
    style G fill:#1a1a1a,stroke:#33ccff
    style H fill:#1a1a1a,stroke:#33ccff
    style I fill:#1a1a1a,stroke:#33ccff
    style J fill:#1a1a1a,stroke:#33ccff
```

## Projetos DisponÃ­veis

### 1. Jogo de NÃºmeros

* [Jogo de NÃºmeros](number-game.html) - Um jogo de adivinhaÃ§Ã£o que utiliza loops e condicionais

* Demonstra uso de `while`, `if/else` e operadores de comparaÃ§Ã£o

* Implementa sistema de pontuaÃ§Ã£o e feedback ao usuÃ¡rio

### 2. Sistema de Menu

* [Sistema de Menu](menu-system.html) - Interface de comando baseada em menus

* Explora uso extensivo de `switch/case`

* Demonstra navegaÃ§Ã£o entre diferentes estados do menu

### 3. MÃ¡quina de Estados

* [MÃ¡quina de Estados](state-machine.html) - Sistema de seguranÃ§a com estados

* Implementa uma mÃ¡quina de estados simples

* Utiliza combinaÃ§Ã£o de `switch/case` e controle de fluxo

## Conceitos Aplicados

1. Estruturas Condicionais

* `if/else`

* `switch/case`

* Operadores de comparaÃ§Ã£o

2. Loops

* `while`

* Controle de iteraÃ§Ã£o

* CondiÃ§Ãµes de saÃ­da

3. Controle de Fluxo

* `break`

* `continue`

* Estados e transiÃ§Ãµes

## Objetivos de Aprendizado

* Praticar diferentes estruturas de controle

* Entender fluxo de execuÃ§Ã£o

* Implementar lÃ³gica de decisÃ£o

* Gerenciar estados do programa

## PrÃ³ximos Passos

ApÃ³s completar estes projetos, vocÃª estarÃ¡ preparado para:

1. Desenvolver sistemas mais complexos

2. Combinar diferentes estruturas de controle

3. Implementar lÃ³gica de negÃ³cios mais sofisticada

[Arrays e ColeÃ§Ãµes](arrays-collections.html)

Tip:

"O controle de fluxo Ã© como hackear a Matrix - vocÃª precisa saber exatamente onde e quando dobrar as regras."



# Jogo de NÃºmeros

## DescriÃ§Ã£o do Projeto

Desenvolva um jogo de adivinhaÃ§Ã£o onde o jogador tenta adivinhar um nÃºmero gerado aleatoriamente pelo sistema.

## Conceitos Aplicados

* Loops (while/do-while)

* Condicionais (if/else)

* Switch Expressions

* Pattern Matching

## ImplementaÃ§Ã£o Base

```JAVA
public class NumberGame {
    public static void main(String[] args) {
        // ConfiguraÃ§Ãµes do jogo usando tipos primitivos
        int numeroSecreto = 42; // NÃºmero fixo para simplificar
        int tentativasMaximas = 5;
        int tentativas = 0;
        boolean jogoAtivo = true;
        
        // Mensagem inicial usando Text Block
        System.out.println("""
            === JOGO DE ADIVINHAÃ‡ÃƒO ===
            Tente adivinhar o nÃºmero entre 1 e 100
            VocÃª tem 5 tentativas!
            =========================
            """);
        
        // Loop principal do jogo
        while (jogoAtivo && tentativas < tentativasMaximas) {
            System.out.println("\nTentativa " + (tentativas + 1) + " de " + tentativasMaximas);
            System.out.print("Digite seu palpite: ");
            
            // Simulando entrada do usuÃ¡rio (vocÃª pode modificar para testar)
            var palpite = 50; // Simula entrada do usuÃ¡rio
            
            // Incrementa tentativas
            tentativas++;
            
            // Verifica o palpite
            if (palpite == numeroSecreto) {
                System.out.println("ParabÃ©ns! VocÃª acertou em " + tentativas + " tentativas!");
                jogoAtivo = false;
            } else {
                // Verifica se ainda tem tentativas
                if (tentativas >= tentativasMaximas) {
                    System.out.println("Game Over! O nÃºmero era " + numeroSecreto);
                } else {
                    // DÃ¡ dicas baseadas no palpite
                    if (palpite < numeroSecreto) {
                        System.out.println("Tente um nÃºmero MAIOR!");
                    } else {
                        System.out.println("Tente um nÃºmero MENOR!");
                    }
                    
                    // Mostra tentativas restantes
                    System.out.println("Tentativas restantes: " + (tentativasMaximas - tentativas));
                }
            }
            
            // Pequena pausa para simular processamento
            System.out.println("Processando...");
        }
        
        // PontuaÃ§Ã£o final
        int pontuacao = 0;
        if (!jogoAtivo) { // Se acertou
            pontuacao = (tentativasMaximas - tentativas + 1) * 100;
            System.out.println("Sua pontuaÃ§Ã£o: " + pontuacao);
        }
        
        System.out.println("Fim do jogo!");
    }
}
```

## Interface com UsuÃ¡rio

```JAVA
public class NumberGameUI {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        NumberGame game = new NumberGame(100, 5);
        
        System.out.println("=== Jogo de AdivinhaÃ§Ã£o ===");
        System.out.println("Tente adivinhar o nÃºmero entre 1 e 100");
        
        do {
            System.out.print("Digite seu palpite: ");
            if (scanner.hasNextInt()) {
                int guess = scanner.nextInt();
                String result = game.processGuess(guess);
                System.out.println(result);
            } else {
                System.out.println("Por favor, digite um nÃºmero vÃ¡lido!");
                scanner.next();
            }
        } while (!game.isGameOver());
    }
}
```

## Desafios de ExtensÃ£o

1. NÃ­veis de Dificuldade

```JAVA
public enum Difficulty {
    EASY(1, 10, 6),
    MEDIUM(1, 100, 5),
    HARD(1, 1000, 4);

    final int min, max, attempts;
    
    Difficulty(int min, int max, int attempts) {
        this.min = min;
        this.max = max;
        this.attempts = attempts;
    }
}
```

1. Sistema de PontuaÃ§Ã£o

```JAVA
public int calculateScore() {
    return switch (state) {
        case WON -> (maxAttempts - attempts + 1) * 100;
        case LOST -> 0;
        default -> throw new IllegalStateException("Jogo ainda em andamento");
    };
}
```

## PrÃ³ximos Passos

* Implemente o sistema de dificuldade

* Adicione um sistema de recordes

* Crie um modo multiplayer

[Menu System](menu-system.html)



# Sistema de Menu

## DescriÃ§Ã£o do Projeto

Desenvolva um sistema de menu interativo estilo cyberpunk para uma interface de terminal.

## Conceitos Aplicados

* Switch Expressions

* Pattern Matching

* Loops

* Condicionais Aninhados

## ImplementaÃ§Ã£o Base

```JAVA
public class MenuSystem {
    public static void main(String[] args) {
        // Estado atual do menu usando String
        String menuAtual = "PRINCIPAL";
        
        // Flag para controle do loop
        boolean sistemaAtivo = true;
        
        // Mensagem de boas-vindas usando Text Block
        System.out.println("""
            === SISTEMA CYBERDECK v1.0 ===
            Menu Principal:
            1. Iniciar Sistema
            2. ConfiguraÃ§Ãµes
            3. Status
            4. Sair
            ===========================
            """);
        
        // Loop principal do sistema
        while (sistemaAtivo) {
            System.out.println("\nMenu atual: " + menuAtual);
            System.out.print("Digite uma opÃ§Ã£o: ");
            
            // Simulando entrada do usuÃ¡rio (vocÃª pode modificar para testar)
            var opcao = "1"; // Simula entrada do usuÃ¡rio
            
            // Controle de fluxo baseado no menu atual
            switch (menuAtual) {
                case "PRINCIPAL":
                    switch (opcao) {
                        case "1":
                            menuAtual = "SISTEMA";
                            System.out.println("""
                                === Menu do Sistema ===
                                1. Verificar Status
                                2. Executar DiagnÃ³stico
                                3. Voltar
                                """);
                            break;
                        case "2":
                            menuAtual = "CONFIG";
                            System.out.println("""
                                === Menu de ConfiguraÃ§Ãµes ===
                                1. Display
                                2. SeguranÃ§a
                                3. Rede
                                4. Voltar
                                """);
                            break;
                        case "3":
                            System.out.println("""
                                Status do Sistema:
                                - MemÃ³ria: OK
                                - Processador: OK
                                - Rede: OK
                                """);
                            break;
                        case "4":
                            sistemaAtivo = false;
                            break;
                    }
                    break;
                    
                case "CONFIG":
                    switch (opcao) {
                        case "1":
                            System.out.println("Configurando Display...");
                            break;
                        case "2":
                            System.out.println("Configurando SeguranÃ§a...");
                            break;
                        case "3":
                            System.out.println("Configurando Rede...");
                            break;
                        case "4":
                            menuAtual = "PRINCIPAL";
                            System.out.println("Voltando ao Menu Principal...");
                            break;
                    }
                    break;
                    
                case "SISTEMA":
                    switch (opcao) {
                        case "1":
                            System.out.println("Verificando status...");
                            break;
                        case "2":
                            System.out.println("Executando diagnÃ³stico...");
                            break;
                        case "3":
                            menuAtual = "PRINCIPAL";
                            System.out.println("Voltando ao Menu Principal...");
                            break;
                    }
                    break;
            }
            
            // Pequena pausa para simular processamento
            System.out.println("Processando...");
        }
        
        System.out.println("Sistema finalizado.");
    }
}
```

## Interface com UsuÃ¡rio

```JAVA
public class MenuSystemUI {
    public static void main(String[] args) {
        MenuSystem menu = new MenuSystem();
        Scanner scanner = new Scanner(System.in);
        
        System.out.println("""
            === SISTEMA CYBERDECK v1.0 ===
            Iniciando interface...
            """);
        
        String input;
        do {
            System.out.print("> ");
            input = scanner.nextLine().trim();
            String response = menu.processInput(input);
            System.out.println(response);
        } while (!input.equals("exit"));
    }
}
```

## Recursos AvanÃ§ados

1. AnimaÃ§Ãµes de Terminal

```JAVA
public class TerminalEffects {
    public static void typeWriter(String text) {
        for (char c : text.toCharArray()) {
            System.out.print(c);
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        System.out.println();
    }
}
```

1. Sistema de Cores

```JAVA
public class ColoredOutput {
    public static final String ANSI_GREEN = "\u001B[32m";
    public static final String ANSI_RED = "\u001B[31m";
    public static final String ANSI_RESET = "\u001B[0m";
    
    public static String success(String text) {
        return ANSI_GREEN + text + ANSI_RESET;
    }
    
    public static String error(String text) {
        return ANSI_RED + text + ANSI_RESET;
    }
}
```

## Desafios de ExtensÃ£o

1. Adicione autenticaÃ§Ã£o de usuÃ¡rio

2. Implemente submenus dinÃ¢micos

3. Crie um sistema de logs

4. Adicione efeitos visuais ASCII art

## PrÃ³ximos Passos

* Implemente mais funcionalidades no menu

* Adicione persistÃªncia de configuraÃ§Ãµes

* Crie uma interface grÃ¡fica ASCII mais elaborada

[State Machine](state-machine.html)



# MÃ¡quina de Estados

## DescriÃ§Ã£o do Projeto

Implemente uma mÃ¡quina de estados que simula um sistema de seguranÃ§a cyberpunk.

## Conceitos Aplicados

* Pattern Matching

* Switch Expressions

* Loops Controlados por Estado

* Condicionais Complexos

## ImplementaÃ§Ã£o Base

```JAVA
public class StateMachine {
    public static void main(String[] args) {
        // Estados possÃ­veis usando String
        String estado = "TRAVADO";  // estado inicial
        
        // Contadores e flags usando tipos primitivos
        int tentativasInvalidas = 0;
        boolean sistemaAtivo = true;
        
        // Mensagem de boas-vindas usando Text Block
        System.out.println("""
            === SISTEMA DE SEGURANÃ‡A CYBERPUNK ===
            Estados: TRAVADO, DESTRAVADO, ALERTA
            Comandos: 
            1 - Inserir cÃ³digo vÃ¡lido
            2 - Inserir cÃ³digo invÃ¡lido
            3 - Travar sistema
            4 - Sair
            ====================================
            """);
        
        // Loop principal do sistema
        while (sistemaAtivo) {
            System.out.println("\nEstado atual: " + estado);
            System.out.print("Digite um comando: ");
            
            // Simulando entrada do usuÃ¡rio (vocÃª pode modificar os valores para testar)
            var comando = "1"; // Simula entrada do usuÃ¡rio
            
            // Controle de fluxo baseado no estado atual
            switch (estado) {
                case "TRAVADO":
                    if (comando.equals("1")) {
                        estado = "DESTRAVADO";
                        tentativasInvalidas = 0;
                        System.out.println("Acesso concedido!");
                    } else if (comando.equals("2")) {
                        tentativasInvalidas++;
                        if (tentativasInvalidas >= 3) {
                            estado = "ALERTA";
                            System.out.println("ALERTA: MÃºltiplas tentativas invÃ¡lidas!");
                        } else {
                            System.out.println("CÃ³digo invÃ¡lido. Tentativas restantes: " + (3 - tentativasInvalidas));
                        }
                    }
                    break;
                    
                case "DESTRAVADO":
                    if (comando.equals("3")) {
                        estado = "TRAVADO";
                        System.out.println("Sistema travado!");
                    }
                    break;
                    
                case "ALERTA":
                    if (comando.equals("1")) {
                        estado = "TRAVADO";
                        tentativasInvalidas = 0;
                        System.out.println("Sistema resetado!");
                    }
                    break;
            }
            
            // CondiÃ§Ã£o de saÃ­da
            if (comando.equals("4")) {
                sistemaAtivo = false;
                System.out.println("Encerrando sistema...");
            }
            
            // Pequena pausa para simular processamento
            System.out.println("Processando...");
        }
    }
}
```

## Interface com UsuÃ¡rio

```JAVA
public class SecuritySystemUI {
    public static void main(String[] args) {
        SecuritySystem system = new SecuritySystem();
        Scanner scanner = new Scanner(System.in);
        
        System.out.println("""
            === SISTEMA DE SEGURANÃ‡A CYBERPUNK ===
            Digite 'help' para ver os comandos disponÃ­veis
            """);
        
        while (true) {
            System.out.print(">> ");
            String input = scanner.nextLine().toUpperCase();
            
            if (input.equals("EXIT")) break;
            
            try {
                SecurityEvent event = SecurityEvent.valueOf(input);
                String result = system.processEvent(event);
                System.out.println(result);
            } catch (IllegalArgumentException e) {
                if (input.equals("HELP")) {
                    showHelp();
                } else {
                    System.out.println("Comando invÃ¡lido");
                }
            }
        }
    }
    
    private static void showHelp() {
        System.out.println("""
            Comandos disponÃ­veis:
            VALID_CODE - Tentar cÃ³digo de acesso
            INVALID_CODE - CÃ³digo invÃ¡lido
            LOCK - Travar sistema
            EMERGENCY - Ativar emergÃªncia
            MAINTENANCE_KEY - Modo manutenÃ§Ã£o
            RESET - Resetar sistema
            SHUTDOWN - Desligar sistema
            EXIT - Sair do programa
            """);
    }
}
```

## Recursos AvanÃ§ados

1. Sistema de Biometria

```JAVA
public class BiometricScanner {
    public boolean validateBiometric(String bioData) {
        return switch (bioData.length()) {
            case 32 -> bioData.matches("[A-F0-9]+");
            case 64 -> bioData.matches("[a-f0-9]+");
            default -> false;
        };
    }
}
```

1. Monitor de Atividades

```JAVA
public class ActivityMonitor {
    private final Queue<SecurityEvent> recentEvents;
    private static final int MAX_EVENTS = 10;
    
    public ActivityMonitor() {
        this.recentEvents = new LinkedList<>();
    }
    
    public void recordEvent(SecurityEvent event) {
        recentEvents.offer(event);
        if (recentEvents.size() > MAX_EVENTS) {
            recentEvents.poll();
        }
    }
    
    public boolean detectSuspiciousActivity() {
        long invalidAttempts = recentEvents.stream()
            .filter(e -> e == SecurityEvent.INVALID_CODE)
            .count();
        return invalidAttempts >= 3;
    }
}
```

## Desafios de ExtensÃ£o

1. Implemente um sistema de nÃ­veis de acesso

2. Adicione criptografia para cÃ³digos de acesso

3. Crie um sistema de backup automÃ¡tico

4. Implemente notificaÃ§Ãµes em tempo real

## PrÃ³ximos Passos

* Adicione mais estados e eventos

* Implemente persistÃªncia de logs

* Crie uma interface grÃ¡fica mais elaborada

* Adicione suporte a mÃºltiplos usuÃ¡rios

[Control Flow](control-flow.html)



# Arrays e ColeÃ§Ãµes

![Arrays and Collections Banner](arrays-collections-banner.png)

```
DATA STRUCTURES
â”œâ”€â”€ Arrays
â”‚   â”œâ”€â”€ Unidimensionais
â”‚   â””â”€â”€ Multidimensionais
â””â”€â”€ Collections
    â”œâ”€â”€ List
    â”œâ”€â”€ Set
    â”œâ”€â”€ Queue
    â””â”€â”€ Map
```

## VisÃ£o Geral

Esta seÃ§Ã£o explora as estruturas de dados fundamentais em Java, desde arrays bÃ¡sicos atÃ© as coleÃ§Ãµes mais sofisticadas do framework Collections.

```MERMAID
graph TD
    A[Estruturas de Dados] --> B[Arrays]
    A --> C[Collections]
    
    B --> D[Arrays Primitivos]
    B --> E[Arrays de Objetos]
    
    C --> F[List]
    C --> G[Set]
    C --> H[Queue]
    C --> I[Map]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#33ccff
    style E fill:#1a1a1a,stroke:#33ccff
    style F fill:#1a1a1a,stroke:#33ccff
    style G fill:#1a1a1a,stroke:#33ccff
    style H fill:#1a1a1a,stroke:#33ccff
    style I fill:#1a1a1a,stroke:#33ccff
```

## MÃ³dulos do Curso

### 1. Arrays Fundamentais

* [Arrays](arrays.html) - Estruturas bÃ¡sicas e manipulaÃ§Ã£o

* Arrays unidimensionais e multidimensionais

* OperaÃ§Ãµes comuns e boas prÃ¡ticas

### 2. Framework Collections

* [VisÃ£o Geral das Collections](collections-overview.html)

* [Listas](lists.html) - SequÃªncias ordenadas

* [Sets](sets.html) - Conjuntos sem duplicatas

* [Maps](maps.html) - Pares chave-valor

* [Queues](queues.html) - Filas e pilhas

* [Stacks](stacks.html) - Estruturas LIFO

### 3. Projetos PrÃ¡ticos

* [Gerenciador de Tarefas](task-manager.html)

* [Sistema de InventÃ¡rio](inventory-system.html)

* [ImplementaÃ§Ã£o de Cache](cache-implementation.html)

## Conceitos Principais

1. Arrays

* AlocaÃ§Ã£o de memÃ³ria

* IndexaÃ§Ã£o

* IteraÃ§Ã£o

* Arrays multidimensionais

2. Collections Framework

* Interfaces principais

* ImplementaÃ§Ãµes comuns

* Algoritmos de coleÃ§Ãµes

* Iteradores

3. Performance e Uso

* Complexidade de tempo

* Uso de memÃ³ria

* Escolha da estrutura adequada

* OtimizaÃ§Ãµes

## Objetivos de Aprendizado

* Dominar manipulaÃ§Ã£o de arrays

* Entender o framework Collections

* Escolher estruturas apropriadas

* Implementar soluÃ§Ãµes eficientes

## PrÃ³ximos Passos

ApÃ³s esta seÃ§Ã£o, vocÃª estarÃ¡ preparado para:

1. Trabalhar com estruturas de dados complexas

2. Implementar algoritmos eficientes

3. Desenvolver sistemas escalÃ¡veis

[Fundamentos de OOP](oop-fundamentals.html)

Tip:

"Em um mundo digital, dados sÃ£o poder. A forma como vocÃª os estrutura determina sua eficiÃªncia no combate."



# Arrays em Java

```
ARRAY OPERATIONS
â”œâ”€â”€ DeclaraÃ§Ã£o (Como registrar clientes em um bordel)
â”œâ”€â”€ InicializaÃ§Ã£o (Abrir as portas)
â”œâ”€â”€ Acesso (Encontrar seu favorito)
â”œâ”€â”€ ModificaÃ§Ã£o (Trocar os nÃºmeros)
â””â”€â”€ IteraÃ§Ã£o (Fazer a ronda noturna)
```

## Fundamentos

Arrays sÃ£o como um bordel bem organizado - cada quarto tem seu nÃºmero, e vocÃª sabe exatamente o que esperar em cada um. Sem surpresas desagradÃ¡veis.

```JAVA
// DeclaraÃ§Ã£o e inicializaÃ§Ã£o
int[] quartos = new int[5];  // 5 quartos vazios
String[] servicos = {"BASICO", "ESPECIAL", "COMPLETO"};

// Array multidimensional (como um prÃ©dio com vÃ¡rios andares)
int[][] predio = new int[3][3];
```

## CaracterÃ­sticas Principais

### 1. Tamanho Fixo (Como um Motel Lotado)

```JAVA
// Uma vez definido o nÃºmero de quartos, nÃ£o dÃ¡ pra criar mais
int numQuartos = 10;
double[] precos = new double[numQuartos];

// Nem adianta chorar, nÃ£o vai caber mais
System.out.println("Quartos disponÃ­veis: " + precos.length);
```

### 2. IndexaÃ§Ã£o Base-Zero (Como Idade de PolÃ­tico)

```JAVA
// O primeiro sempre comeÃ§a do zero
int primeiro = quartos[0];  // Quarto 0 (mas na placa tÃ¡ 1)

// O Ãºltimo Ã© sempre um a menos que o total
int ultimo = quartos[quartos.length - 1];
```

### 3. Tipo HomogÃªneo (Como Menu de Boteco)

```JAVA
// Aqui sÃ³ serve cachaÃ§a, amigo
String[] drinks = new String[3];
drinks[0] = "51";
drinks[1] = "Velho Barreiro";
drinks[2] = "PitÃº";
```

## OperaÃ§Ãµes Comuns

### IteraÃ§Ã£o (Como Fazer a Ronda)

```JAVA
// MÃ©todo tradicional (checando quarto por quarto)
for (int i = 0; i < quartos.length; i++) {
    System.out.println("Verificando quarto " + i);
}

// MÃ©todo moderno (cÃ¢meras de seguranÃ§a)
for (String drink : drinks) {
    System.out.println("Bebida disponÃ­vel: " + drink);
}
```

### ManipulaÃ§Ã£o (Como Gerenciar o Estabelecimento)

```JAVA
// Resetar preÃ§os (promoÃ§Ã£o de segunda)
Arrays.fill(precos, 29.90);

// Ordenar por preÃ§o (do mais barato pro mais caro)
Arrays.sort(precos);

// Procurar aquele cliente especial
int indice = Arrays.binarySearch(drinks, "51");
```

## Arrays Multidimensionais (Como um Cassino de Luxo)

### Matrizes

```JAVA
// Mapa do cassino (3 andares, cada um com 3 salas)
int[][] cassino = {
    {1, 2, 3},  // CaÃ§a-nÃ­queis
    {4, 5, 6},  // Poker
    {7, 8, 9}   // Roleta
};

// Encontrar mesa especÃ­fica
int mesa = cassino[1][2];  // Mesa 6 de poker
```

### IteraÃ§Ã£o em Matrizes (InspeÃ§Ã£o SanitÃ¡ria)

```JAVA
// Verificando todas as mesas
for (int andar = 0; andar < cassino.length; andar++) {
    for (int sala = 0; sala < cassino[andar].length; sala++) {
        System.out.print("Verificando mesa " + cassino[andar][sala]);
    }
    System.out.println(" - Andar limpo!");
}
```

## Boas PrÃ¡ticas (Regras da Casa)

1. ValidaÃ§Ã£o de Ãndices (Checagem de ID)

```JAVA
if (quarto >= 0 && quarto < quartos.length) {
    // Cliente pode entrar
    return quartos[quarto];
}
```

1. CÃ³pia de Arrays (Expandindo o NegÃ³cio)

```JAVA
// Abrindo filial com mesma configuraÃ§Ã£o
int[] filial = Arrays.copyOf(quartos, quartos.length);

// Pegando sÃ³ o melhor da casa
int[] vips = Arrays.copyOfRange(quartos, 1, 4);
```

## ExercÃ­cios PrÃ¡ticos

1. Implemente um sistema de rodÃ­zio de "funcionÃ¡rios"

2. Crie um controle de mesas de poker

3. Desenvolva um algoritmo de distribuiÃ§Ã£o de gorjetas

## PrÃ³ximos Passos

Depois de dominar esse bordel de arrays, vocÃª estarÃ¡ pronto para:

1. Gerenciar uma rede de estabelecimentos

2. Implementar sistemas de fidelidade

3. Expandir para o mercado internacional

[Collections: Quando Um NÃ£o Ã© Suficiente](collections-overview.html)

Tip:

"Arrays sÃ£o como um bordel bem administrado - cada elemento no seu lugar, e vocÃª sempre sabe onde encontrar o que procura."



# Collections Framework: O Submundo das Estruturas de Dados

```
COLLECTIONS HIERARCHY
â”œâ”€â”€ List (Como uma Lista de Devedores)
â”œâ”€â”€ Set (Clube Exclusivo, Sem Repetidos)
â”œâ”€â”€ Queue (Fila do PÃ£o, Mas Com Classe)
â””â”€â”€ Map (Agenda TelefÃ´nica do Traficante)
```

## Anatomia do Submundo

Imagine o Collections Framework como uma organizaÃ§Ã£o criminosa bem estruturada - cada famÃ­lia tem sua especialidade, mas todas trabalham juntas quando necessÃ¡rio.

```JAVA
// As principais famÃ­lias
List<String> listaDaChantagem = new ArrayList<>();
Set<String> membrosVIP = new HashSet<>();
Queue<String> filaDeEspera = new LinkedList<>();
Map<String, Double> contasAReceber = new HashMap<>();
```

## FamÃ­lias Principais

### 1. List (A Lista Negra)

```JAVA
List<String> alvos = new ArrayList<>();
alvos.add("JoÃ£o Caloteiro");    // Adiciona no final
alvos.add(0, "Maria Malandra"); // Adiciona no inÃ­cio
String proximo = alvos.get(0);  // PrÃ³xima vÃ­tima
```

### 2. Set (Clube dos Exclusivos)

```JAVA
Set<String> vips = new HashSet<>();
vips.add("Don Corleone");     // Entra no clube
vips.add("Don Corleone");     // Tenta entrar de novo (falha)
boolean isMembro = vips.contains("Don Corleone"); // TÃ¡ na lista?
```

### 3. Queue (Fila do Desespero)

```JAVA
Queue<String> esperando = new LinkedList<>();
esperando.offer("ZÃ© Devedor");  // Entra na fila
String proximo = esperando.poll(); // PrÃ³ximo a ser "atendido"
String espiadinha = esperando.peek(); // Quem Ã© o prÃ³ximo sem tirar
```

### 4. Map (Livro Caixa)

```JAVA
Map<String, Double> dividas = new HashMap<>();
dividas.put("ZÃ©", 1000.0);     // Deve mil
dividas.put("Maria", 2000.0);   // Deve dois mil
Double quanto = dividas.get("ZÃ©"); // Quanto o ZÃ© deve?
```

## Escolhendo sua Arma

### ArrayList vs LinkedList

```JAVA
// ArrayList: Acesso rÃ¡pido, como endereÃ§o fixo
List<String> enderecos = new ArrayList<>();  // Ã“timo para consultas

// LinkedList: InserÃ§Ã£o rÃ¡pida, como mensageiro
List<String> mensagens = new LinkedList<>();  // Bom para alteraÃ§Ãµes
```

### HashSet vs TreeSet

```JAVA
// HashSet: RÃ¡pido e caÃ³tico, como bar de porto
Set<String> frequentadores = new HashSet<>();  // NÃ£o liga pra ordem

// TreeSet: Organizado e lento, como clube de madame
Set<String> clientesVIP = new TreeSet<>();     // Tudo ordenadinho
```

### HashMap vs TreeMap

```JAVA
// HashMap: BagunÃ§ado mas eficiente, como caderno de agiota
Map<String, Double> pagamentos = new HashMap<>();

// TreeMap: Organizado e metÃ³dico, como livro contÃ¡bil
Map<String, Double> contabilidade = new TreeMap<>();
```

## OperaÃ§Ãµes Especiais

### IteraÃ§Ã£o (Fazendo a Ronda)

```JAVA
// For each moderno
for (String devedor : alvos) {
    System.out.println("Procurando: " + devedor);
}

// Iterator (modo old school)
Iterator<String> it = alvos.iterator();
while (it.hasNext()) {
    String alvo = it.next();
    if (alvo.contains("Delator")) {
        it.remove(); // Remove o X9
    }
}
```

### OrdenaÃ§Ã£o (Organizando a Casa)

```JAVA
// Ordenar a lista de devedores por nome
Collections.sort(alvos);

// Ordenar por valor da dÃ­vida
alvos.sort((a, b) -> dividas.get(a).compareTo(dividas.get(b)));
```

## Dicas de SobrevivÃªncia

1. Escolha Certa

* ArrayList para acesso rÃ¡pido

* LinkedList para muitas alteraÃ§Ãµes

* HashSet para unicidade

* TreeSet para ordem natural

* HashMap para acesso por chave

* TreeMap para ordem nas chaves

2. Performance

```JAVA
// Defina o tamanho inicial se souber
List<String> lista = new ArrayList<>(1000);

// Use a estrutura certa pro trabalho
Set<String> conjunto = new HashSet<>();  // Mais rÃ¡pido que List pra busca
```

## ExercÃ­cios PrÃ¡ticos

1. Implemente um sistema de controle de territÃ³rio

2. Crie um gerenciador de dÃ­vidas com juros compostos

3. Desenvolva uma lista de "proteÃ§Ã£o" com prioridades

## PrÃ³ximos Passos

Depois de dominar as Collections, vocÃª estarÃ¡ pronto para:

1. Gerenciar dados como um profissional

2. Implementar estruturas complexas

3. Otimizar operaÃ§Ãµes de dados

[Arrays: De Volta ao BÃ¡sico](arrays.html)
[Lists: Quando a Ordem Importa](lists.html)

Tip:

"Collections sÃ£o como uma famÃ­lia do crime organizado - cada uma tem seu papel, e juntas controlam toda a cidade dos dados."



# Lists: A Playlist do Baile Funk

```
LIST TYPES
â”œâ”€â”€ ArrayList (Camarote VIP)
â””â”€â”€ LinkedList (Fila do Open Bar)
```

## Fundamentos

Lists sÃ£o como uma festa funk - tem ordem, repetiÃ§Ã£o e sempre cabe mais um.

```JAVA
// Criando a lista de convidados
List<String> convidados = new ArrayList<>();
convidados.add("MC Kevinho");    // Adiciona no fim da lista
convidados.add(0, "MC Livinho"); // Fura a fila (adiciona no inÃ­cio)
```

## ArrayList vs LinkedList

### ArrayList (Camarote VIP)

```JAVA
// RÃ¡pido pra achar alguÃ©m, como camarote numerado
ArrayList<String> camarote = new ArrayList<>();
camarote.add("Anitta");
camarote.get(0);         // Acesso direto, mesa 0
```

### LinkedList (Fila do Open Bar)

```JAVA
// Melhor pra galera entrar e sair, como fila de open bar
LinkedList<String> openBar = new LinkedList<>();
openBar.addFirst("Sedento");   // Furando fila
openBar.addLast("Paciente");   // Entrando no fim
```

## OperaÃ§Ãµes BÃ¡sicas (Como Gerenciar o Baile)

### AdiÃ§Ã£o (Deixa Entrar)

```JAVA
// VÃ¡rios jeitos de deixar a galera entrar
List<String> baile = new ArrayList<>();
baile.add("DanÃ§arino");           // Fim da fila
baile.add(0, "DJ");               // VIP, direto pro inÃ­cio
baile.addAll(Arrays.asList("MC", "DJ", "Beat Maker")); // Grupo
```

### RemoÃ§Ã£o (Expulsando da Festa)

```JAVA
// Diferentes formas de expulsar
baile.remove("ConfusÃ£o");          // Remove elemento especÃ­fico
baile.remove(0);                   // Remove da posiÃ§Ã£o
baile.removeIf(x -> x.contains("Briga")); // Remove todos briguentos
```

### Acesso (Procurando na MultidÃ£o)

```JAVA
// Encontrando a galera
String vip = baile.get(0);         // Pega pela posiÃ§Ã£o
int pos = baile.indexOf("DJ");     // Onde tÃ¡ o DJ?
boolean temMC = baile.contains("MC"); // O MC chegou?
```

## Lists Especializadas (Ãreas VIP)

### Vector (Antiga Casa de Show)

```JAVA
// Synchronized por padrÃ£o, como seguranÃ§a old school
Vector<String> casaAntiga = new Vector<>();
casaAntiga.add("DanÃ§arino ClÃ¡ssico");
```

### Stack (Pilha de Caixas de Som)

```JAVA
// LIFO - Last In, First Out
Stack<String> equipamento = new Stack<>();
equipamento.push("Grave");     // Empilha
String topo = equipamento.pop(); // Desempilha
```

## OrdenaÃ§Ã£o (Organizando o Line-up)

```JAVA
// Ordenando a lista de apresentaÃ§Ãµes
List<String> lineup = new ArrayList<>();
lineup.addAll(Arrays.asList("MC Late", "DJ Early", "MC Prime"));

// Ordem alfabÃ©tica
Collections.sort(lineup);

// Ordem personalizada
lineup.sort((a, b) -> a.length() - b.length()); // Por tamanho do nome
```

## IteraÃ§Ã£o (Passando o Som)

```JAVA
// For tradicional (Contagem regressiva)
for (int i = 0; i < lineup.size(); i++) {
    System.out.println("PrÃ³ximo: " + lineup.get(i));
}

// For each (Passando o som)
for (String artista : lineup) {
    System.out.println("No palco: " + artista);
}

// Iterator (Revista na entrada)
Iterator<String> revista = lineup.iterator();
while (revista.hasNext()) {
    String pessoa = revista.next();
    if (pessoa.contains("Problema")) {
        revista.remove(); // Barrado
    }
}
```

## Dicas Pro Baile

1. Escolha Certa

* ArrayList: Quando precisa acessar rÃ¡pido

* LinkedList: Quando a galera entra e sai muito

2. Performance

```JAVA
// Define o tamanho se souber quantos vem
List<String> convidados = new ArrayList<>(100);

// Limpa a lista depois da festa
convidados.clear();
```

## ExercÃ­cios PrÃ¡ticos

1. Implemente um sistema de fila de entrada

2. Crie um gerenciador de playlists

3. Desenvolva um controlador de pedidos de mÃºsica

## PrÃ³ximos Passos

Depois de dominar as Lists, vocÃª estarÃ¡ pronto para:

1. Gerenciar qualquer tipo de sequÃªncia ordenada

2. Implementar filas e pilhas eficientes

3. Organizar dados com repetiÃ§Ã£o

[Collections Overview](collections-overview.html)
[Sets: Sem Repeteco](sets.html)

Tip:

"Lists sÃ£o como um baile funk: tem ordem, aceita repetiÃ§Ã£o e sempre cabe mais um na pista!"



# Sets: O Clube dos Ãšnicos

```
SET TYPES
â”œâ”€â”€ HashSet (Balada Alternativa)
â”œâ”€â”€ LinkedHashSet (Festa TemÃ¡tica)
â””â”€â”€ TreeSet (Clube da Alta Sociedade)
```

## Fundamentos

Sets sÃ£o como uma festa exclusiva - nÃ£o tem repetido e cada um Ã© Ãºnico.

```JAVA
// Criando a lista do clube mais exclusivo
Set<String> clubeDosUnicos = new HashSet<>();
clubeDosUnicos.add("Hipster");    // Entra
clubeDosUnicos.add("Hipster");    // Barrado! JÃ¡ tem um igual
```

## Tipos de Sets (Diferentes Baladas)

### HashSet (Balada Alternativa)

```JAVA
// RÃ¡pido e caÃ³tico, como uma rave
HashSet<String> rave = new HashSet<>();
rave.add("Raver");      // Ordem? Que ordem?
rave.add("DJ");         // Entra onde der
```

### LinkedHashSet (Festa TemÃ¡tica)

```JAVA
// MantÃ©m a ordem de entrada, como fila organizada
LinkedHashSet<String> tematica = new LinkedHashSet<>();
tematica.add("Anos 80");  // Primeiro
tematica.add("Anos 90");  // Segundo
```

### TreeSet (Clube da Alta Sociedade)

```JAVA
// Sempre ordenado, como lista de socialites
TreeSet<String> clubeSocial = new TreeSet<>();
clubeSocial.add("Baronesa");   // SerÃ¡ ordenado
clubeSocial.add("Condessa");   // Automaticamente
```

## OperaÃ§Ãµes BÃ¡sicas (Regras do Clube)

### AdiÃ§Ã£o (Tentando Entrar)

```JAVA
Set<String> clube = new HashSet<>();
clube.add("SÃ³cio");            // Bem-vindo ao clube
clube.add("SÃ³cio");            // Negado! JÃ¡ Ã© membro
clube.addAll(Arrays.asList("VIP", "Premium")); // Grupo VIP
```

### RemoÃ§Ã£o (Cancelando Sociedade)

```JAVA
// Diferentes formas de expulsar
clube.remove("Ex-sÃ³cio");       // Remove especÃ­fico
clube.removeIf(x -> x.startsWith("Inadimplente")); // Remove todos inadimplentes
```

### VerificaÃ§Ã£o (Lista na Porta)

```JAVA
// Checando quem pode entrar
boolean isMembro = clube.contains("VIP");     // EstÃ¡ na lista?
boolean todosVIP = clube.containsAll(vips);   // Grupo inteiro na lista?
```

## OperaÃ§Ãµes de Conjunto (Misturando as Tribos)

```JAVA
Set<String> metaleiros = new HashSet<>();
Set<String> punks = new HashSet<>();

// UniÃ£o (Festa de Rock)
Set<String> rockeiros = new HashSet<>(metaleiros);
rockeiros.addAll(punks);

// InterseÃ§Ã£o (Amigos em Comum)
Set<String> hibridos = new HashSet<>(metaleiros);
hibridos.retainAll(punks);

// DiferenÃ§a (SÃ³ Metaleiros)
Set<String> puristas = new HashSet<>(metaleiros);
puristas.removeAll(punks);
```

## IteraÃ§Ã£o (Fazendo a Social)

```JAVA
// For each (Cumprimentando todo mundo)
for (String socio : clube) {
    System.out.println("Boa noite, " + socio);
}

// Iterator (Revista VIP)
Iterator<String> revista = clube.iterator();
while (revista.hasNext()) {
    String pessoa = revista.next();
    if (pessoa.contains("Indesejado")) {
        revista.remove(); // Tchau!
    }
}
```

## Dicas de Etiqueta

1. Escolha do Clube

* HashSet: Quando sÃ³ importa ser Ãºnico

* LinkedHashSet: Quando a ordem de entrada importa

* TreeSet: Quando precisa manter tudo ordenado

2. Performance

```JAVA
// Define tamanho inicial se souber
Set<String> vips = new HashSet<>(100);

// Use o tipo certo pra cada ocasiÃ£o
Set<String> ordenados = new TreeSet<>();  // Sempre ordenado
```

## ExercÃ­cios PrÃ¡ticos

1. Implemente um sistema de controle de sÃ³cios

2. Crie um gerenciador de eventos exclusivos

3. Desenvolva um verificador de duplicatas

## PrÃ³ximos Passos

Depois de dominar os Sets, vocÃª estarÃ¡ pronto para:

1. Gerenciar coleÃ§Ãµes sem duplicatas

2. Implementar sistemas de membros

3. Trabalhar com conjuntos matemÃ¡ticos

[Lists: A SequÃªncia](lists.html)
[Maps: Chave e Valor](maps.html)

Tip:

"Sets sÃ£o como clubes exclusivos - nÃ£o importa quantas vezes vocÃª tente entrar, sÃ³ passa uma vez!"



# Maps: O Guarda-Volumes da Matrix

```
MAP TYPES
â”œâ”€â”€ HashMap (ArmÃ¡rio Digital)
â”œâ”€â”€ LinkedHashMap (ArmÃ¡rio com HistÃ³rico)
â””â”€â”€ TreeMap (ArmÃ¡rio Ordenado)
```

## Fundamentos

Maps sÃ£o como um guarda-volumes high-tech - cada item tem sua chave Ãºnica, e vocÃª pode guardar qualquer coisa lÃ¡ dentro.

```JAVA
// Criando um guarda-volumes digital
Map<String, String> lockers = new HashMap<>();
lockers.put("A123", "Katana Digital");    // Guarda item
lockers.get("A123");                      // Recupera item
```

## Tipos de Maps (Diferentes Sistemas)

### HashMap (ArmÃ¡rio Quantum)

```JAVA
// RÃ¡pido e aleatÃ³rio, como teletransporte
HashMap<Integer, String> quantum = new HashMap<>();
quantum.put(42, "Dados Encriptados");  // Ordem? Irrelevante!
quantum.put(7, "CÃ³digo Fonte");        // Acesso instantÃ¢neo
```

### LinkedHashMap (Registro CronolÃ³gico)

```JAVA
// MantÃ©m ordem de inserÃ§Ã£o, como log de sistema
LinkedHashMap<String, String> logs = new LinkedHashMap<>();
logs.put("09:00", "Login");    // Primeiro registro
logs.put("09:01", "Download"); // Segundo registro
```

### TreeMap (Mainframe Ordenado)

```JAVA
// Sempre ordenado pela chave, como diretÃ³rio indexado
TreeMap<String, String> mainframe = new TreeMap<>();
mainframe.put("sys.exe", "Sistema");     // OrdenaÃ§Ã£o
mainframe.put("hack.exe", "Ferramentas"); // automÃ¡tica
```

## OperaÃ§Ãµes BÃ¡sicas (Protocolos de Acesso)

### InserÃ§Ã£o (Upload)

```JAVA
Map<String, Object> database = new HashMap<>();
database.put("user.dat", new User());          // Novo registro
database.putIfAbsent("backup.dat", new Data()); // SÃ³ se nÃ£o existir
```

### RecuperaÃ§Ã£o (Download)

```JAVA
// Diferentes formas de acessar
Object data = database.get("user.dat");        // Acesso direto
Object safe = database.getOrDefault("temp.dat", new Data()); // Com fallback
```

### RemoÃ§Ã£o (Delete)

```JAVA
// Limpando registros
database.remove("temp.dat");              // Remove entrada
database.remove("user.dat", oldUser);     // Remove se valor bater
```

## NavegaÃ§Ã£o (Scanning)

```JAVA
Map<String, String> matrix = new HashMap<>();

// Iterando chaves (Scanning IDs)
for (String key : matrix.keySet()) {
    System.out.println("ID: " + key);
}

// Iterando valores (Data Mining)
for (String value : matrix.values()) {
    System.out.println("Data: " + value);
}

// Iterando pares (Full Scan)
for (Map.Entry<String, String> entry : matrix.entrySet()) {
    System.out.println(entry.getKey() + " -> " + entry.getValue());
}
```

## OperaÃ§Ãµes AvanÃ§adas (Hacks)

```JAVA
// ComputaÃ§Ã£o condicional
matrix.compute("stats", (k, v) -> v == null ? "new" : v + "_updated");

// Merge de dados
matrix.merge("downloads", 1, (old, new) -> old + new);

// OperaÃ§Ãµes em massa
matrix.replaceAll((k, v) -> v.toUpperCase());
```

## Dicas de SeguranÃ§a

1. Escolha do Sistema

* HashMap: Para acesso rÃ¡pido e aleatÃ³rio

* LinkedHashMap: Quando ordem de inserÃ§Ã£o importa

* TreeMap: Para manter chaves ordenadas

2. Performance

```JAVA
// Inicialize com tamanho se souber
Map<String, String> system = new HashMap<>(100);

// Use o tipo certo para cada operaÃ§Ã£o
Map<String, Integer> sorted = new TreeMap<>();  // Para dados ordenados
```

## ExercÃ­cios PrÃ¡ticos

1. Implemente um sistema de cache

2. Crie um gerenciador de sessÃµes

3. Desenvolva um contador de frequÃªncia

## PrÃ³ximos Passos

Depois de dominar os Maps, vocÃª estarÃ¡ pronto para:

1. Criar sistemas de armazenamento chave-valor

2. Implementar caches eficientes

3. Gerenciar dados indexados

[Sets: Exclusividade](sets.html)
[Queues: Processamento](queues.html)

Tip:

"Maps sÃ£o como o guarda-volumes da Matrix - cada segredo tem sua chave, e sÃ³ vocÃª sabe onde procurar!"



# Queues: A Fila do Banco Digital

```
QUEUE TYPES
â”œâ”€â”€ Queue (Fila Normal)
â”œâ”€â”€ Deque (Fila Premium)
â””â”€â”€ PriorityQueue (Fila Preferencial)
```

## Fundamentos

Queues sÃ£o como filas de banco digitais - primeiro a chegar, primeiro a ser atendido (FIFO).

```JAVA
// Criando uma fila digital
Queue<String> fila = new LinkedList<>();
fila.offer("Cliente#1");    // Entra na fila
String proximo = fila.poll(); // PrÃ³ximo a ser atendido
```

## Tipos de Queues

### Queue BÃ¡sica

```JAVA
Queue<String> atendimento = new LinkedList<>();
atendimento.offer("UsuÃ¡rio");  // Adiciona ao fim
atendimento.poll();            // Remove do inÃ­cio
atendimento.peek();            // Consulta prÃ³ximo
```

### Deque (Double-Ended Queue)

```JAVA
Deque<String> premium = new ArrayDeque<>();
premium.offerFirst("VIP");     // Fura fila
premium.offerLast("Regular");  // Entra normal
premium.pollFirst();           // Remove do inÃ­cio
premium.pollLast();           // Remove do fim
```

### PriorityQueue

```JAVA
// Fila com prioridades
PriorityQueue<Integer> senha = new PriorityQueue<>();
senha.offer(3);  // Organiza automaticamente
senha.offer(1);  // por ordem natural
senha.offer(2);  // ou comparador customizado
```

## OperaÃ§Ãµes Comuns

### InserÃ§Ã£o

```JAVA
Queue<String> fila = new LinkedList<>();
fila.offer("Normal");      // Preferido (retorna boolean)
fila.add("ForÃ§a");        // LanÃ§a exceÃ§Ã£o se cheio
```

### RemoÃ§Ã£o

```JAVA
String cliente = fila.poll();     // Retorna null se vazio
String proximo = fila.remove();   // LanÃ§a exceÃ§Ã£o se vazio
```

### Consulta

```JAVA
String espiar = fila.peek();      // Retorna null se vazio
String primeiro = fila.element(); // LanÃ§a exceÃ§Ã£o se vazio
```

## Casos de Uso

1. Processamento de TransaÃ§Ãµes

```JAVA
Queue<Transaction> transactions = new LinkedList<>();
transactions.offer(new Transaction("DepÃ³sito"));
processTransaction(transactions.poll());
```

1. Sistema de Mensagens

```JAVA
PriorityQueue<Message> messages = new PriorityQueue<>();
messages.offer(new Message("Urgente", 1));
messages.offer(new Message("Normal", 2));
```

## Dicas de Performance

```JAVA
// Inicialize com tamanho se souber
Queue<String> fila = new LinkedList<>(100);

// Use o tipo certo para o caso
Deque<String> rapido = new ArrayDeque<>();  // Mais eficiente que LinkedList
```

## ExercÃ­cios PrÃ¡ticos

1. Implemente um sistema de atendimento

2. Crie um processador de eventos

3. Desenvolva um escalonador de tarefas

## PrÃ³ximos Passos

Depois de dominar Queues, vocÃª estarÃ¡ pronto para:

1. Gerenciar filas de processamento

2. Implementar sistemas de mensageria

3. Criar escalonadores de tarefas

[Maps: Chave-Valor](maps.html)
[Stacks: Pilha](stacks.html)

Tip:

"Queues sÃ£o como filas digitais: justas, ordenadas e sempre processando na ordem certa!"



# Stacks: A Pilha de Downloads

```
STACK OPERATIONS
â”œâ”€â”€ push() (Upload)
â”œâ”€â”€ pop()  (Download)
â””â”€â”€ peek() (Preview)
```

## Fundamentos

Stacks sÃ£o como uma pilha de downloads - o Ãºltimo arquivo baixado Ã© o primeiro que vocÃª acessa (LIFO).

```JAVA
// Criando uma pilha de downloads
Stack<String> downloads = new Stack<>();
downloads.push("arquivo.zip");    // Adiciona no topo
String ultimo = downloads.pop();  // Remove do topo
```

## OperaÃ§Ãµes BÃ¡sicas

### Push (Upload)

```JAVA
Stack<String> stack = new Stack<>();
stack.push("Camada 1");  // Base
stack.push("Camada 2");  // Meio
stack.push("Camada 3");  // Topo
```

### Pop (Download)

```JAVA
String top = stack.pop();     // Remove e retorna topo
String peek = stack.peek();   // SÃ³ espia o topo
boolean vazia = stack.empty(); // Checa se estÃ¡ vazia
```

### Busca

```JAVA
int posicao = stack.search("Camada 1"); // Busca na pilha
// Retorna posiÃ§Ã£o (1 = topo) ou -1 se nÃ£o encontrar
```

## Casos de Uso

### 1. HistÃ³rico de NavegaÃ§Ã£o

```JAVA
Stack<String> historico = new Stack<>();
historico.push("homepage.html");
historico.push("perfil.html");
String voltar = historico.pop(); // Volta pÃ¡gina
```

### 2. Desfazer/Refazer

```JAVA
Stack<Command> undoStack = new Stack<>();
undoStack.push(new Command("save"));
Command lastCommand = undoStack.pop(); // Desfaz
```

### 3. ValidaÃ§Ã£o de Sintaxe

```JAVA
Stack<Character> brackets = new Stack<>();
brackets.push('{');  // Abre
char close = brackets.pop(); // Fecha
// VÃ¡lido se stack vazia no final
```

## ImplementaÃ§Ã£o Alternativa

```JAVA
// Usando Deque como Stack (mais moderno)
Deque<String> stack = new ArrayDeque<>();
stack.push("Novo");
String top = stack.pop();
```

## Dicas de Performance

```JAVA
// Vector Ã© thread-safe mas mais lento
Stack<Integer> threadsafe = new Stack<>();

// ArrayDeque Ã© mais rÃ¡pido mas nÃ£o thread-safe
Deque<Integer> fast = new ArrayDeque<>();
```

## ExercÃ­cios PrÃ¡ticos

1. Implemente um verificador de parÃªnteses

2. Crie um sistema de desfazer/refazer

3. Desenvolva um navegador simplificado

## PrÃ³ximos Passos

Depois de dominar Stacks, vocÃª estarÃ¡ pronto para:

1. Implementar histÃ³ricos e navegaÃ§Ã£o

2. Criar sistemas de desfazer/refazer

3. Validar expressÃµes e sintaxe

[Queues: Filas](queues.html)
[Collections Projects](collections-projects.html)

Tip:

"Stacks sÃ£o como downloads: o Ãºltimo que chegou Ã© o primeiro que vocÃª acessa!"



# Projetos PrÃ¡ticos: Collections em AÃ§Ã£o

## Projeto 1: Task Manager (Lista de Contratos)

### Objetivo

Criar um sistema de gerenciamento de tarefas usando diferentes Collections.

```JAVA
public class TaskManager {
    private List<Task> allTasks = new ArrayList<>();
    private Map<String, Task> taskById = new HashMap<>();
    private PriorityQueue<Task> urgentTasks = new PriorityQueue<>();
    
    public void addTask(Task task) {
        allTasks.add(task);
        taskById.put(task.getId(), task);
        if (task.isUrgent()) {
            urgentTasks.offer(task);
        }
    }
    
    public Task getNextUrgentTask() {
        return urgentTasks.poll();
    }
}
```

### Funcionalidades

* Adicionar/remover tarefas

* PriorizaÃ§Ã£o automÃ¡tica

* Busca por ID/status

* HistÃ³rico de alteraÃ§Ãµes

## Projeto 2: Inventory System (Controle de Arsenal)

### Objetivo

Implementar um sistema de inventÃ¡rio com controle de estoque.

```JAVA
public class InventorySystem {
    private Map<String, Item> inventory = new HashMap<>();
    private Set<String> lowStock = new HashSet<>();
    private Queue<Order> pendingOrders = new LinkedList<>();
    
    public void addItem(Item item) {
        inventory.put(item.getCode(), item);
        checkStock(item);
    }
    
    private void checkStock(Item item) {
        if (item.getQuantity() < item.getMinimum()) {
            lowStock.add(item.getCode());
            createRestockOrder(item);
        }
    }
}
```

### Funcionalidades

* Controle de estoque

* Alertas de baixo estoque

* Processamento de pedidos

* RelatÃ³rios de inventÃ¡rio

## Projeto 3: Cache Implementation (MemÃ³ria TemporÃ¡ria)

### Objetivo

Desenvolver um sistema de cache com polÃ­tica de expiraÃ§Ã£o.

```JAVA
public class CacheSystem<K, V> {
    private Map<K, CacheEntry<V>> cache = new LinkedHashMap<>();
    private Queue<K> expirationQueue = new PriorityQueue<>();
    
    public void put(K key, V value, long ttl) {
        cache.put(key, new CacheEntry<>(value, ttl));
        expirationQueue.offer(key);
        cleanExpired();
    }
    
    public V get(K key) {
        CacheEntry<V> entry = cache.get(key);
        return (entry != null && !entry.isExpired()) ? entry.getValue() : null;
    }
}
```

### Funcionalidades

* Cache com TTL (Time To Live)

* PolÃ­tica LRU (Least Recently Used)

* Limpeza automÃ¡tica

* EstatÃ­sticas de hit/miss

## Desafios Extras

### 1. Sistema Multi-Thread

```JAVA
public class ThreadSafeTaskManager {
    private final ConcurrentHashMap<String, Task> tasks = new ConcurrentHashMap<>();
    private final BlockingQueue<Task> taskQueue = new LinkedBlockingQueue<>();
    
    public void processTask() {
        while (true) {
            Task task = taskQueue.take(); // Bloqueia atÃ© ter tarefa
            executeTask(task);
        }
    }
}
```

### 2. Sistema de Eventos

```JAVA
public class EventSystem {
    private final Deque<Event> eventHistory = new ArrayDeque<>();
    private final Map<String, List<EventHandler>> handlers = new HashMap<>();
    
    public void emit(Event event) {
        eventHistory.push(event);
        notifyHandlers(event);
    }
    
    public void undo() {
        if (!eventHistory.isEmpty()) {
            revertEvent(eventHistory.pop());
        }
    }
}
```

## PrÃ³ximos Passos

1. Implemente os projetos base

2. Adicione funcionalidades extras

3. Otimize o cÃ³digo

4. Adicione testes unitÃ¡rios

5. Documente seu cÃ³digo

[Stacks: Pilhas](stacks.html)
[OOP Fundamentals](oop-fundamentals.html)

Tip:

"A verdadeira maestria vem da prÃ¡tica. Cada projeto Ã© uma chance de aperfeiÃ§oar suas habilidades!"



# Task Manager: Gerenciador de Tarefas Digital

## Objetivo do Projeto

Criar um gerenciador de tarefas simples usando arrays e collections bÃ¡sicas.

## Estruturas de Dados Utilizadas

```JAVA
// Lista de tarefas usando array
String[] tarefas = new String[100];
int[] prioridades = new int[100];
boolean[] concluidas = new boolean[100];
int totalTarefas = 0;

// Lista dinÃ¢mica usando ArrayList
ArrayList<String> tarefasDinamicas = new ArrayList<>();

// Fila de tarefas urgentes
Queue<String> tarefasUrgentes = new LinkedList<>();

// Mapa para busca rÃ¡pida
HashMap<String, Integer> indiceTarefas = new HashMap<>();
```

## Funcionalidades Principais

### 1. Adicionar Tarefa

```JAVA
public static void adicionarTarefa(String tarefa, int prioridade) {
    if (totalTarefas < tarefas.length) {
        tarefas[totalTarefas] = tarefa;
        prioridades[totalTarefas] = prioridade;
        concluidas[totalTarefas] = false;
        
        // Adiciona nas estruturas dinÃ¢micas
        tarefasDinamicas.add(tarefa);
        indiceTarefas.put(tarefa, totalTarefas);
        
        if (prioridade > 8) {
            tarefasUrgentes.offer(tarefa);
        }
        
        totalTarefas++;
        System.out.println("Tarefa adicionada: " + tarefa);
    }
}
```

### 2. Listar Tarefas

```JAVA
public static void listarTarefas() {
    System.out.println("\n=== Lista de Tarefas ===");
    for (int i = 0; i < totalTarefas; i++) {
        String status = concluidas[i] ? "[X]" : "[ ]";
        System.out.printf("%s %s (Prioridade: %d)%n", 
            status, tarefas[i], prioridades[i]);
    }
}
```

### 3. Marcar Como ConcluÃ­da

```JAVA
public static void concluirTarefa(String tarefa) {
    Integer indice = indiceTarefas.get(tarefa);
    if (indice != null) {
        concluidas[indice] = true;
        System.out.println("Tarefa concluÃ­da: " + tarefa);
    }
}
```

### 4. Buscar Tarefas

```JAVA
public static void buscarTarefa(String termo) {
    System.out.println("\n=== Resultados da Busca ===");
    for (int i = 0; i < totalTarefas; i++) {
        if (tarefas[i].toLowerCase().contains(termo.toLowerCase())) {
            System.out.println("- " + tarefas[i]);
        }
    }
}
```

### 5. PrÃ³xima Tarefa Urgente

```JAVA
public static String proximaTarefaUrgente() {
    return tarefasUrgentes.poll();
}
```

## Exemplo de Uso

```JAVA
public static void main(String[] args) {
    // Adicionar algumas tarefas
    adicionarTarefa("Debugar cÃ³digo", 9);
    adicionarTarefa("Backup sistema", 7);
    adicionarTarefa("Atualizar firewall", 10);
    
    // Listar todas as tarefas
    listarTarefas();
    
    // Concluir uma tarefa
    concluirTarefa("Backup sistema");
    
    // Buscar tarefas
    buscarTarefa("firewall");
    
    // Verificar prÃ³xima tarefa urgente
    String urgente = proximaTarefaUrgente();
    System.out.println("PrÃ³xima urgente: " + urgente);
}
```

## Desafios para Praticar

1. Filtrar por Prioridade

```JAVA
public static void filtrarPorPrioridade(int minimo) {
    for (int i = 0; i < totalTarefas; i++) {
        if (prioridades[i] >= minimo) {
            System.out.println(tarefas[i]);
        }
    }
}
```

1. Remover Tarefa

```JAVA
public static void removerTarefa(String tarefa) {
    Integer indice = indiceTarefas.get(tarefa);
    if (indice != null) {
        // Shift elements
        for (int i = indice; i < totalTarefas - 1; i++) {
            tarefas[i] = tarefas[i + 1];
            prioridades[i] = prioridades[i + 1];
            concluidas[i] = concluidas[i + 1];
        }
        totalTarefas--;
        
        // Atualizar estruturas dinÃ¢micas
        tarefasDinamicas.remove(tarefa);
        indiceTarefas.remove(tarefa);
    }
}
```

## ExercÃ­cios Propostos

1. Implementar ordenaÃ§Ã£o por prioridade

2. Adicionar data limite para tarefas

3. Criar filtro por status (pendente/concluÃ­da)

4. Implementar sistema de tags usando arrays

5. Adicionar persistÃªncia em arquivo texto

## PrÃ³ximos Passos

* [Inventory System](inventory-system.html)

* [Cache Implementation](cache-implementation.html)

Tip:

"Uma tarefa bem organizada Ã© uma tarefa meio feita!"



# Sistema de InventÃ¡rio (Arsenal)

Um sistema de inventÃ¡rio cyberpunk para gerenciar equipamentos e recursos.

## Objetivos de Aprendizado

* Implementar um sistema usando `Map`, `Set` e `Queue`

* Gerenciar estoque com estruturas de dados apropriadas

* Aplicar lÃ³gica de negÃ³cios com coleÃ§Ãµes

## Conceitos Aplicados

* HashMap para armazenamento principal

* HashSet para itens em baixo estoque

* Queue para pedidos pendentes

* Encapsulamento de dados

* ValidaÃ§Ãµes de negÃ³cio

## ImplementaÃ§Ã£o Base

### Classe Item

```JAVA
public class Item {
    private String code;
    private String name;
    private int quantity;
    private int minimum;
    private double price;

    public Item(String code, String name, int quantity, int minimum, double price) {
        this.code = code;
        this.name = name;
        this.quantity = quantity;
        this.minimum = minimum;
        this.price = price;
    }

    // Getters e Setters
    public String getCode() { return code; }
    public String getName() { return name; }
    public int getQuantity() { return quantity; }
    public int getMinimum() { return minimum; }
    public double getPrice() { return price; }

    public void setQuantity(int quantity) { this.quantity = quantity; }
}
```

### Classe Order

```JAVA
public class Order {
    private String itemCode;
    private int quantity;
    private String status;

    public Order(String itemCode, int quantity) {
        this.itemCode = itemCode;
        this.quantity = quantity;
        this.status = "PENDING";
    }

    // Getters e Setters
    public String getItemCode() { return itemCode; }
    public int getQuantity() { return quantity; }
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
}
```

### Sistema Principal

```JAVA
public class InventorySystem {
    private Map<String, Item> inventory = new HashMap<>();
    private Set<String> lowStock = new HashSet<>();
    private Queue<Order> pendingOrders = new LinkedList<>();
    
    // Adicionar item ao inventÃ¡rio
    public void addItem(Item item) {
        inventory.put(item.getCode(), item);
        checkStock(item);
    }
    
    // Verificar nÃ­vel de estoque
    private void checkStock(Item item) {
        if (item.getQuantity() < item.getMinimum()) {
            lowStock.add(item.getCode());
            createRestockOrder(item);
        }
    }
    
    // Criar pedido de reposiÃ§Ã£o
    private void createRestockOrder(Item item) {
        int orderQuantity = item.getMinimum() - item.getQuantity();
        Order order = new Order(item.getCode(), orderQuantity);
        pendingOrders.offer(order);
    }
    
    // Remover item do inventÃ¡rio
    public void removeItem(String code) {
        inventory.remove(code);
        lowStock.remove(code);
    }
    
    // Atualizar quantidade
    public void updateQuantity(String code, int quantity) {
        Item item = inventory.get(code);
        if (item != null) {
            item.setQuantity(quantity);
            checkStock(item);
        }
    }
    
    // Listar itens em baixo estoque
    public Set<String> getLowStockItems() {
        return new HashSet<>(lowStock);
    }
    
    // Processar prÃ³ximo pedido
    public Order processNextOrder() {
        return pendingOrders.poll();
    }
}
```

## Exemplo de Uso

```JAVA
public class InventoryDemo {
    public static void main(String[] args) {
        InventorySystem system = new InventorySystem();
        
        // Adicionar itens
        system.addItem(new Item("HACK001", "NetHack Module", 5, 10, 299.99));
        system.addItem(new Item("DECK002", "CyberDeck", 2, 5, 999.99));
        
        // Verificar baixo estoque
        Set<String> lowStock = system.getLowStockItems();
        System.out.println("Itens em baixo estoque: " + lowStock);
        
        // Processar pedidos
        Order nextOrder = system.processNextOrder();
        if (nextOrder != null) {
            System.out.println("Processando pedido: " + nextOrder.getItemCode());
        }
    }
}
```

## ExercÃ­cios Propostos

1. Implementar RelatÃ³rios

* Gerar relatÃ³rio de valor total do inventÃ¡rio

* Listar itens por faixa de preÃ§o

* Calcular estatÃ­sticas de pedidos

2. Adicionar ValidaÃ§Ãµes

* Verificar cÃ³digos duplicados

* Validar quantidades negativas

* Implementar limites de estoque

3. Expandir Funcionalidades

* Adicionar categorias de itens

* Implementar sistema de alertas

* Criar histÃ³rico de transaÃ§Ãµes

## Desafios AvanÃ§ados

1. Sistema de Prioridade

* Implementar PriorityQueue para pedidos

* Definir critÃ©rios de priorizaÃ§Ã£o

* Gerenciar pedidos urgentes

2. PersistÃªncia de Dados

* Salvar estado do inventÃ¡rio

* Carregar dados de arquivo

* Implementar backup automÃ¡tico

## Dicas de ImplementaÃ§Ã£o

* Use enums para status e categorias

* Implemente tratamento de exceÃ§Ãµes

* Mantenha o cÃ³digo modular

* Documente as funcionalidades

* Adicione logs de operaÃ§Ãµes

## PrÃ³ximos Passos

* [Cache Implementation](cache-implementation.html)

* [Collections Overview](collections-overview.html)

* [Maps](maps.html)

Tip:

"Um bom arsenal nÃ£o Ã© apenas sobre quantidade, mas sobre organizaÃ§Ã£o e controle."



# ImplementaÃ§Ã£o de Cache

![Cache System](cache-system-banner.png)

Um sistema de cache Ã© uma estrutura de dados que armazena temporariamente dados frequentemente acessados para melhorar a performance. Neste projeto, implementaremos um cache simples usando arrays e conceitos bÃ¡sicos de Java.

## Arquitetura do Sistema

```MERMAID
graph TD
    A[Cliente] --> B[Cache]
    B --> C[Armazenamento]
    B --> D[EstatÃ­sticas]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
```

## Componentes Principais

### Estrutura de Dados

* Arrays paralelos para chaves e valores

* Array para timestamps

* Array para contagem de acessos

* Controle de capacidade e tamanho atual

### OperaÃ§Ãµes BÃ¡sicas

* InserÃ§Ã£o/atualizaÃ§Ã£o de itens

* Busca por chave

* SubstituiÃ§Ã£o de itens menos usados

* Monitoramento de estatÃ­sticas

## ImplementaÃ§Ã£o Base

### SimpleCache.java

```JAVA
public class SimpleCache {
    private String[] keys;
    private String[] values;
    private long[] timestamps;
    private int[] accessCount;
    private int capacity;
    private int size;
    
    public SimpleCache(int maxSize) {
        capacity = maxSize;
        keys = new String[capacity];
        values = new String[capacity];
        timestamps = new long[capacity];
        accessCount = new int[capacity];
        size = 0;
    }
    
    // MÃ©todos principais aqui...
}
```

### PolÃ­tica de SubstituiÃ§Ã£o

O cache utiliza a estratÃ©gia LFU (Least Frequently Used):

1. MantÃ©m contagem de acessos para cada item

2. Quando o cache estÃ¡ cheio, remove o item menos acessado

3. Em caso de empate, mantÃ©m o item mais antigo

## Interface de UsuÃ¡rio

### Menu Principal

```JAVA
System.out.println("\n=== Sistema de Cache ===");
System.out.println("1. Adicionar/Atualizar item");
System.out.println("2. Buscar item");
System.out.println("3. Mostrar estatÃ­sticas");
System.out.println("4. Sair");
```

### VisualizaÃ§Ã£o de EstatÃ­sticas

```
=== Cache Stats ===
Capacity: 5
Current Size: 3

Cache Contents:
Key | Value | Access Count | Age (ms)
------------------------------------
key1 | value1 | 3 | 1500
key2 | value2 | 1 | 1000
key3 | value3 | 2 | 500
```

## Desafios de ExtensÃ£o

1. Implementar Cache GenÃ©rico

```JAVA
public class GenericCache<K, V> {
    private K[] keys;
    private V[] values;
    // ...
}
```

1. Adicionar ExpiraÃ§Ã£o de Items

```JAVA
public boolean isExpired(String key) {
    int index = findKey(key);
    if (index != -1) {
        long age = System.currentTimeMillis() - timestamps[index];
        return age > expirationTime;
    }
    return true;
}
```

1. Implementar Diferentes PolÃ­ticas

* LRU (Least Recently Used)

* FIFO (First In First Out)

* Random Replacement

## PrÃ³ximos Passos

1. Adicione suporte a tipos genÃ©ricos

2. Implemente expiraÃ§Ã£o de itens

3. Crie diferentes polÃ­ticas de substituiÃ§Ã£o

4. Adicione persistÃªncia em arquivo

5. Implemente cache distribuÃ­do

## Conceitos Aplicados

* Arrays e manipulaÃ§Ã£o

* Tipos primitivos

* Strings

* Estruturas de controle

* MÃ©todos e classes

* Entrada/saÃ­da bÃ¡sica

## Dicas de ImplementaÃ§Ã£o

1. Mantenha o cÃ³digo organizado e bem documentado

2. Use constantes para valores fixos

3. Implemente validaÃ§Ãµes de entrada

4. Adicione logs para depuraÃ§Ã£o

5. Considere casos de erro

## ExercÃ­cios Propostos

1. Implemente um cache com limite de tempo

2. Crie um cache que persiste em arquivo

3. Adicione suporte a mÃºltiplos tipos de dados

4. Implemente estatÃ­sticas avanÃ§adas

5. Crie testes unitÃ¡rios

[Inventory System](inventory-system.html)



# Fundamentos da ProgramaÃ§Ã£o Orientada a Objetos

## O que Ã© OOP?

A ProgramaÃ§Ã£o Orientada a Objetos (OOP) Ã© um paradigma de programaÃ§Ã£o que organiza o cÃ³digo em objetos, que contÃªm dados e cÃ³digo. Os objetos sÃ£o instÃ¢ncias de classes, que servem como blueprints para criar objetos.

## Pilares da OOP

```MERMAID
graph TD
    A[OOP] --> B[Encapsulamento]
    A --> C[HeranÃ§a]
    A --> D[Polimorfismo]
    A --> E[AbstraÃ§Ã£o]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#00ff00
```

### Encapsulamento

* Oculta detalhes internos

* Protege dados sensÃ­veis

* Reduz complexidade

### HeranÃ§a

* Reutiliza cÃ³digo

* Estabelece hierarquias

* Especializa comportamentos

### Polimorfismo

* Flexibiliza interfaces

* Adapta comportamentos

* Simplifica cÃ³digo

### AbstraÃ§Ã£o

* Modela conceitos

* Simplifica problemas

* Define interfaces

## Conceitos Fundamentais

### Classes e Objetos

```JAVA
public class Netrunner {
    private String codename;
    private int skillLevel;

    public Netrunner(String codename) {
        this.codename = codename;
        this.skillLevel = 1;
    }
}
```

### Atributos e MÃ©todos

```JAVA
public class CyberDeck {
    // Atributos
    private int power;
    private String model;

    // MÃ©todos
    public void upgrade() {
        this.power++;
    }
}
```

## BenefÃ­cios da OOP

1. Manutenibilidade

* CÃ³digo organizado

* FÃ¡cil de atualizar

* Modular

2. Reusabilidade

* Componentes reutilizÃ¡veis

* Menos duplicaÃ§Ã£o

* Economia de tempo

3. Flexibilidade

* FÃ¡cil de estender

* AdaptÃ¡vel

* EscalÃ¡vel

4. SeguranÃ§a

* Controle de acesso

* Dados protegidos

* CÃ³digo seguro

## PrÃ¡ticas Recomendadas

### Nomenclatura

* Classes: PascalCase

* MÃ©todos: camelCase

* VariÃ¡veis: camelCase

* Constantes: UPPER_CASE

### OrganizaÃ§Ã£o

* Uma classe por arquivo

* Pacotes lÃ³gicos

* Hierarquia clara

### PrincÃ­pios

* Single Responsibility

* Open/Closed

* Liskov Substitution

* Interface Segregation

* Dependency Inversion

## PrÃ³ximos Passos

1. Classes e Objetos

2. Encapsulamento

3. HeranÃ§a

4. Polimorfismo

5. Interfaces e Classes Abstratas

6. Records

7. Sealed Classes

8. Projetos PrÃ¡ticos

## Conceitos Relacionados

* Design Patterns

* SOLID Principles

* Clean Code

* Refactoring

* Testing

[Classes e Objetos](classes-objects.html)

Tip:

"Na Matrix da programaÃ§Ã£o, objetos sÃ£o as unidades fundamentais de poder. Domine-os, e vocÃª dominarÃ¡ o cÃ³digo."



# Classes e Objetos

## Conceito Base

Uma classe Ã© um template para criar objetos, definindo seus atributos e comportamentos. Um objeto Ã© uma instÃ¢ncia de uma classe.

```MERMAID
graph TD
    A[Classe] -->|instancia| B[Objeto]
    B -->|contÃ©m| C[Atributos]
    B -->|contÃ©m| D[MÃ©todos]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
```

## Estrutura de uma Classe

```JAVA
public class CyberHacker {
    // Atributos
    private String handle;
    private int level;
    private double credits;

    // Construtor
    public CyberHacker(String handle) {
        this.handle = handle;
        this.level = 1;
        this.credits = 1000.0;
    }

    // MÃ©todos
    public void hackSystem() {
        this.level++;
        this.credits += 500;
    }
}
```

## Criando Objetos

```JAVA
// Instanciando objetos
CyberHacker hacker1 = new CyberHacker("Shadowbyte");
CyberHacker hacker2 = new CyberHacker("NetPhantom");

// Usando objetos
hacker1.hackSystem();
```

## Componentes Principais

### Atributos

* Representam estado

* Definem caracterÃ­sticas

* Armazenam dados

### MÃ©todos

* Definem comportamento

* Manipulam atributos

* Executam operaÃ§Ãµes

### Construtores

* Inicializam objetos

* Configuram estado inicial

* Validam parÃ¢metros

## Boas PrÃ¡ticas

1. NomeaÃ§Ã£o

* Classes: PascalCase

* MÃ©todos/Atributos: camelCase

2. OrganizaÃ§Ã£o

* Um arquivo por classe

* Agrupamento lÃ³gico

* Pacotes estruturados

3. Responsabilidade

* PropÃ³sito Ãºnico

* CoesÃ£o alta

* Acoplamento baixo

## ExercÃ­cios PrÃ¡ticos

```JAVA
public class DataMatrix {
    private String[] data;
    private int securityLevel;

    // Implemente os mÃ©todos:
    // 1. Construtor
    // 2. encrypt()
    // 3. decrypt()
    // 4. updateSecurity()
}
```

## PrÃ³ximos Passos

[Encapsulamento](encapsulation.html)

Tip:

"No grid digital, cada objeto Ã© um nÃ³ de poder. Construa-os com sabedoria."



# Encapsulamento

## Conceito Base

Encapsulamento Ã© o princÃ­pio de ocultar detalhes internos e fornecer uma interface controlada para interaÃ§Ã£o.

```MERMAID
graph TD
    A[Classe] -->|protege| B[Dados Privados]
    A -->|expÃµe| C[Interface PÃºblica]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
```

## ImplementaÃ§Ã£o

```JAVA
public class SecureDataVault {
    // Dados privados
    private String[] encryptedData;
    private int accessLevel;
    private boolean isLocked;

    // Interface pÃºblica
    public void storeData(String data) {
        if (!isLocked) {
            // LÃ³gica de armazenamento
        }
    }

    public String retrieveData(int index) {
        if (validateAccess()) {
            return encryptedData[index];
        }
        return null;
    }

    private boolean validateAccess() {
        // LÃ³gica de validaÃ§Ã£o
        return accessLevel > 2;
    }
}
```

## Modificadores de Acesso

1. private

* Acesso apenas na classe

* MÃ¡xima proteÃ§Ã£o

* Dados sensÃ­veis

2. protected

* Acesso na hierarquia

* Classes derivadas

* Pacote atual

3. public

* Acesso universal

* Interface externa

* API pÃºblica

## Getters e Setters

```JAVA
public class CyberAccount {
    private double credits;
    private String owner;

    // Getter
    public double getCredits() {
        return credits;
    }

    // Setter com validaÃ§Ã£o
    public void setCredits(double amount) {
        if (amount >= 0) {
            this.credits = amount;
        }
    }
}
```

## BenefÃ­cios

1. SeguranÃ§a

* Controle de acesso

* ValidaÃ§Ã£o de dados

* ProteÃ§Ã£o de estado

2. ManutenÃ§Ã£o

* MudanÃ§as internas

* EvoluÃ§Ã£o segura

* Debugging simples

3. Flexibilidade

* Interface estÃ¡vel

* ImplementaÃ§Ã£o variÃ¡vel

* Versionamento

## ExercÃ­cios PrÃ¡ticos

```JAVA
public class SecuritySystem {
    // Implemente:
    // 1. Dados privados
    // 2. Getters/Setters
    // 3. ValidaÃ§Ãµes
    // 4. MÃ©todos de acesso
}
```

## PrÃ³ximos Passos

[HeranÃ§a](inheritance.html)

Tip:

"Na matrix, a informaÃ§Ã£o Ã© poder. Proteja-a com encapsulamento."



# HeranÃ§a

## Conceito Base

HeranÃ§a permite que uma classe herde atributos e mÃ©todos de outra, estabelecendo uma relaÃ§Ã£o "Ã© um" entre classes.

```MERMAID
graph TD
    A[Netrunner] -->|herda de| B[Hacker]
    B -->|herda de| C[CyberOperator]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
```

## ImplementaÃ§Ã£o BÃ¡sica

```JAVA
public class CyberOperator {
    protected String codename;
    protected int accessLevel;

    public CyberOperator(String codename) {
        this.codename = codename;
        this.accessLevel = 1;
    }

    public void accessNetwork() {
        System.out.println("Basic network access");
    }
}

public class Hacker extends CyberOperator {
    private int hackingSkill;

    public Hacker(String codename) {
        super(codename);
        this.hackingSkill = 50;
    }

    @Override
    public void accessNetwork() {
        System.out.println("Advanced network access");
    }
}
```

## Tipos de HeranÃ§a

### HeranÃ§a Simples

```JAVA
public class Netrunner extends Hacker {
    private String[] cyberdeckModules;
    
    public Netrunner(String codename) {
        super(codename);
        this.cyberdeckModules = new String[]{"Basic"};
    }
}
```

### Hierarquia de Classes

* Superclasse (pai)

* Subclasse (filho)

* Cadeia de heranÃ§a

## Palavra-chave super

```JAVA
public class ICEBreaker extends Netrunner {
    public ICEBreaker(String codename) {
        super(codename);  // Chama construtor pai
    }

    @Override
    public void accessNetwork() {
        super.accessNetwork();  // Chama mÃ©todo pai
        System.out.println("Breaking ICE protocols");
    }
}
```

## Boas PrÃ¡ticas

1. ComposiÃ§Ã£o vs HeranÃ§a

* Prefira composiÃ§Ã£o

* Evite hierarquias profundas

* Mantenha coesÃ£o

2. PrincÃ­pio LSP

* SubstituiÃ§Ã£o de Liskov

* Comportamento consistente

* Contratos respeitados

3. DocumentaÃ§Ã£o

* Documente extensÃµes

* Explique sobreposiÃ§Ãµes

* Defina contratos

## ExercÃ­cios PrÃ¡ticos

```JAVA
// Implemente:
public class SecuritySystem {
    // Base para sistema de seguranÃ§a
}

public class FirewallSystem extends SecuritySystem {
    // Sistema especÃ­fico de firewall
}

public class IntrusionDetection extends SecuritySystem {
    // Sistema de detecÃ§Ã£o
}
```

## PrÃ³ximos Passos

[Polimorfismo](polymorphism.html)

Tip:

"Na hierarquia do cÃ³digo, cada classe herda o poder de seus ancestrais."



# Polimorfismo

## Conceito Base

Polimorfismo permite que objetos de diferentes classes sejam tratados como objetos de uma classe comum, possibilitando comportamentos diferentes atravÃ©s da mesma interface.

```MERMAID
graph TD
    A[CyberProgram] -->|executa como| B[Virus]
    A -->|executa como| C[Firewall]
    A -->|executa como| D[DataMiner]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
```

## Tipos de Polimorfismo

### Sobrescrita (Override)

```JAVA
public class CyberProgram {
    public void execute() {
        System.out.println("Running base program");
    }
}

public class Virus extends CyberProgram {
    @Override
    public void execute() {
        System.out.println("Infiltrating system");
    }
}
```

### Sobrecarga (Overload)

```JAVA
public class DataMiner {
    public void mine(String data) {
        // Processa string
    }

    public void mine(byte[] data) {
        // Processa bytes
    }

    public void mine(String data, int depth) {
        // Processa com profundidade
    }
}
```

## Polimorfismo em AÃ§Ã£o

```JAVA
public class SystemInterface {
    public void executeProgram(CyberProgram program) {
        program.execute();  // Polimorfismo em tempo de execuÃ§Ã£o
    }

    public static void main(String[] args) {
        SystemInterface system = new SystemInterface();
        
        CyberProgram virus = new Virus();
        CyberProgram firewall = new Firewall();
        
        system.executeProgram(virus);    // Executa como Virus
        system.executeProgram(firewall); // Executa como Firewall
    }
}
```

## BenefÃ­cios

1. Flexibilidade

* CÃ³digo genÃ©rico

* Extensibilidade

* Manutenibilidade

2. ReutilizaÃ§Ã£o

* Interfaces comuns

* Comportamento variÃ¡vel

* CÃ³digo limpo

3. AbstraÃ§Ã£o

* SimplificaÃ§Ã£o

* Encapsulamento

* Modularidade

## PadrÃµes Comuns

### Factory Method

```JAVA
public interface CyberTool {
    void activate();
}

public class ToolFactory {
    public CyberTool createTool(String type) {
        return switch (type) {
            case "hack" -> new HackTool();
            case "scan" -> new ScanTool();
            default -> throw new IllegalArgumentException();
        };
    }
}
```

### Strategy Pattern

```JAVA
public interface AttackStrategy {
    void execute();
}

public class CyberAttack {
    private AttackStrategy strategy;
    
    public void setStrategy(AttackStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void execute() {
        strategy.execute();
    }
}
```

## ExercÃ­cios PrÃ¡ticos

```JAVA
// Implemente diferentes tipos de programas:
public interface Program {
    void run();
    void stop();
    String getStatus();
}

// Crie implementaÃ§Ãµes para:
// 1. DataAnalyzer
// 2. NetworkScanner
// 3. SecurityMonitor
```

## PrÃ³ximos Passos

[Interfaces e Classes Abstratas](null)

Tip:

"No ciberespaÃ§o, um programa pode assumir muitas formas. O poder estÃ¡ na adaptaÃ§Ã£o."




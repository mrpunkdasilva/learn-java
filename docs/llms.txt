# NetRunner: Java Mastery Guide

## Inicializando Sistema...

```
 _   _      _   ____                            
| \ | | ___| |_|  _ \ _   _ _ __  _ __   ___ _ __ 
|  \| |/ _ \ __| |_) | | | | '_ \| '_ \ / _ \ '__|
| |\  |  __/ |_|  _ <| |_| | | | | | | |  __/ |   
|_| \_|\___|\__|_| \_\\__,_|_| |_|_| |_|\___|_|   
                                                  
>> Java Mastery Guide v1.0
>> Inicializando interface neural...
>> Estabelecendo conexÃ£o com a Matrix...
>> Sistema pronto para upload de conhecimento...
```

## Sobre este Guia

Bem-vindo, runner. VocÃª acaba de acessar a interface neural mais avanÃ§ada para dominar a linguagem Java. Este nÃ£o Ã© apenas mais um tutorial - Ã© sua porta de entrada para o submundo do desenvolvimento de software.

### O que vocÃª vai encontrar aqui

* ðŸ”§ Fundamentos SÃ³lidos: Do bÃ¡sico ao avanÃ§ado, construa uma base inquebrÃ¡vel

* ðŸŒ Projetos PrÃ¡ticos: Aplique seus conhecimentos em missÃµes do mundo real

* ðŸš€ Tecnologias Modernas: Frameworks, cloud, seguranÃ§a e muito mais

* ðŸ’¡ PadrÃµes e Boas PrÃ¡ticas: Aprenda a construir cÃ³digo resiliente e escalÃ¡vel

## PrÃ©-requisitos

* Computador com acesso Ã  internet

* Vontade de aprender e experimentar

* DisposiÃ§Ã£o para desafios prÃ¡ticos

* Mente aberta para novos conceitos

## Como Usar este Guia

1. Siga a SequÃªncia: Os mÃ³dulos foram organizados em ordem progressiva de complexidade

2. Pratique: Complete as missÃµes prÃ¡ticas em cada seÃ§Ã£o

3. Experimente: Modifique os exemplos e crie suas prÃ³prias variaÃ§Ãµes

4. Conecte-se: Participe da comunidade e compartilhe seu progresso

## Roadmap de Aprendizado

```MERMAID
graph TD
    A[InicializaÃ§Ã£o] --> B[Protocolos BÃ¡sicos]
    B --> C[Matriz de Controle]
    C --> D[Interface Neural/OOP]
    D --> E[Sistemas AvanÃ§ados]
    E --> F[EspecializaÃ§Ã£o]
```

## Quick Start

```JAVA
public class NetRunner {
    public static void main(String[] args) {
        System.out.println("Iniciando jornada no NetRunner...");
        System.out.println("Preparando ambiente de desenvolvimento...");
        System.out.println("Sistema pronto para comeÃ§ar!");
    }
}
```

## PrÃ³ximos Passos

1. Comece pela seÃ§Ã£o [Sobre o Projeto](about.html)

2. Configure seu [Ambiente de Desenvolvimento](development-environment.html)

3. Inicie sua jornada com [Java BÃ¡sico](java-basics.html)

## Status do Projeto

* VersÃ£o: 1.0

* Status: Ativo

* Java: 17+

Tip:

"O cÃ³digo Ã© apenas o comeÃ§o. O verdadeiro poder estÃ¡ em como vocÃª o utiliza." - NetRunner's Manifesto

[ComeÃ§ar Agora](getting-started.html)



# Iniciando no NetRunner

```
>> Inicializando sequÃªncia de boot...
>> Carregando mÃ³dulos bÃ¡sicos...
>> Preparando ambiente de desenvolvimento...
>> Sistema pronto para upload inicial...
```

## PrÃ©-requisitos do Sistema

### Hardware Recomendado

* Processador: Dual Core ou superior

* MemÃ³ria RAM: 8GB mÃ­nimo (16GB recomendado)

* Armazenamento: 10GB de espaÃ§o livre

* ConexÃ£o com Internet estÃ¡vel

### Software Base

* Sistema Operacional: Windows 10/11, macOS, Linux

* Java Development Kit (JDK) 17 ou superior

* IDE compatÃ­vel (recomendamos IntelliJ IDEA)

* Git para controle de versÃ£o

## Checklist de InicializaÃ§Ã£o

```
CHECKLIST
â”œâ”€â”€ [1] ConfiguraÃ§Ã£o do Ambiente
â”œâ”€â”€ [2] InstalaÃ§Ã£o das Ferramentas
â”œâ”€â”€ [3] VerificaÃ§Ã£o do Sistema
â””â”€â”€ [4] Teste de ConexÃ£o
```

## SequÃªncia de Boot

### 1. PreparaÃ§Ã£o Inicial

Antes de mergulhar no cÃ³digo, certifique-se de:

* Ler o [Sobre o Projeto](about.html)

* Verificar os [PrÃ©-requisitos](prerequisites.html)

* Entender o [Caminho de Aprendizado](learning-path.html)

### 2. Setup do Ambiente

Configure seu ambiente de desenvolvimento:

* [ConfiguraÃ§Ã£o do Sistema Operacional](os-setup.html)

* [VisÃ£o Geral das Ferramentas](tools-overview.html)

### 3. Primeiros Passos

```JAVA
public class FirstConnection {
    public static void main(String[] args) {
        System.out.println("ConexÃ£o estabelecida com NetRunner...");
        System.out.println("Iniciando upload de conhecimento...");
        System.out.println("Bem-vindo Ã  Matrix, runner!");
    }
}
```

## Roadmap Inicial

```MERMAID
graph TD
    A[InÃ­cio] --> B[Setup Ambiente]
    B --> C[Fundamentos Java]
    C --> D[Primeiros Projetos]
    D --> E[EvoluÃ§Ã£o ContÃ­nua]
```

## NavegaÃ§Ã£o do Sistema

### Estrutura do Curso

* MÃ³dulos progressivos

* Projetos prÃ¡ticos em cada seÃ§Ã£o

* ExercÃ­cios de fixaÃ§Ã£o

* Desafios de cÃ³digo

### Como Progredir

1. Complete cada mÃ³dulo sequencialmente

2. Execute todos os exemplos de cÃ³digo

3. FaÃ§a os exercÃ­cios propostos

4. Construa os projetos sugeridos

## Suporte e Recursos

### Canais de Ajuda

* DocumentaÃ§Ã£o oficial

* FÃ³rum da comunidade

* RepositÃ³rio de exemplos

* Canal de dÃºvidas

## PrÃ³ximos Passos

Escolha seu caminho:

1. [Configurar Ambiente de Desenvolvimento](development-environment.html)

2. [Instalar JDK](jdk-installation.html)

3. [Configurar IDE](ide-setup.html)

## Dicas de SobrevivÃªncia

Tip:

"Na Matrix do cÃ³digo, a prÃ¡tica constante Ã© sua melhor arma."

* Mantenha um ritmo consistente de estudos

* Pratique diariamente

* NÃ£o pule etapas fundamentais

* Construa seu prÃ³prio cÃ³digo

* Participe da comunidade

## Checkpoint

Antes de prosseguir, certifique-se de:

* [ ] Ter lido a introduÃ§Ã£o completa

* [ ] Entender a estrutura do curso

* [ ] Verificar os requisitos do sistema

* [ ] Estar pronto para comeÃ§ar a configuraÃ§Ã£o

[ComeÃ§ar ConfiguraÃ§Ã£o do Ambiente](development-environment.html)

Tip:

"Todo runner comeÃ§a com um primeiro comando. FaÃ§a o seu contar."



# Sobre o Projeto NetRunner

```
>> Inicializando mÃ³dulo de apresentaÃ§Ã£o...
>> Carregando manifesto do projeto...
>> Estabelecendo parÃ¢metros base...
```

## Manifesto NetRunner

No cenÃ¡rio atual do desenvolvimento de software, dominar Java nÃ£o Ã© apenas uma habilidade - Ã© uma necessidade. O NetRunner foi concebido como uma interface neural direta para seu aprendizado, mesclando conceitos tÃ©cnicos sÃ³lidos com uma experiÃªncia imersiva Ãºnica.

## Arquitetura do Conhecimento

### Core Components

1. Fundamentos SÃ³lidos

* Sintaxe e estruturas bÃ¡sicas

* Paradigmas de programaÃ§Ã£o

* GestÃ£o de memÃ³ria e recursos

* Debugging e resoluÃ§Ã£o de problemas

2. Desenvolvimento PrÃ¡tico

* Projetos hands-on

* Casos de uso reais

* ImplementaÃ§Ãµes guiadas

* Desafios progressivos

3. EvoluÃ§Ã£o TÃ©cnica

* PadrÃµes de projeto

* Boas prÃ¡ticas

* OtimizaÃ§Ã£o de cÃ³digo

* SeguranÃ§a e performance

## Metodologia de Ensino

### Abordagem Neural

```
INPUT â†’ PROCESSAMENTO â†’ OUTPUT
   â†‘          â†‘            â†‘
Teoria    PrÃ¡tica     Resultado
```

* Teoria Focada: Apenas o essencial, sem fluff

* PrÃ¡tica Intensiva: Aprenda fazendo

* Feedback Loop: Teste, erre, aprenda, repita

### Ciclo de Aprendizado

```MERMAID
graph LR
    A[Conceito] --> B[Exemplo]
    B --> C[PrÃ¡tica]
    C --> D[Desafio]
    D --> E[Review]
    E --> A
```

## Objetivos do Projeto

### Metas Principais

1. CapacitaÃ§Ã£o TÃ©cnica

* DomÃ­nio completo da sintaxe Java

* CompreensÃ£o profunda de OOP

* Habilidades de debugging avanÃ§adas

* PrÃ¡ticas de cÃ³digo limpo

2. Desenvolvimento Profissional

* PreparaÃ§Ã£o para mercado

* Portfolio builder

* ResoluÃ§Ã£o de problemas reais

* Mindset de desenvolvedor

3. EvoluÃ§Ã£o ContÃ­nua

* Updates regulares

* Novos desafios

* ExpansÃ£o de conteÃºdo

* IntegraÃ§Ã£o com tecnologias emergentes

## Stack TecnolÃ³gico

### Core Technologies

```
JAVA STACK
â”œâ”€â”€ Core Java 17+
â”œâ”€â”€ Build Tools
â”‚   â”œâ”€â”€ Maven
â”‚   â””â”€â”€ Gradle
â”œâ”€â”€ Testing
â”‚   â”œâ”€â”€ JUnit
â”‚   â””â”€â”€ Mockito
â””â”€â”€ Frameworks
    â”œâ”€â”€ Spring
    â””â”€â”€ Hibernate
```

## Compromisso com Qualidade

### PadrÃµes de ExcelÃªncia

* CÃ³digo Documentado: Exemplos claros e bem comentados

* Melhores PrÃ¡ticas: Seguindo padrÃµes da indÃºstria

* AtualizaÃ§Ãµes Regulares: ConteÃºdo sempre atual

* Suporte Ativo: Comunidade engajada

## PrÃ³ximos Passos

Agora que vocÃª compreende a essÃªncia do NetRunner, Ã© hora de configurar seu ambiente de desenvolvimento e comeÃ§ar sua jornada.

[Configurar Ambiente de Desenvolvimento](development-environment.html)

Tip:

"A matrix tem seus padrÃµes. Uma vez que vocÃª os entende, o cÃ³digo se torna sua segunda natureza."



# PrÃ©-requisitos do NetRunner

```
>> Escaneando requisitos do sistema...
>> Verificando compatibilidade...
>> Analisando perfil do usuÃ¡rio...
>> RelatÃ³rio de requisitos gerado...
```

## Requisitos TÃ©cnicos

### Hardware MÃ­nimo

| Componente |Requisito MÃ­nimo |Recomendado |
---------------------------------------------
| Processador |Dual Core 2GHz |Quad Core 3GHz+ |
| MemÃ³ria RAM |8GB |16GB+ |
| Armazenamento |10GB livre |20GB+ livre |
| Internet |5Mbps |15Mbps+ |

### Software Base

```
REQUISITOS DE SOFTWARE
â”œâ”€â”€ Sistema Operacional
â”‚   â”œâ”€â”€ Windows 10/11
â”‚   â”œâ”€â”€ macOS Catalina+
â”‚   â””â”€â”€ Linux (kernel 5.0+)
â”œâ”€â”€ Navegador Moderno
â”‚   â”œâ”€â”€ Chrome 90+
â”‚   â”œâ”€â”€ Firefox 88+
â”‚   â””â”€â”€ Edge 90+
â””â”€â”€ Ferramentas Base
    â”œâ”€â”€ Git 2.30+
    â””â”€â”€ Terminal
```

## Conhecimentos PrÃ©vios

### Fundamentais

* LÃ³gica de programaÃ§Ã£o bÃ¡sica

* Conceitos de algoritmos

* Familiaridade com terminal/linha de comando

* NoÃ§Ãµes de versionamento

### Recomendados

* ExperiÃªncia com qualquer linguagem de programaÃ§Ã£o

* Conhecimento bÃ¡sico de redes

* InglÃªs tÃ©cnico para leitura

## VerificaÃ§Ã£o de Requisitos

### Checklist TÃ©cnico

* [ ] Hardware compatÃ­vel

* [ ] SO atualizado

* [ ] EspaÃ§o em disco suficiente

* [ ] ConexÃ£o estÃ¡vel com internet

### Checklist de Conhecimento

* [ ] Entendimento de lÃ³gica de programaÃ§Ã£o

* [ ] Familiaridade com terminal

* [ ] NoÃ§Ãµes de Git

* [ ] Capacidade de leitura tÃ©cnica

## Auto-AvaliaÃ§Ã£o

Execute este diagnÃ³stico bÃ¡sico:

```JAVA
public class SkillCheck {
    public static void main(String[] args) {
        // Se vocÃª entende este cÃ³digo bÃ¡sico
        // vocÃª estÃ¡ no caminho certo
        for (int i = 1; i <= 5; i++) {
            System.out.println("Teste de lÃ³gica #" + i);
        }
    }
}
```

## PreparaÃ§Ã£o Inicial

### 1. VerificaÃ§Ã£o de Sistema

```BASH
# Execute estes comandos no terminal
java -version
git --version
```

### 2. Estudo Preliminar

* Revisar conceitos bÃ¡sicos de programaÃ§Ã£o

* Familiarizar-se com terminal

* Praticar Git bÃ¡sico

## Recursos de Nivelamento

### Material de Estudo

* [LÃ³gica de ProgramaÃ§Ã£o BÃ¡sica](learning-path.html)

* [IntroduÃ§Ã£o a Terminais](terminal-essentials.html)

* [Git Fundamentals](git-basics.html)

### ExercÃ­cios PreparatÃ³rios

1. Criar algoritmos simples

2. Praticar comandos de terminal

3. Fazer operaÃ§Ãµes bÃ¡sicas com Git

## PrÃ³ximos Passos

Se vocÃª atende aos requisitos:

1. [ComeÃ§ar Setup do Ambiente](development-environment.html)

2. [Instalar Ferramentas](tools-overview.html)

3. [Iniciar Jornada](learning-path.html)

Se precisar de reforÃ§o:

1. Revisar material de nivelamento

2. Praticar exercÃ­cios bÃ¡sicos

3. Retornar quando preparado

## Suporte

### Canais de Ajuda

* FÃ³rum da comunidade

* DocumentaÃ§Ã£o oficial

* Tutoriais de nivelamento

* Mentoria da comunidade

[Configurar Ambiente de Desenvolvimento](development-environment.html)

Tip:

"Prepare seu terminal. A Matrix espera apenas aqueles que estÃ£o verdadeiramente prontos."



# Caminho de Aprendizado

```
>> Inicializando mapa neural...
>> Carregando rotas de conhecimento...
>> Calculando trajetÃ³ria Ã³tima...
>> Caminho de desenvolvimento estabelecido...
```

## Roadmap de EvoluÃ§Ã£o

```MERMAID
graph TD
    A[InicializaÃ§Ã£o] --> B[Java BÃ¡sico]
    B --> C[POO & Estruturas]
    C --> D[Recursos AvanÃ§ados]
    D --> E[Frameworks & Tools]
    E --> F[EspecializaÃ§Ã£o]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#00ff00
    style F fill:#1a1a1a,stroke:#00ff00
```

## NÃ­veis de ProgressÃ£o

### NÃ­vel 1: InicializaÃ§Ã£o

```
FASE INICIAL
â”œâ”€â”€ Setup do Ambiente
â”œâ”€â”€ Sintaxe BÃ¡sica
â”œâ”€â”€ VariÃ¡veis e Tipos
â”œâ”€â”€ Operadores
â””â”€â”€ Strings
```

### NÃ­vel 2: Controle de Fluxo

```
CONTROLE
â”œâ”€â”€ Condicionais
â”œâ”€â”€ Loops
â”œâ”€â”€ Switch
â””â”€â”€ Pattern Matching
```

### NÃ­vel 3: Estruturas de Dados

```
ESTRUTURAS
â”œâ”€â”€ Arrays
â”œâ”€â”€ Collections
â”œâ”€â”€ Lists & Sets
â””â”€â”€ Maps & Queues
```

### NÃ­vel 4: POO Fundamental

```
ORIENTAÃ‡ÃƒO A OBJETOS
â”œâ”€â”€ Classes e Objetos
â”œâ”€â”€ Encapsulamento
â”œâ”€â”€ HeranÃ§a
â””â”€â”€ Polimorfismo
```

### NÃ­vel 5: Recursos AvanÃ§ados

```
AVANÃ‡ADO
â”œâ”€â”€ Generics
â”œâ”€â”€ Lambda
â”œâ”€â”€ Streams
â””â”€â”€ Optional
```

## Metodologia de Progresso

### Ciclo de Aprendizado

```MERMAID
graph LR
    A[Teoria] --> B[Exemplo]
    B --> C[PrÃ¡tica]
    C --> D[Projeto]
    D --> E[Review]
    E --> A
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#00ff00
```

## Sistema de MissÃµes

### Projetos por NÃ­vel

1. BÃ¡sico

* Calculadora

* Conversor de Temperatura

* Manipulador de Strings

2. IntermediÃ¡rio

* Sistema BancÃ¡rio

* Gerenciador de Tarefas

* Processador de Dados

3. AvanÃ§ado

* API REST

* MicroserviÃ§o

* Sistema DistribuÃ­do

## MÃ©tricas de Progresso

### Indicadores de EvoluÃ§Ã£o

* Projetos completados

* ExercÃ­cios resolvidos

* Conceitos dominados

* CÃ³digo revisado

### Sistema de Conquistas

```
CONQUISTAS
â”œâ”€â”€ Iniciante [â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘]
â”œâ”€â”€ Desenvolvedor [â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘]
â””â”€â”€ Especialista [â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘]
```

## Recursos de Suporte

### Material Complementar

* DocumentaÃ§Ã£o oficial

* Artigos tÃ©cnicos

* VÃ­deos tutoriais

* ExercÃ­cios prÃ¡ticos

### Ferramentas de Desenvolvimento

* IDEs recomendadas

* Plugins essenciais

* Frameworks populares

* Bibliotecas Ãºteis

## PrÃ³ximas Etapas

### Caminhos de EspecializaÃ§Ã£o

1. Backend Development

2. Cloud Computing

3. Microservices

4. Data Engineering

## Dicas de Progresso

### Boas PrÃ¡ticas

* Code todos os dias

* Revise conceitos regularmente

* Participe da comunidade

* Construa projetos pessoais

### Armadilhas Comuns

* Pular fundamentos

* NÃ£o praticar cÃ³digo

* Ignorar boas prÃ¡ticas

* Evitar desafios

[ComeÃ§ar Jornada](java-basics.html)

Tip:

"O caminho do conhecimento Ã© como a Matrix - infinito em possibilidades, limitado apenas pela sua dedicaÃ§Ã£o."



# Ambiente de Desenvolvimento

```
>> Iniciando configuraÃ§Ã£o do ambiente...
>> Verificando dependÃªncias do sistema...
>> Preparando ferramentas de desenvolvimento...
>> Ambiente base estabelecido...
```

## VisÃ£o Geral

```MERMAID
graph TD
    A[Sistema Operacional] --> B[JDK]
    B --> C[IDE]
    C --> D[Ferramentas Auxiliares]
    D --> E[Ambiente Completo]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#00ff00
```

## Stack de Desenvolvimento

### Componentes Essenciais

```
AMBIENTE BASE
â”œâ”€â”€ JDK 17+
â”œâ”€â”€ IDE
â”‚   â”œâ”€â”€ IntelliJ IDEA
â”‚   â”œâ”€â”€ Eclipse
â”‚   â””â”€â”€ VS Code
â”œâ”€â”€ Git
â””â”€â”€ Terminal
```

### Ferramentas Auxiliares

```
TOOLS
â”œâ”€â”€ Maven/Gradle
â”œâ”€â”€ Docker
â”œâ”€â”€ Postman
â””â”€â”€ DBeaver
```

## ConfiguraÃ§Ã£o por Sistema Operacional

### Windows

```POWERSHELL
# Verificar versÃ£o do Java
java -version

# Verificar versÃ£o do Git
git --version

# Verificar variÃ¡veis de ambiente
echo %JAVA_HOME%
echo %PATH%
```

### macOS/Linux

```BASH
# Verificar versÃ£o do Java
java -version

# Verificar versÃ£o do Git
git --version

# Verificar variÃ¡veis de ambiente
echo $JAVA_HOME
echo $PATH
```

## IDEs Recomendadas

### IntelliJ IDEA

* Community Edition * Gratuita * Recursos essenciais * Plugins bÃ¡sicos

* Ultimate Edition * Recursos avanÃ§ados * Suporte a frameworks * Ferramentas profissionais

### VS Code

* Leve e rÃ¡pido

* ExtensÃ­vel

* Multiplataforma

* Gratuito

### Eclipse

* IDE tradicional

* Grande comunidade

* Plugins diversos

* Gratuito

## Plugins Essenciais

### Para Produtividade

```
PLUGINS
â”œâ”€â”€ Code Completion
â”œâ”€â”€ Git Integration
â”œâ”€â”€ Code Analysis
â””â”€â”€ Theme Tools
```

### Para Qualidade

```
QUALITY
â”œâ”€â”€ SonarLint
â”œâ”€â”€ CheckStyle
â”œâ”€â”€ PMD
â””â”€â”€ SpotBugs
```

## ConfiguraÃ§Ãµes Recomendadas

### Editor Settings

```JSON
{
    "editor.formatOnSave": true,
    "java.format.enabled": true,
    "java.completion.enabled": true,
    "java.debug.settings.hotCodeReplace": "auto"
}
```

### Git Config

```BASH
git config --global user.name "Seu Nome"
git config --global user.email "seu@email.com"
git config --global core.editor "code --wait"
```

## VerificaÃ§Ã£o do Ambiente

### Checklist de InstalaÃ§Ã£o

* [ ] JDK instalado e configurado

* [ ] IDE instalada e configurada

* [ ] Git instalado e configurado

* [ ] Terminal configurado

* [ ] Plugins essenciais instalados

### Teste do Ambiente

```JAVA
public class EnvironmentTest {
    public static void main(String[] args) {
        System.out.println("Java Version: " + 
            System.getProperty("java.version"));
        System.out.println("Java Home: " + 
            System.getProperty("java.home"));
        System.out.println("OS: " + 
            System.getProperty("os.name"));
    }
}
```

## PrÃ³ximos Passos

1. [Configurar Sistema Operacional](os-setup.html)

2. [Explorar Ferramentas](tools-overview.html)

3. [ComeÃ§ar a Programar](java-basics.html)

## Troubleshooting

### Problemas Comuns

1. Java nÃ£o encontrado

* Verificar instalaÃ§Ã£o

* Conferir PATH

* Reinstalar se necessÃ¡rio

2. IDE nÃ£o reconhece JDK

* Verificar configuraÃ§Ãµes

* Reconfigurar JAVA_HOME

* Reinstalar JDK

3. Git nÃ£o configurado

* Executar configuraÃ§Ãµes bÃ¡sicas

* Verificar credenciais

* Testar conexÃ£o com repositÃ³rio

[Configurar Sistema Operacional](os-setup.html)

Tip:

"Um ambiente bem configurado Ã© como ter acesso direto Ã  Matrix - tudo flui naturalmente."



# ConfiguraÃ§Ã£o do Sistema Operacional

```
>> Iniciando diagnÃ³stico do sistema...
>> Verificando compatibilidade...
>> Ajustando configuraÃ§Ãµes base...
>> Sistema preparado para desenvolvimento...
```

## Requisitos por Sistema

### Windows

```
WINDOWS SETUP
â”œâ”€â”€ Windows 10/11
â”œâ”€â”€ PowerShell 5.1+
â”œâ”€â”€ Windows Terminal
â””â”€â”€ WSL2 (recomendado)
```

### macOS

```
MACOS SETUP
â”œâ”€â”€ Catalina (10.15)+
â”œâ”€â”€ Terminal/iTerm2
â”œâ”€â”€ Homebrew
â””â”€â”€ Command Line Tools
```

### Linux

```
LINUX SETUP
â”œâ”€â”€ Kernel 5.0+
â”œâ”€â”€ Terminal
â”œâ”€â”€ Package Manager
â””â”€â”€ Build Tools
```

## ConfiguraÃ§Ã£o do Windows

### 1. Habilitar WSL2

```POWERSHELL
# Habilitar WSL
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart

# Habilitar VirtualizaÃ§Ã£o
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart

# Definir WSL2 como padrÃ£o
wsl --set-default-version 2
```

### 2. Windows Terminal

```
TERMINAL FEATURES
â”œâ”€â”€ Multi-tabs
â”œâ”€â”€ Temas personalizados
â”œâ”€â”€ Split panes
â””â”€â”€ IntegraÃ§Ã£o WSL
```

### 3. VariÃ¡veis de Ambiente

```POWERSHELL
# Adicionar ao Path
[Environment]::SetEnvironmentVariable(
    "Path",
    [Environment]::GetEnvironmentVariable("Path", "Machine") + ";C:\your\path",
    "Machine"
)
```

## ConfiguraÃ§Ã£o do macOS

### 1. Homebrew

```BASH
# Instalar Homebrew
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Verificar instalaÃ§Ã£o
brew doctor
```

### 2. Command Line Tools

```BASH
# Instalar Command Line Tools
xcode-select --install

# Verificar instalaÃ§Ã£o
xcode-select -p
```

### 3. Terminal Enhancement

```BASH
# Instalar iTerm2
brew install --cask iterm2

# Instalar Oh My Zsh
sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
```

## ConfiguraÃ§Ã£o do Linux

### 1. Pacotes Essenciais

```BASH
# Ubuntu/Debian
sudo apt update
sudo apt install build-essential curl wget git

# Fedora
sudo dnf groupinstall "Development Tools"
sudo dnf install curl wget git
```

### 2. Terminal Setup

```BASH
# Instalar e configurar ZSH
sudo apt install zsh
chsh -s $(which zsh)

# Instalar Oh My Zsh
sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
```

## ConfiguraÃ§Ãµes Comuns

### 1. Git Global

```BASH
# ConfiguraÃ§Ã£o bÃ¡sica
git config --global user.name "Seu Nome"
git config --global user.email "seu@email.com"

# Editor padrÃ£o
git config --global core.editor "code --wait"
```

### 2. SSH Keys

```BASH
# Gerar nova chave SSH
ssh-keygen -t ed25519 -C "seu@email.com"

# Iniciar ssh-agent
eval "$(ssh-agent -s)"

# Adicionar chave
ssh-add ~/.ssh/id_ed25519
```

## PersonalizaÃ§Ã£o

### Terminal Theme

```JSON
{
    "colorScheme": "Cyberpunk",
    "fontFace": "Cascadia Code",
    "fontSize": 12,
    "useAcrylic": true,
    "acrylicOpacity": 0.8
}
```

### Aliases Ãšteis

```BASH
# Git aliases
alias gs='git status'
alias ga='git add'
alias gc='git commit'
alias gp='git push'

# Navigation
alias ll='ls -la'
alias ..='cd ..'
alias ...='cd ../..'
```

## Ambientes de Desenvolvimento Isolados

### SDKMAN! com Docker

```
FROM ubuntu:22.04

# Instalar dependÃªncias
RUN apt-get update && apt-get install -y \
    curl \
    zip \
    unzip

# Instalar SDKMAN!
RUN curl -s "https://get.sdkman.io" | bash
ENV SDKMAN_DIR="/root/.sdkman"

# Configurar ambiente
COPY .sdkmanrc /app/.sdkmanrc
WORKDIR /app

# Instalar SDKs
RUN bash -c "source $SDKMAN_DIR/bin/sdkman-init.sh && \
    sdk env install"
```

### Gerenciamento de VersÃµes por Projeto

```
PROJECT STRUCTURE
â”œâ”€â”€ .sdkmanrc        # VersÃµes do projeto
â”œâ”€â”€ .java-version    # Alternativa para Java
â””â”€â”€ docker-compose.yml
```

### Exemplo de docker-compose.yml

```YAML
version: '3.8'
services:
  java-dev:
    build: .
    volumes:
      - .:/app
    environment:
      - SDKMAN_DIR=/root/.sdkman
```

### Scripts de AutomaÃ§Ã£o

```BASH
#!/bin/bash
# setup-dev.sh

# Verificar SDKMAN!
if ! command -v sdk &> /dev/null; then
    echo "Instalando SDKMAN!..."
    curl -s "https://get.sdkman.io" | bash
fi

# Carregar SDKMAN!
source "$HOME/.sdkman/bin/sdkman-init.sh"

# Instalar versÃµes do projeto
if [ -f .sdkmanrc ]; then
    echo "Configurando ambiente do projeto..."
    sdk env install
fi
```

### IntegraÃ§Ã£o com IDEs

```
IDE INTEGRATION
â”œâ”€â”€ IntelliJ IDEA
â”‚   â””â”€â”€ Project SDK
â”œâ”€â”€ Eclipse
â”‚   â””â”€â”€ Installed JREs
â””â”€â”€ VS Code
    â””â”€â”€ Java Runtime
```

### VerificaÃ§Ã£o de Ambiente

```BASH
# Verificar todas as versÃµes instaladas
sdk current

# Listar candidatos instalados
sdk list

# Verificar ambiente do projeto
sdk env
```

## VerificaÃ§Ã£o

### Checklist Final

* [ ] Sistema atualizado

* [ ] Terminal configurado

* [ ] Git instalado

* [ ] SSH configurado

* [ ] Aliases definidos

### Teste de Ambiente

```BASH
# Verificar versÃµes
java -version
git --version
node --version

# Testar SSH
ssh -T git@github.com
```

## Troubleshooting

### Problemas Comuns

1. WSL nÃ£o inicia

* Verificar virtualizaÃ§Ã£o no BIOS

* Reinstalar WSL

* Atualizar Windows

2. Homebrew falha

* Verificar permissÃµes

* Atualizar macOS

* Reinstalar Xcode CLI

3. Linux packages quebrados

* Limpar cache

* Atualizar repositÃ³rios

* Verificar dependÃªncias

[Explorar Ferramentas](tools-overview.html)

Tip:

"Configure seu sistema como um verdadeiro netrunner - cada detalhe importa na Matrix."



# VisÃ£o Geral das Ferramentas

```
NETRUNNER TOOLKIT
â”œâ”€â”€ Development
â”‚   â”œâ”€â”€ JDK
â”‚   â”œâ”€â”€ IDE
â”‚   â””â”€â”€ Build Tools
â”œâ”€â”€ Version Control
â”‚   â”œâ”€â”€ Git
â”‚   â””â”€â”€ GitHub/GitLab
â”œâ”€â”€ Containers
â”‚   â”œâ”€â”€ Docker
â”‚   â””â”€â”€ Kubernetes
â””â”€â”€ Cloud Tools
    â”œâ”€â”€ AWS CLI
    â”œâ”€â”€ Azure CLI
    â””â”€â”€ GCloud SDK
```

## Ferramentas Essenciais

### JDK (Java Development Kit)

```
JDK DISTRIBUTIONS
â”œâ”€â”€ Oracle JDK
â”œâ”€â”€ OpenJDK
â”œâ”€â”€ Amazon Corretto
â”œâ”€â”€ Eclipse Temurin
â””â”€â”€ GraalVM
```

#### Gerenciadores de VersÃ£o

* SDKMAN! - Gerenciamento de SDKs

* Jabba - Alternativa multiplataforma

* jEnv - EspecÃ­fico para Unix

### IDEs (Integrated Development Environment)

```
IDE OPTIONS
â”œâ”€â”€ IntelliJ IDEA
â”‚   â”œâ”€â”€ Community Edition
â”‚   â””â”€â”€ Ultimate Edition
â”œâ”€â”€ Eclipse
â”‚   â””â”€â”€ Enterprise Edition
â”œâ”€â”€ VS Code
â”‚   â””â”€â”€ Java Extensions
â””â”€â”€ NetBeans
```

#### Recursos Principais

* Debugging avanÃ§ado

* IntegraÃ§Ã£o com ferramentas

* RefatoraÃ§Ã£o inteligente

* Suporte a frameworks

### Build Tools

```
BUILD SYSTEMS
â”œâ”€â”€ Maven
â”‚   â”œâ”€â”€ Dependency Management
â”‚   â””â”€â”€ Lifecycle Management
â”œâ”€â”€ Gradle
â”‚   â”œâ”€â”€ Groovy DSL
â”‚   â””â”€â”€ Kotlin DSL
â””â”€â”€ Ant (Legacy)
```

## Ferramentas de Controle de VersÃ£o

### Git

```
GIT ESSENTIALS
â”œâ”€â”€ Controle de versÃ£o
â”œâ”€â”€ Branching
â”œâ”€â”€ Merging
â””â”€â”€ ColaboraÃ§Ã£o
```

### Interfaces Git

```
GIT GUI TOOLS
â”œâ”€â”€ GitKraken
â”œâ”€â”€ SourceTree
â”œâ”€â”€ GitHub Desktop
â””â”€â”€ IDE Integration
```

## Ferramentas de Container

### Docker

```
DOCKER STACK
â”œâ”€â”€ Docker Engine
â”œâ”€â”€ Docker Compose
â”œâ”€â”€ Docker Hub
â””â”€â”€ Docker Desktop
```

### Container Registry

```
REGISTRY OPTIONS
â”œâ”€â”€ Docker Hub
â”œâ”€â”€ GitHub Packages
â”œâ”€â”€ AWS ECR
â””â”€â”€ Azure Container Registry
```

## Ferramentas Cloud

### CLI Tools

```
CLOUD TOOLS
â”œâ”€â”€ AWS CLI
â”œâ”€â”€ Azure CLI
â”œâ”€â”€ Google Cloud SDK
â””â”€â”€ Heroku CLI
```

### Cloud IDEs

```
CLOUD DEVELOPMENT
â”œâ”€â”€ GitHub Codespaces
â”œâ”€â”€ GitPod
â”œâ”€â”€ Cloud9
â””â”€â”€ Eclipse Che
```

## Ferramentas de Produtividade

### Terminal

```
TERMINAL SETUP
â”œâ”€â”€ Windows Terminal
â”œâ”€â”€ iTerm2 (macOS)
â”œâ”€â”€ Terminator (Linux)
â””â”€â”€ Shell
    â”œâ”€â”€ Bash
    â”œâ”€â”€ Zsh
    â””â”€â”€ Fish
```

### ExtensÃµes Recomendadas

#### VS Code

```
VS CODE EXTENSIONS
â”œâ”€â”€ Java Extension Pack
â”œâ”€â”€ Spring Boot Tools
â”œâ”€â”€ Debugger for Java
â””â”€â”€ Test Runner
```

#### IntelliJ IDEA

```
INTELLIJ PLUGINS
â”œâ”€â”€ Lombok
â”œâ”€â”€ SonarLint
â”œâ”€â”€ GitToolBox
â””â”€â”€ Rainbow Brackets
```

## Ferramentas de Teste

### Testing Framework

```
TEST TOOLS
â”œâ”€â”€ JUnit
â”œâ”€â”€ TestNG
â”œâ”€â”€ Mockito
â””â”€â”€ AssertJ
```

### AnÃ¡lise de CÃ³digo

```
CODE QUALITY
â”œâ”€â”€ SonarQube
â”œâ”€â”€ CheckStyle
â”œâ”€â”€ PMD
â””â”€â”€ SpotBugs
```

## Ferramentas de DocumentaÃ§Ã£o

### Documentation

```
DOCUMENTATION
â”œâ”€â”€ JavaDoc
â”œâ”€â”€ Swagger/OpenAPI
â”œâ”€â”€ AsciiDoc
â””â”€â”€ Markdown
```

## Setup Inicial

### Checklist de InstalaÃ§Ã£o

* [ ] JDK via SDKMAN!

* [ ] IDE principal

* [ ] Git

* [ ] Docker

* [ ] Cloud CLI necessÃ¡ria

* [ ] Terminal configurado

### ConfiguraÃ§Ã£o Recomendada

```BASH
# Instalar JDK
sdk install java

# Configurar Git
git config --global user.name "Seu Nome"
git config --global user.email "seu@email.com"

# Verificar Docker
docker --version
```

## ManutenÃ§Ã£o

### AtualizaÃ§Ãµes Regulares

```
UPDATE ROUTINE
â”œâ”€â”€ JDK patches
â”œâ”€â”€ IDE updates
â”œâ”€â”€ Docker images
â””â”€â”€ Dependencies
```

### Backup de ConfiguraÃ§Ãµes

```
BACKUP ESSENTIALS
â”œâ”€â”€ IDE settings
â”œâ”€â”€ Git config
â”œâ”€â”€ Docker config
â””â”€â”€ Terminal preferences
```

## Troubleshooting

### Problemas Comuns

1. Conflitos de VersÃ£o Java

* Usar SDKMAN! para gerenciar versÃµes

* Verificar JAVA_HOME

* Limpar caches

2. Problemas IDE

* Limpar caches

* Atualizar Ã­ndices

* Reinstalar plugins

3. Issues Docker

* Verificar serviÃ§o

* Limpar volumes

* Reset configuraÃ§Ãµes

[ComeÃ§ar InstalaÃ§Ã£o JDK](jdk-installation.html)

Tip:

"Um netrunner Ã© tÃ£o bom quanto suas ferramentas. Escolha-as sabiamente."



# Setup do Ambiente de Desenvolvimento

```
SYSTEM INITIALIZATION
â”œâ”€â”€ JDK Setup
â”œâ”€â”€ IDE Config
â”œâ”€â”€ Git Setup
â”œâ”€â”€ Docker Init
â”œâ”€â”€ Cloud Tools
â””â”€â”€ Terminal Setup
```

## VisÃ£o Geral

### Requisitos MÃ­nimos

```
MINIMUM SPECS
â”œâ”€â”€ CPU: 2+ cores
â”œâ”€â”€ RAM: 8GB+
â”œâ”€â”€ Storage: 10GB+
â””â”€â”€ Internet: 10Mbps+
```

### Componentes Principais

* Java Development Kit (JDK)

* Ambiente de Desenvolvimento Integrado (IDE)

* Sistema de Controle de VersÃ£o

* Ferramentas de ContainerizaÃ§Ã£o

* CLIs de Cloud

* Terminal Configurado

## Ordem de InstalaÃ§Ã£o

### SequÃªncia Recomendada

1. [InstalaÃ§Ã£o do JDK](jdk-installation.html)

2. [ConfiguraÃ§Ã£o da IDE](ide-setup.html)

3. [BÃ¡sico do Git](git-basics.html)

4. [Essenciais do Terminal](terminal-essentials.html)

5. [BÃ¡sico do Docker](docker-basics.html)

6. [Setup Cloud](cloud-setup.html)

## VerificaÃ§Ã£o de Ambiente

### Checklist de ValidaÃ§Ã£o

```BASH
# Verificar Java
java --version

# Verificar Git
git --version

# Verificar Docker
docker --version

# Verificar Cloud CLI
aws --version  # ou
az --version   # ou
gcloud --version
```

## PrÃ³ximos Passos

### ConfiguraÃ§Ã£o AvanÃ§ada

* PersonalizaÃ§Ã£o da IDE

* ConfiguraÃ§Ã£o do Git

* Setup de Containers

* IntegraÃ§Ã£o Cloud

[Iniciar InstalaÃ§Ã£o do JDK](jdk-installation.html)

Tip:

"A preparaÃ§Ã£o adequada Ã© metade da batalha. Configure seu ambiente com precisÃ£o."



# InstalaÃ§Ã£o do JDK

```
JDK INSTALLATION
â”œâ”€â”€ SDKMAN! Setup
â”œâ”€â”€ JDK Selection
â”œâ”€â”€ Environment Config
â””â”€â”€ Validation
```

## SDKMAN!

### InstalaÃ§Ã£o do SDKMAN!

```BASH
# Download e instalaÃ§Ã£o
curl -s "https://get.sdkman.io" | bash

# Recarregar shell
source "$HOME/.sdkman/bin/sdkman-init.sh"

# Verificar instalaÃ§Ã£o
sdk version
```

### Comandos BÃ¡sicos

```
SDKMAN COMMANDS
â”œâ”€â”€ sdk list java     # Listar versÃµes
â”œâ”€â”€ sdk install java  # Instalar JDK
â”œâ”€â”€ sdk use java     # Usar versÃ£o
â””â”€â”€ sdk default java # Definir padrÃ£o
```

## InstalaÃ§Ã£o do JDK

### Escolha da DistribuiÃ§Ã£o

```
JDK OPTIONS
â”œâ”€â”€ Oracle JDK
â”‚   â””â”€â”€ LicenÃ§a comercial
â”œâ”€â”€ OpenJDK
â”‚   â””â”€â”€ Open source
â”œâ”€â”€ Amazon Corretto
â”‚   â””â”€â”€ AWS optimized
â”œâ”€â”€ Eclipse Temurin
â”‚   â””â”€â”€ AdoptOpenJDK successor
â””â”€â”€ GraalVM
    â””â”€â”€ Native compilation
```

### InstalaÃ§Ã£o via SDKMAN!

```BASH
# Listar versÃµes disponÃ­veis
sdk list java

# Instalar JDK LTS
sdk install java 17.0.8-tem

# Definir como padrÃ£o
sdk default java 17.0.8-tem
```

## ConfiguraÃ§Ã£o do Ambiente

### VariÃ¡veis de Ambiente

```BASH
# Verificar JAVA_HOME
echo $JAVA_HOME

# Verificar PATH
echo $PATH | grep java
```

### ConfiguraÃ§Ã£o Manual (se necessÃ¡rio)

```BASH
# Para Bash/Zsh
echo "export JAVA_HOME=$HOME/.sdkman/candidates/java/current" >> ~/.bashrc
echo "export PATH=\$JAVA_HOME/bin:\$PATH" >> ~/.bashrc

# Para Fish
set -Ux JAVA_HOME $HOME/.sdkman/candidates/java/current
set -Ux PATH $JAVA_HOME/bin $PATH
```

## VerificaÃ§Ã£o da InstalaÃ§Ã£o

### Testes BÃ¡sicos

```BASH
# Verificar versÃ£o Java
java --version

# Verificar compilador
javac --version

# Testar compilaÃ§Ã£o
echo 'public class Test { public static void main(String[] args) { System.out.println("Hello, NetRunner!"); } }' > Test.java
javac Test.java
java Test
```

## Multi-versÃ£o

### Gerenciamento de VersÃµes

```BASH
# Instalar mÃºltiplas versÃµes
sdk install java 11.0.20-tem
sdk install java 17.0.8-tem
sdk install java 21-tem

# Alternar entre versÃµes
sdk use java 11.0.20-tem  # TemporÃ¡rio
sdk default java 17.0.8-tem  # Permanente
```

### ConfiguraÃ§Ã£o por Projeto

```BASH
# Criar arquivo de configuraÃ§Ã£o
echo "java=17.0.8-tem" > .sdkmanrc

# Ativar ambiente do projeto
sdk env
```

## Troubleshooting

### Problemas Comuns

1. SDKMAN! nÃ£o instala

* Verificar curl instalado

* Verificar permissÃµes

* Verificar conexÃ£o

2. JDK nÃ£o encontrado

* Recarregar terminal

* Verificar PATH

* Verificar JAVA_HOME

3. Conflitos de versÃ£o

* Usar `sdk flush`

* Remover versÃ£o: `sdk rm java`

* Reinstalar SDKMAN!

## PrÃ³ximos Passos

### ConfiguraÃ§Ã£o IDE

* Configurar Project SDK

* Importar projetos

* Configurar build tools

[Configurar IDE](ide-setup.html)

Tip:

"A base de todo netrunner Ã© um JDK bem configurado. Escolha suas armas com sabedoria."



# ConfiguraÃ§Ã£o da IDE

```
IDE SETUP
â”œâ”€â”€ IntelliJ IDEA
â”œâ”€â”€ Eclipse
â”œâ”€â”€ VS Code
â””â”€â”€ NetBeans
```

## IntelliJ IDEA

### InstalaÃ§Ã£o

```
INTELLIJ VARIANTS
â”œâ”€â”€ Community Edition
â”‚   â””â”€â”€ Open Source
â””â”€â”€ Ultimate Edition
    â””â”€â”€ Trial/Licensed
```

```BASH
# Linux (snap)
sudo snap install intellij-idea-community --classic

# macOS (brew)
brew install --cask intellij-idea-ce

# Windows
winget install JetBrains.IntelliJ.IDEA.Community
```

### Plugins Essenciais

```
CORE PLUGINS
â”œâ”€â”€ Java Development
â”œâ”€â”€ Git Integration
â”œâ”€â”€ Maven/Gradle
â””â”€â”€ Docker
```

### ConfiguraÃ§Ã£o Inicial

```
INITIAL SETUP
â”œâ”€â”€ Project SDK
â”œâ”€â”€ Code Style
â”œâ”€â”€ File Templates
â””â”€â”€ Live Templates
```

## Visual Studio Code

### InstalaÃ§Ã£o

```BASH
# Linux
sudo snap install code --classic

# macOS
brew install --cask visual-studio-code

# Windows
winget install Microsoft.VisualStudioCode
```

### ExtensÃµes Java

```
EXTENSIONS
â”œâ”€â”€ Extension Pack for Java
â”œâ”€â”€ Spring Boot Extension Pack
â”œâ”€â”€ Java Test Runner
â””â”€â”€ Debugger for Java
```

### ConfiguraÃ§Ãµes Recomendadas

```JSON
{
    "java.home": "/path/to/jdk",
    "java.format.settings.url": "eclipse-formatter.xml",
    "java.completion.importOrder": [
        "java",
        "javax",
        "com",
        "org"
    ]
}
```

## Eclipse

### InstalaÃ§Ã£o

```
ECLIPSE PACKAGES
â”œâ”€â”€ Eclipse IDE for Java
â”œâ”€â”€ Eclipse IDE for Enterprise
â””â”€â”€ Eclipse IDE for Web
```

```BASH
# Linux
sudo snap install eclipse --classic

# macOS
brew install --cask eclipse-java

# Windows
winget install Eclipse.Java
```

### Plugins Recomendados

```
ECLIPSE PLUGINS
â”œâ”€â”€ EGit
â”œâ”€â”€ Spring Tools
â”œâ”€â”€ CodeMix
â””â”€â”€ Darkest Dark Theme
```

## ConfiguraÃ§Ãµes AvanÃ§adas

### PersonalizaÃ§Ã£o

```
CUSTOMIZATION
â”œâ”€â”€ Theme Setup
â”œâ”€â”€ Keymap Config
â”œâ”€â”€ Code Templates
â””â”€â”€ Live Templates
```

### IntegraÃ§Ã£o Git

```
GIT SETUP
â”œâ”€â”€ SSH Keys
â”œâ”€â”€ GitHub Integration
â”œâ”€â”€ GitLab Integration
â””â”€â”€ Bitbucket Integration
```

### Debug & Profiling

```
DEBUG TOOLS
â”œâ”€â”€ Remote Debug
â”œâ”€â”€ Memory Analyzer
â”œâ”€â”€ CPU Profiler
â””â”€â”€ Thread Dump
```

## Produtividade

### Atalhos Essenciais

```
SHORTCUTS
â”œâ”€â”€ Code Completion
â”‚   â”œâ”€â”€ Ctrl+Space
â”‚   â””â”€â”€ Alt+Enter
â”œâ”€â”€ Navigation
â”‚   â”œâ”€â”€ Ctrl+Click
â”‚   â””â”€â”€ Alt+F7
â”œâ”€â”€ Refactoring
â”‚   â”œâ”€â”€ Shift+F6
â”‚   â””â”€â”€ Ctrl+Alt+M
â””â”€â”€ Debug
    â”œâ”€â”€ F8
    â””â”€â”€ F9
```

### Templates

```JAVA
// Live Template: psvm
public static void main(String[] args) {
    
}

// Live Template: sout
System.out.println();

// Live Template: fori
for (int i = 0; i < ; i++) {
    
}
```

## Troubleshooting

### Problemas Comuns

1. IDE nÃ£o reconhece JDK

* Verificar JAVA_HOME

* Reconfigurar Project SDK

* Invalidar caches

2. Performance lenta

* Aumentar heap memory

* Desabilitar plugins

* Limpar Ã­ndices

3. Problemas de indexaÃ§Ã£o

* Invalidar caches

* Reconstruir Ã­ndices

* Verificar exclusÃµes

## ConfiguraÃ§Ã£o do Projeto

### Estrutura BÃ¡sica

```
PROJECT STRUCTURE
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/
â”‚   â”‚   â”œâ”€â”€ java/
â”‚   â”‚   â””â”€â”€ resources/
â”‚   â””â”€â”€ test/
â”‚       â”œâ”€â”€ java/
â”‚       â””â”€â”€ resources/
â”œâ”€â”€ pom.xml
â””â”€â”€ .gitignore
```

### Build Tools

```
BUILD CONFIG
â”œâ”€â”€ Maven
â”‚   â””â”€â”€ pom.xml
â””â”€â”€ Gradle
    â””â”€â”€ build.gradle
```

## PrÃ³ximos Passos

### Workflow Setup

* Configurar formataÃ§Ã£o de cÃ³digo

* Definir templates de projeto

* Configurar integraÃ§Ã£o contÃ­nua

* Preparar ambiente de debug

[Configurar Git](git-basics.html)

Tip:

"Uma IDE bem configurada Ã© como ter um deck cyberdeck personalizado - aumenta exponencialmente sua eficiÃªncia na Matrix."



# Git BÃ¡sico

```
GIT FUNDAMENTALS
â”œâ”€â”€ Setup Inicial
â”œâ”€â”€ OperaÃ§Ãµes BÃ¡sicas
â”œâ”€â”€ Branching
â”œâ”€â”€ Remote Operations
â””â”€â”€ Best Practices
```

## InstalaÃ§Ã£o e Setup

### InstalaÃ§Ã£o

```BASH
# Linux (Debian/Ubuntu)
sudo apt install git

# macOS
brew install git

# Windows
winget install Git.Git
```

### ConfiguraÃ§Ã£o Inicial

```BASH
# Identidade
git config --global user.name "Seu Nome"
git config --global user.email "seu@email.com"

# Editor padrÃ£o
git config --global core.editor "code --wait"  # VS Code
# git config --global core.editor "vim"        # Vim
# git config --global core.editor "nano"       # Nano

# Configurar branch padrÃ£o
git config --global init.defaultBranch main
```

## OperaÃ§Ãµes BÃ¡sicas

### Ciclo de Vida

```
FILE STATUS
â”œâ”€â”€ Untracked
â”œâ”€â”€ Staged
â”œâ”€â”€ Committed
â””â”€â”€ Modified
```

### Comandos Essenciais

```BASH
# Iniciar repositÃ³rio
git init

# Status do repositÃ³rio
git status

# Adicionar arquivos
git add <arquivo>      # Arquivo especÃ­fico
git add .              # Todos os arquivos

# Commit
git commit -m "mensagem"
git commit -am "mensagem"  # Add + Commit

# HistÃ³rico
git log
git log --oneline
git log --graph
```

## Branches

### OperaÃ§Ãµes com Branches

```BASH
# Listar branches
git branch

# Criar branch
git branch feature/nova-funcionalidade

# Mudar de branch
git checkout feature/nova-funcionalidade
# ou
git switch feature/nova-funcionalidade

# Criar e mudar
git checkout -b feature/nova-funcionalidade
```

### Merge e Rebase

```BASH
# Merge
git checkout main
git merge feature/nova-funcionalidade

# Rebase
git checkout feature/nova-funcionalidade
git rebase main
```

## OperaÃ§Ãµes Remotas

### ConfiguraÃ§Ã£o Remota

```BASH
# Adicionar remote
git remote add origin https://github.com/user/repo.git

# Listar remotes
git remote -v

# Remover remote
git remote remove origin
```

### SincronizaÃ§Ã£o

```BASH
# Push
git push origin main

# Pull
git pull origin main

# Fetch
git fetch origin

# Clone
git clone https://github.com/user/repo.git
```

## Gitflow

### Estrutura de Branches

```
BRANCH STRUCTURE
â”œâ”€â”€ main
â”œâ”€â”€ develop
â”œâ”€â”€ feature/*
â”œâ”€â”€ release/*
â”œâ”€â”€ hotfix/*
â””â”€â”€ bugfix/*
```

### Workflow BÃ¡sico

```
WORKFLOW
â”œâ”€â”€ Criar feature branch
â”œâ”€â”€ Desenvolver
â”œâ”€â”€ Commit changes
â”œâ”€â”€ Push to remote
â””â”€â”€ Create pull request
```

## Boas PrÃ¡ticas

### Commits

```
COMMIT PATTERNS
â”œâ”€â”€ Conventional Commits
â”‚   â”œâ”€â”€ feat: nova feature
â”‚   â”œâ”€â”€ fix: correÃ§Ã£o
â”‚   â”œâ”€â”€ docs: documentaÃ§Ã£o
â”‚   â”œâ”€â”€ style: formataÃ§Ã£o
â”‚   â”œâ”€â”€ refactor: refatoraÃ§Ã£o
â”‚   â”œâ”€â”€ test: testes
â”‚   â””â”€â”€ chore: manutenÃ§Ã£o
â””â”€â”€ Atomic Commits
```

### .gitignore

```BASH
# Java
*.class
*.jar
target/

# IDEs
.idea/
.vscode/
*.iml

# Logs
*.log
logs/

# OS
.DS_Store
Thumbs.db
```

## Git AvanÃ§ado

### Stash

```BASH
# Salvar alteraÃ§Ãµes
git stash

# Listar stashes
git stash list

# Aplicar stash
git stash apply
git stash pop

# Limpar stash
git stash clear
```

### Reset e Revert

```BASH
# Reset
git reset --soft HEAD~1   # MantÃ©m alteraÃ§Ãµes
git reset --hard HEAD~1   # Remove alteraÃ§Ãµes

# Revert
git revert HEAD          # Reverte Ãºltimo commit
```

## Troubleshooting

### Problemas Comuns

1. Conflitos de Merge

```BASH
# Abortar merge
git merge --abort

# Resolver manualmente
# Editar arquivos
git add .
git commit
```

2. Branch Errada

```BASH
# Mover alteraÃ§Ãµes
git stash
git checkout branch-correta
git stash pop
```

3. Commit Errado

```BASH
# Desfazer Ãºltimo commit
git reset --soft HEAD~1

# Alterar mensagem
git commit --amend
```

## Ferramentas Visuais

### GUI Clients

```
GUI OPTIONS
â”œâ”€â”€ GitKraken
â”œâ”€â”€ SourceTree
â”œâ”€â”€ GitHub Desktop
â””â”€â”€ Git GUI
```

## PrÃ³ximos Passos

### Aprofundamento

* Explorar Git hooks

* Configurar CI/CD

* Aprender rebase interativo

* Estudar estratÃ©gias de branching

[Essenciais do Terminal](terminal-essentials.html)

Tip:

"No submundo digital, o controle de versÃ£o Ã© sua linha do tempo pessoal - cada commit Ã© um checkpoint que vocÃª pode revisitar."



# Essenciais do Terminal

```
TERMINAL MASTERY
â”œâ”€â”€ BÃ¡sico
â”œâ”€â”€ NavegaÃ§Ã£o
â”œâ”€â”€ ManipulaÃ§Ã£o
â”œâ”€â”€ Processos
â””â”€â”€ CustomizaÃ§Ã£o
```

## Comandos Fundamentais

### NavegaÃ§Ã£o

```BASH
# Listar arquivos
ls
ls -la

# Mudar diretÃ³rio
cd path/to/dir
cd ..
cd ~

# Mostrar diretÃ³rio atual
pwd
```

### ManipulaÃ§Ã£o de Arquivos

```BASH
# Criar
touch arquivo.txt
mkdir pasta

# Copiar
cp origem destino
cp -r pasta1 pasta2

# Mover/Renomear
mv origem destino

# Remover
rm arquivo.txt
rm -r pasta
```

### VisualizaÃ§Ã£o

```BASH
# Ver conteÃºdo
cat arquivo.txt
less arquivo.txt
head arquivo.txt
tail arquivo.txt

# Buscar
grep "texto" arquivo.txt
find . -name "*.java"
```

## PermissÃµes

### Gerenciamento

```BASH
# Visualizar
ls -l

# Modificar
chmod +x script.sh
chmod 755 arquivo

# Mudar proprietÃ¡rio
chown usuario:grupo arquivo
```

## Processos

### Gerenciamento

```BASH
# Listar processos
ps aux
top

# Background
comando &
bg
fg

# Terminar processo
kill PID
killall processo
```

## Redirecionamento

### Input/Output

```BASH
# Redirecionamento
comando > output.txt
comando >> output.txt
comando < input.txt

# Pipes
comando1 | comando2
```

## Ambiente

### VariÃ¡veis

```BASH
# Exibir
echo $PATH
env

# Definir
export JAVA_HOME=/path/to/java
```

## CustomizaÃ§Ã£o

### Shell RC

```BASH
# .bashrc ou .zshrc
alias ll='ls -la'
alias gs='git status'

# Path
export PATH=$PATH:/novo/caminho
```

## Atalhos

### Keyboard Shortcuts

```
SHORTCUTS
â”œâ”€â”€ Ctrl + C  (Cancelar)
â”œâ”€â”€ Ctrl + L  (Limpar)
â”œâ”€â”€ Ctrl + R  (Buscar histÃ³rico)
â”œâ”€â”€ Ctrl + A  (InÃ­cio da linha)
â””â”€â”€ Ctrl + E  (Fim da linha)
```

## Scripts

### Shell Scripts

```BASH
#!/bin/bash

# Exemplo bÃ¡sico
echo "Iniciando script..."
for i in {1..5}; do
    echo "IteraÃ§Ã£o $i"
done
```

## Ferramentas AvanÃ§adas

### Power Tools

```
POWER TOOLS
â”œâ”€â”€ tmux    (Terminal Multiplexer)
â”œâ”€â”€ vim     (Editor)
â”œâ”€â”€ htop    (Process Viewer)
â””â”€â”€ fzf     (Fuzzy Finder)
```

## Troubleshooting

### Debug

```BASH
# Debug modo
set -x

# Verificar status
echo $?

# Ver logs
tail -f /var/log/syslog
```

## PrÃ³ximos Passos

### Aprofundamento

* Shell scripting avanÃ§ado

* AutomaÃ§Ã£o com cron

* Terminal multiplexing

* CustomizaÃ§Ã£o avanÃ§ada

[BÃ¡sico do Docker](docker-basics.html)

Tip:

"O terminal Ã© sua interface direta com a Matrix - domine-o, e vocÃª controlarÃ¡ o sistema."



# Docker BÃ¡sico

```
DOCKER ESSENTIALS
â”œâ”€â”€ Conceitos
â”œâ”€â”€ InstalaÃ§Ã£o
â”œâ”€â”€ Comandos BÃ¡sicos
â”œâ”€â”€ Docker Compose
â””â”€â”€ Best Practices
```

## Fundamentos

### Conceitos BÃ¡sicos

```
DOCKER COMPONENTS
â”œâ”€â”€ Images
â”œâ”€â”€ Containers
â”œâ”€â”€ Volumes
â”œâ”€â”€ Networks
â””â”€â”€ Registry
```

### InstalaÃ§Ã£o

```BASH
# Linux (Ubuntu)
curl -fsSL https://get.docker.com | sh

# Windows/Mac
# Baixar Docker Desktop do site oficial
```

## Comandos Essenciais

### Gerenciamento de Containers

```BASH
# Executar container
docker run hello-world
docker run -d -p 8080:80 nginx

# Listar containers
docker ps
docker ps -a

# OperaÃ§Ãµes
docker start container_id
docker stop container_id
docker restart container_id
docker rm container_id
```

### Imagens

```BASH
# Listar imagens
docker images

# Pull de imagem
docker pull ubuntu:latest

# Remover imagem
docker rmi imagem_id

# Build de imagem
docker build -t app:1.0 .
```

## Dockerfile

### Estrutura BÃ¡sica

```
# Base image
FROM openjdk:17-jdk-slim

# Metadados
LABEL maintainer="netrunner@corp.net"

# DiretÃ³rio de trabalho
WORKDIR /app

# Copiar arquivos
COPY target/*.jar app.jar

# Porta
EXPOSE 8080

# Comando de execuÃ§Ã£o
CMD ["java", "-jar", "app.jar"]
```

## Docker Compose

### docker-compose.yml

```YAML
version: '3.8'
services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - DB_HOST=db
    depends_on:
      - db
  
  db:
    image: postgres:13
    environment:
      - POSTGRES_PASSWORD=secret
```

### Comandos Compose

```BASH
# Iniciar serviÃ§os
docker-compose up -d

# Parar serviÃ§os
docker-compose down

# Logs
docker-compose logs
```

## Redes

### Network Commands

```BASH
# Criar rede
docker network create mynet

# Listar redes
docker network ls

# Conectar container
docker network connect mynet container_id
```

## Volumes

### Volume Management

```BASH
# Criar volume
docker volume create mydata

# Listar volumes
docker volume ls

# Usar volume
docker run -v mydata:/data nginx
```

## Troubleshooting

### Problemas Comuns

```BASH
# Verificar logs
docker logs container_id

# Inspecionar container
docker inspect container_id

# Entrar no container
docker exec -it container_id bash
```

## SeguranÃ§a

### Best Practices

```
SECURITY CHECKLIST
â”œâ”€â”€ Usar imagens oficiais
â”œâ”€â”€ Manter containers atualizados
â”œâ”€â”€ Limitar recursos
â”œâ”€â”€ Usar usuÃ¡rios nÃ£o-root
â””â”€â”€ Escanear vulnerabilidades
```

## Monitoramento

### Ferramentas

```
MONITORING TOOLS
â”œâ”€â”€ Docker Stats
â”œâ”€â”€ Prometheus
â”œâ”€â”€ Grafana
â””â”€â”€ cAdvisor
```

## PrÃ³ximos Passos

### Aprofundamento

* OrquestraÃ§Ã£o com Kubernetes

* CI/CD com Docker

* Docker Swarm

* MicroserviÃ§os

[Setup Cloud](cloud-setup.html)

Tip:

"Containers sÃ£o como cÃ¡psulas de dados na Matrix - isolados, portÃ¡teis e prontos para deployment."



# Setup Cloud

```
CLOUD SETUP
â”œâ”€â”€ Providers
â”œâ”€â”€ CLI Tools
â”œâ”€â”€ Authentication
â””â”€â”€ Basic Services
```

## Cloud Providers

### Principais Provedores

```
CLOUD OPTIONS
â”œâ”€â”€ AWS
â”œâ”€â”€ Azure
â”œâ”€â”€ Google Cloud
â””â”€â”€ Oracle Cloud
```

## CLI Setup

### AWS CLI

```BASH
# Instalar AWS CLI
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install

# Configurar
aws configure
```

### Azure CLI

```BASH
# Instalar Azure CLI
curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

# Login
az login
```

### Google Cloud SDK

```BASH
# Instalar Google Cloud SDK
curl https://sdk.cloud.google.com | bash

# Inicializar
gcloud init
```

## AutenticaÃ§Ã£o

### Credenciais

```
AUTH METHODS
â”œâ”€â”€ Access Keys
â”œâ”€â”€ Service Accounts
â”œâ”€â”€ IAM Roles
â””â”€â”€ MFA
```

### ConfiguraÃ§Ã£o

```BASH
# AWS Credentials
aws configure set aws_access_key_id YOUR_KEY
aws configure set aws_secret_access_key YOUR_SECRET

# GCloud Auth
gcloud auth login
gcloud config set project YOUR_PROJECT
```

## ServiÃ§os BÃ¡sicos

### Storage

```
STORAGE SERVICES
â”œâ”€â”€ AWS S3
â”œâ”€â”€ Azure Blob
â””â”€â”€ Google Cloud Storage
```

### Compute

```
COMPUTE SERVICES
â”œâ”€â”€ EC2/VM
â”œâ”€â”€ Container Services
â””â”€â”€ Serverless
```

## Networking

### VPC Setup

```
NETWORK CONFIG
â”œâ”€â”€ VPC/VNET
â”œâ”€â”€ Subnets
â”œâ”€â”€ Security Groups
â””â”€â”€ Load Balancers
```

## Monitoramento

### Ferramentas Cloud

```
MONITORING
â”œâ”€â”€ CloudWatch
â”œâ”€â”€ Azure Monitor
â””â”€â”€ Cloud Monitoring
```

## SeguranÃ§a

### Best Practices

```
SECURITY CHECKLIST
â”œâ”€â”€ MFA Ativado
â”œâ”€â”€ Least Privilege
â”œâ”€â”€ Encryption
â””â”€â”€ Logging
```

## Cost Management

### Controle de Custos

```
COST CONTROL
â”œâ”€â”€ Budgets
â”œâ”€â”€ Alerts
â”œâ”€â”€ Resource Tags
â””â”€â”€ Cost Explorer
```

## PrÃ³ximos Passos

### Aprofundamento

* Infrastructure as Code

* Cloud Native Development

* Serverless Architecture

* Multi-Cloud Strategy

[ComeÃ§ar com Java](java-basics.html)

Tip:

"A nuvem Ã© a nova fronteira da Matrix - um territÃ³rio vasto de recursos virtualizados prontos para serem explorados."



# Fundamentos Java

```
JAVA BASICS
â”œâ”€â”€ Estrutura
â”œâ”€â”€ Sintaxe
â”œâ”€â”€ Tipos
â”œâ”€â”€ Operadores
â””â”€â”€ Strings
```

## Estrutura de um Programa

### Anatomia BÃ¡sica

```JAVA
// Arquivo: HelloMatrix.java
public class HelloMatrix {
    public static void main(String[] args) {
        System.out.println("Iniciando conexÃ£o com a Matrix...");
    }
}
```

### Componentes Principais

```
JAVA STRUCTURE
â”œâ”€â”€ Package Declaration
â”œâ”€â”€ Imports
â”œâ”€â”€ Class Declaration
â”œâ”€â”€ Fields
â””â”€â”€ Methods
```

## ConvenÃ§Ãµes de CÃ³digo

### Nomenclatura

```
NAMING CONVENTIONS
â”œâ”€â”€ Classes        (PascalCase)
â”œâ”€â”€ Methods        (camelCase)
â”œâ”€â”€ Variables      (camelCase)
â”œâ”€â”€ Constants      (UPPER_SNAKE_CASE)
â””â”€â”€ Packages       (lowercase)
```

## CompilaÃ§Ã£o e ExecuÃ§Ã£o

### Processo

```
COMPILATION FLOW
Source (.java) â†’ Bytecode (.class) â†’ JVM â†’ Execution
```

### Comandos

```BASH
# Compilar
javac HelloMatrix.java

# Executar
java HelloMatrix
```

## Estrutura de Arquivos

### OrganizaÃ§Ã£o

```
PROJECT STRUCTURE
src/
â”œâ”€â”€ com/
â”‚   â””â”€â”€ netrunner/
â”‚       â””â”€â”€ core/
â”‚           â””â”€â”€ HelloMatrix.java
â””â”€â”€ resources/
    â””â”€â”€ config.properties
```

## ComentÃ¡rios

### Tipos

```JAVA
// ComentÃ¡rio de linha Ãºnica

/*
   ComentÃ¡rio de
   mÃºltiplas linhas
*/

/**
 * DocumentaÃ§Ã£o JavaDoc
 * @author NetRunner
 * @version 1.0
 */
```

## Palavras-Chave

### Keywords Principais

```
KEYWORDS
â”œâ”€â”€ Controle     (if, else, for, while)
â”œâ”€â”€ Modificadores (public, private, static)
â”œâ”€â”€ Tipos        (class, interface, enum)
â””â”€â”€ Outros       (new, return, this, super)
```

## Ambiente de Desenvolvimento

### Ferramentas Essenciais

```
DEV ENVIRONMENT
â”œâ”€â”€ JDK
â”œâ”€â”€ IDE
â”œâ”€â”€ Build Tools
â””â”€â”€ Version Control
```

## Debug e Logs

### TÃ©cnicas BÃ¡sicas

```JAVA
// Print debugging
System.out.println("Debug: " + variable);

// Logging bÃ¡sico
Logger logger = Logger.getLogger(HelloMatrix.class.getName());
logger.info("Iniciando aplicaÃ§Ã£o...");
```

## Boas PrÃ¡ticas

### PrincÃ­pios

```
BEST PRACTICES
â”œâ”€â”€ Clean Code
â”œâ”€â”€ DRY (Don't Repeat Yourself)
â”œâ”€â”€ KISS (Keep It Simple)
â””â”€â”€ SOLID Principles
```

## PrÃ³ximos Passos

### TÃ³picos Seguintes

* Sintaxe detalhada

* VariÃ¡veis e tipos

* Operadores

* Strings e manipulaÃ§Ã£o

* Projetos prÃ¡ticos

[Sintaxe Java](syntax.html)

Tip:

"Java Ã© como o cÃ³digo base da Matrix - estruturado, robusto e onipresente."

## SubseÃ§Ãµes

* [Sintaxe](syntax.html)

* [VariÃ¡veis](variables.html)

* [Operadores](operators.html)

* [Strings](strings.html)

* [Projetos BÃ¡sicos](basic-projects.html)



# Sintaxe Java

```
SYNTAX STRUCTURE
â”œâ”€â”€ DeclaraÃ§Ãµes
â”œâ”€â”€ Blocos
â”œâ”€â”€ ExpressÃµes
â””â”€â”€ Statements
```

## Estrutura BÃ¡sica

### Classe

```JAVA
public class MatrixCode {
    // Membros da classe aqui
}
```

### MÃ©todo

```JAVA
public void hackSystem() {
    // CÃ³digo do mÃ©todo aqui
}
```

## DeclaraÃ§Ãµes

### VariÃ¡veis

```JAVA
// DeclaraÃ§Ã£o simples
tipo nome;

// DeclaraÃ§Ã£o com inicializaÃ§Ã£o
tipo nome = valor;

// Exemplos
int contador = 0;
String mensagem = "ConexÃ£o estabelecida";
boolean sistemaBloqueado = false;
```

### Constantes

```JAVA
// Constante
final double PI = 3.14159;

// Constante estÃ¡tica
public static final String VERSION = "1.0.0";
```

## Blocos de CÃ³digo

### Estrutura

```JAVA
{
    // Bloco de cÃ³digo
    // Pode conter mÃºltiplas linhas
}
```

### Escopo

```JAVA
public void exemplo() {
    int x = 1; // Escopo do mÃ©todo
    {
        int y = 2; // Escopo do bloco
        // y Ã© acessÃ­vel aqui
    }
    // y nÃ£o Ã© acessÃ­vel aqui
    // x Ã© acessÃ­vel em todo o mÃ©todo
}
```

## Statements

### Tipos

```JAVA
// Statement simples
System.out.println("Executando...");

// Statement composto
if (status == "online") {
    System.out.println("Conectado");
    iniciarOperacao();
}
```

## ExpressÃµes

### Componentes

```JAVA
// ExpressÃµes aritmÃ©ticas
resultado = 10 + 5 * 2;

// ExpressÃµes lÃ³gicas
boolean acessoPermitido = nivel >= 5 && !bloqueado;

// ExpressÃµes de string
String nomeCompleto = nome + " " + sobrenome;
```

## Identificadores

### Regras

```
IDENTIFIER RULES
â”œâ”€â”€ ComeÃ§ar com letra, $ ou _
â”œâ”€â”€ Pode conter nÃºmeros
â”œâ”€â”€ Case-sensitive
â””â”€â”€ Sem palavras reservadas
```

### Exemplos

```JAVA
// VÃ¡lidos
String usuarioNome;
int _contador;
double $taxa;

// InvÃ¡lidos
int 123numero;     // ComeÃ§a com nÃºmero
String class;      // Palavra reservada
```

## Palavras Reservadas

### Keywords

```
RESERVED WORDS
â”œâ”€â”€ Tipos      (boolean, byte, char...)
â”œâ”€â”€ Controle   (if, else, for, while...)
â”œâ”€â”€ Acesso     (public, private, protected...)
â””â”€â”€ Outros     (new, return, this, super...)
```

## Separadores

### Caracteres Especiais

```
SEPARATORS
â”œâ”€â”€ { }    Blocos
â”œâ”€â”€ [ ]    Arrays
â”œâ”€â”€ ( )    ParÃ¢metros
â”œâ”€â”€ ;      Fim de statement
â”œâ”€â”€ ,      Separador
â””â”€â”€ .      Acesso a membros
```

## ConvenÃ§Ãµes

### Estilo de CÃ³digo

```
CODE STYLE
â”œâ”€â”€ Classes        PascalCase
â”œâ”€â”€ MÃ©todos        camelCase
â”œâ”€â”€ VariÃ¡veis      camelCase
â”œâ”€â”€ Constantes     UPPER_SNAKE_CASE
â””â”€â”€ Pacotes        lowercase
```

## Exemplos PrÃ¡ticos

### Classe Completa

```JAVA
package com.netrunner.core;

public class SecuritySystem {
    private static final int MAX_ATTEMPTS = 3;
    private int attemptCount;
    
    public SecuritySystem() {
        this.attemptCount = 0;
    }
    
    public boolean authenticate(String code) {
        attemptCount++;
        if (attemptCount > MAX_ATTEMPTS) {
            lockSystem();
            return false;
        }
        return validateCode(code);
    }
    
    private void lockSystem() {
        System.out.println("Sistema bloqueado!");
    }
    
    private boolean validateCode(String code) {
        return code.equals("MATRIX_1999");
    }
}
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [VariÃ¡veis](variables.html)

* [Operadores](operators.html)

* [Estruturas de Controle](control-flow.html)

[VariÃ¡veis](variables.html)

Tip:

"A sintaxe Ã© o protocolo que mantÃ©m a Matrix funcionando. Domine-a, e vocÃª dominarÃ¡ o sistema."



# VariÃ¡veis em Java

```
VARIABLES
â”œâ”€â”€ Tipos Primitivos
â”œâ”€â”€ Tipos de ReferÃªncia
â”œâ”€â”€ Type Casting
â””â”€â”€ Palavra-chave var
```

## Conceitos BÃ¡sicos

### DefiniÃ§Ã£o

Uma variÃ¡vel Ã© um local na memÃ³ria que armazena dados. Em Java, toda variÃ¡vel tem:

* Nome (identificador)

* Tipo

* Valor

### DeclaraÃ§Ã£o

```JAVA
// Sintaxe bÃ¡sica
tipoDaVariavel nomeDaVariavel;

// Com inicializaÃ§Ã£o
tipoDaVariavel nomeDaVariavel = valor;
```

## Categorias Principais

### Tipos Primitivos

```
PRIMITIVE TYPES
â”œâ”€â”€ NÃºmeros Inteiros (byte, short, int, long)
â”œâ”€â”€ NÃºmeros Decimais (float, double)
â”œâ”€â”€ Caractere (char)
â””â”€â”€ Booleano (boolean)
```

### Tipos de ReferÃªncia

```
REFERENCE TYPES
â”œâ”€â”€ Classes
â”œâ”€â”€ Interfaces
â”œâ”€â”€ Arrays
â””â”€â”€ Enums
```

## Escopo

### NÃ­veis

```
SCOPE LEVELS
â”œâ”€â”€ Classe (campos)
â”œâ”€â”€ MÃ©todo (variÃ¡veis locais)
â””â”€â”€ Bloco (variÃ¡veis de bloco)
```

### Exemplo

```JAVA
public class DataMatrix {
    private int nivelAcesso; // Escopo de classe
    
    public void processarDados() {
        int contador = 0; // Escopo de mÃ©todo
        
        for (int i = 0; i < 10; i++) { // i tem escopo de bloco
            // cÃ³digo aqui
        }
    }
}
```

## Modificadores

### Constantes

```JAVA
// Constante de classe
public static final int MAX_CONEXOES = 100;

// Constante local
final double PI = 3.14159;
```

### VariÃ¡veis EstÃ¡ticas

```JAVA
public class Sistema {
    static int contadorGlobal; // Compartilhada por todas instÃ¢ncias
    int contadorLocal; // EspecÃ­fica para cada instÃ¢ncia
}
```

## Boas PrÃ¡ticas

### Nomenclatura

```JAVA
// Bom
int userId;
String firstName;
boolean isActive;

// Evitar
int a;
String x;
boolean flag;
```

### InicializaÃ§Ã£o

```JAVA
// Valores padrÃ£o
int numero; // 0
boolean status; // false
String texto; // null

// InicializaÃ§Ã£o explÃ­cita (recomendado)
int numero = 0;
boolean status = false;
String texto = "";
```

## SubseÃ§Ãµes

* [Tipos Primitivos](primitive-types.html)

* [Tipos de ReferÃªncia](reference-types.html)

* [Type Casting](type-casting.html)

* [Palavra-chave var](var-keyword.html)

[Tipos Primitivos](primitive-types.html)

Tip:

"VariÃ¡veis sÃ£o como terminais na Matrix - pontos de acesso para manipular a realidade digital."



# Tipos Primitivos

```
PRIMITIVE DATA TYPES
â”œâ”€â”€ Inteiros
â”‚   â”œâ”€â”€ byte  (8 bits)
â”‚   â”œâ”€â”€ short (16 bits)
â”‚   â”œâ”€â”€ int   (32 bits)
â”‚   â””â”€â”€ long  (64 bits)
â”œâ”€â”€ Decimais
â”‚   â”œâ”€â”€ float  (32 bits)
â”‚   â””â”€â”€ double (64 bits)
â”œâ”€â”€ Caractere
â”‚   â””â”€â”€ char   (16 bits)
â””â”€â”€ LÃ³gico
    â””â”€â”€ boolean (1 bit)
```

## Tipos NumÃ©ricos Inteiros

### byte

```JAVA
// Range: -128 atÃ© 127
byte nivelPoder = 100;
byte codigoStatus = -50;
```

### short

```JAVA
// Range: -32,768 atÃ© 32,767
short populacao = 30000;
short temperatura = -200;
```

### int

```JAVA
// Range: -2^31 atÃ© 2^31-1
int usuarios = 1000000;
int pontuacao = 2147483647;
```

### long

```JAVA
// Range: -2^63 atÃ© 2^63-1
long populacaoMundial = 7800000000L;
long distanciaEspacial = 9223372036854775807L;
```

## Tipos NumÃ©ricos Decimais

### float

```JAVA
// PrecisÃ£o: 6-7 dÃ­gitos decimais
float taxa = 19.99f;
float temperatura = -273.15f;
```

### double

```JAVA
// PrecisÃ£o: 15-16 dÃ­gitos decimais
double pi = 3.141592653589793;
double velocidadeLuz = 299792458.0;
```

## Tipo Caractere

### char

```JAVA
// Unicode 16-bit
char nivel = 'A';
char simbolo = '$';
char unicode = '\u0041'; // 'A'
```

## Tipo Booleano

### boolean

```JAVA
// Valores: true ou false
boolean sistemaAtivo = true;
boolean acessoPermitido = false;
```

## Valores PadrÃ£o

### InicializaÃ§Ã£o AutomÃ¡tica

```
DEFAULT VALUES
â”œâ”€â”€ byte, short, int, long â†’ 0
â”œâ”€â”€ float, double â†’ 0.0
â”œâ”€â”€ char â†’ '\u0000'
â””â”€â”€ boolean â†’ false
```

## Limites e Constantes

### Valores MÃ¡ximos e MÃ­nimos

```JAVA
// Constantes Ãºteis
byte maxByte = Byte.MAX_VALUE;    // 127
int minInt = Integer.MIN_VALUE;   // -2147483648
long maxLong = Long.MAX_VALUE;    // 9223372036854775807
```

## Literais NumÃ©ricos

### RepresentaÃ§Ãµes

```JAVA
// Decimal
int decimal = 1234;

// Hexadecimal
int hexadecimal = 0xFF; // 255

// BinÃ¡rio
int binario = 0b1010; // 10

// Octal
int octal = 0757; // 495
```

## Separador de DÃ­gitos

### Uso do Underscore

```JAVA
// Melhorando legibilidade
long cartaoCredito = 1234_5678_9012_3456L;
int milhao = 1_000_000;
```

## ConsideraÃ§Ãµes de Performance

### Escolha do Tipo

```
PERFORMANCE TIPS
â”œâ”€â”€ Use int para loops
â”œâ”€â”€ Prefira double a float
â”œâ”€â”€ byte/short para arrays grandes
â””â”€â”€ boolean para flags
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [Tipos de ReferÃªncia](reference-types.html)

* [Type Casting](type-casting.html)

* [Operadores](operators.html)

[Tipos de ReferÃªncia](reference-types.html)

Tip:

"Os tipos primitivos sÃ£o como os Ã¡tomos da Matrix - as unidades fundamentais que compÃµem toda a realidade digital."



# Tipos de ReferÃªncia

```
REFERENCE TYPES
â”œâ”€â”€ Classes
â”œâ”€â”€ Interfaces
â”œâ”€â”€ Arrays
â””â”€â”€ Enums
```

## Classes

### DefiniÃ§Ã£o e Uso

```JAVA
// DeclaraÃ§Ã£o
String mensagem = new String("ConexÃ£o estabelecida");
StringBuilder buffer = new StringBuilder();

// Null Ã© permitido
String dados = null;
```

### Classes Comuns

```JAVA
// Wrapper classes
Integer numero = 42;
Double valor = 3.14;
Boolean flag = true;

// UtilitÃ¡rios
Date data = new Date();
Random gerador = new Random();
```

## Arrays

### DeclaraÃ§Ã£o e InicializaÃ§Ã£o

```JAVA
// Arrays unidimensionais
int[] numeros = new int[5];
String[] comandos = {"LOGIN", "EXECUTE", "LOGOUT"};

// Arrays multidimensionais
int[][] matriz = new int[3][3];
```

### ManipulaÃ§Ã£o

```JAVA
// Acessando elementos
int primeiro = numeros[0];

// Modificando elementos
numeros[1] = 42;

// Comprimento
int tamanho = numeros.length;
```

## Enums

### DefiniÃ§Ã£o

```JAVA
public enum NivelAcesso {
    ADMIN,
    USUARIO,
    CONVIDADO
}
```

### Uso

```JAVA
NivelAcesso nivel = NivelAcesso.ADMIN;

switch (nivel) {
    case ADMIN:
        System.out.println("Acesso total");
        break;
    case USUARIO:
        System.out.println("Acesso parcial");
        break;
    case CONVIDADO:
        System.out.println("Acesso limitado");
        break;
}
```

## Interfaces

### ImplementaÃ§Ã£o

```JAVA
public interface Conexao {
    void conectar();
    void desconectar();
}

public class ConexaoSegura implements Conexao {
    @Override
    public void conectar() {
        // ImplementaÃ§Ã£o
    }

    @Override
    public void desconectar() {
        // ImplementaÃ§Ã£o
    }
}
```

## DiferenÃ§as dos Primitivos

### CaracterÃ­sticas

```
REFERENCE VS PRIMITIVE
â”œâ”€â”€ Armazenamento (Heap vs Stack)
â”œâ”€â”€ Null permitido
â”œâ”€â”€ MÃ©todos disponÃ­veis
â””â”€â”€ Overhead de memÃ³ria
```

### Exemplo

```JAVA
// Primitivo
int x = 10;

// ReferÃªncia
Integer y = 10;
y.toString(); // MÃ©todos disponÃ­veis
y = null; // Permitido
```

## Garbage Collection

### Ciclo de Vida

```
OBJECT LIFECYCLE
â”œâ”€â”€ CriaÃ§Ã£o (new)
â”œâ”€â”€ ReferenciaÃ§Ã£o
â”œâ”€â”€ DesreferenciaÃ§Ã£o
â””â”€â”€ Coleta de lixo
```

### Exemplo

```JAVA
String texto = new String("temp"); // Objeto criado
texto = null; // Objeto elegÃ­vel para GC
```

## Collections Framework

### Tipos Principais

```JAVA
// List
List<String> lista = new ArrayList<>();

// Set
Set<Integer> conjunto = new HashSet<>();

// Map
Map<String, Integer> mapa = new HashMap<>();
```

## Boas PrÃ¡ticas

### RecomendaÃ§Ãµes

```
BEST PRACTICES
â”œâ”€â”€ Inicialize referÃªncias
â”œâ”€â”€ Use interfaces apropriadas
â”œâ”€â”€ Verifique null
â””â”€â”€ Libere recursos
```

### Exemplo

```JAVA
// VerificaÃ§Ã£o de null
if (objeto != null) {
    objeto.metodo();
}

// Try-with-resources
try (Scanner scanner = new Scanner(System.in)) {
    // Uso do scanner
}
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [Type Casting](type-casting.html)

* [Palavra-chave var](var-keyword.html)

* [Collections](collections-overview.html)

[Type Casting](type-casting.html)

Tip:

"Os tipos de referÃªncia sÃ£o como os programas da Matrix - entidades complexas que manipulam a realidade digital."



# Type Casting em Java

```
TYPE CASTING
â”œâ”€â”€ ImplÃ­cito (Widening)
â”œâ”€â”€ ExplÃ­cito (Narrowing)
â”œâ”€â”€ ReferÃªncia
â””â”€â”€ Autoboxing/Unboxing
```

## Casting ImplÃ­cito

### Widening Casting

```
WIDENING PATH
byte â†’ short â†’ int â†’ long â†’ float â†’ double
        char â†—
```

### Exemplos

```JAVA
// ConversÃµes automÃ¡ticas
byte byteNum = 100;
int intNum = byteNum; // byte para int

int intValue = 10;
double doubleValue = intNum; // int para double
```

## Casting ExplÃ­cito

### Narrowing Casting

```
NARROWING PATH
double â†’ float â†’ long â†’ int â†’ short â†’ byte
                        â†˜ char
```

### Exemplos

```JAVA
// ConversÃµes manuais
double doubleNum = 9.78;
int intNum = (int) doubleNum; // double para int

int largeNum = 130;
byte byteNum = (byte) largeNum; // int para byte
```

## Casting de ReferÃªncia

### Upcasting

```JAVA
// Classe pai para filho
class Animal {}
class Gato extends Animal {}

Animal animal = new Gato(); // Upcast automÃ¡tico
```

### Downcasting

```JAVA
// Filho para pai (requer verificaÃ§Ã£o)
Animal animal = new Gato();
if (animal instanceof Gato) {
    Gato gato = (Gato) animal; // Downcast explÃ­cito
}
```

## Autoboxing e Unboxing

### Autoboxing

```JAVA
// Primitivo para Wrapper
int primitivo = 42;
Integer wrapper = primitivo; // Autoboxing
```

### Unboxing

```JAVA
// Wrapper para primitivo
Integer wrapper = 42;
int primitivo = wrapper; // Unboxing
```

## VerificaÃ§Ãµes de Tipo

### instanceof

```JAVA
Object obj = "teste";
if (obj instanceof String) {
    String str = (String) obj;
    System.out.println(str.length());
}
```

### Pattern Matching (Java 16+)

```JAVA
Object obj = "teste";
if (obj instanceof String str) {
    System.out.println(str.length());
}
```

## ConversÃµes Comuns

### String Conversions

```JAVA
// String para nÃºmero
String strNum = "42";
int num = Integer.parseInt(strNum);
double dNum = Double.parseDouble("3.14");

// NÃºmero para String
String str1 = String.valueOf(42);
String str2 = Integer.toString(42);
```

## Perda de Dados

### Exemplos

```JAVA
// Perda de precisÃ£o
int x = 128;
byte b = (byte) x; // Overflow: -128

double pi = 3.14159;
int iPi = (int) pi; // Truncado: 3
```

## Boas PrÃ¡ticas

### RecomendaÃ§Ãµes

```
CASTING GUIDELINES
â”œâ”€â”€ Prefira casting implÃ­cito
â”œâ”€â”€ Verifique antes de downcast
â”œâ”€â”€ Evite casting numÃ©rico arriscado
â””â”€â”€ Use mÃ©todos de conversÃ£o apropriados
```

### Exemplo Seguro

```JAVA
// VerificaÃ§Ã£o de range
long longValue = 42L;
if (longValue >= Integer.MIN_VALUE && 
    longValue <= Integer.MAX_VALUE) {
    int intValue = (int) longValue;
}
```

## Casos Especiais

### Char Casting

```JAVA
// Char para nÃºmero
char ch = 'A';
int ascii = ch; // 65

// NÃºmero para char
int num = 66;
char character = (char) num; // 'B'
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [Palavra-chave var](var-keyword.html)

* [Operadores](operators.html)

* [Tipos de Dados](variables.html)

[Palavra-chave var](var-keyword.html)

Tip:

"O type casting Ã© como hackear a Matrix - transformando dados de uma forma para outra."



# Palavra-chave var

```
VAR KEYWORD
â”œâ”€â”€ InferÃªncia de Tipo
â”œâ”€â”€ RestriÃ§Ãµes
â”œâ”€â”€ Usos Comuns
â””â”€â”€ Boas PrÃ¡ticas
```

## IntroduÃ§Ã£o

### O que Ã© var?

```JAVA
// InferÃªncia de tipo local
var mensagem = "ConexÃ£o estabelecida";
var contador = 0;
var lista = new ArrayList<String>();
```

## InferÃªncia de Tipo

### Como Funciona

```JAVA
// O compilador infere o tipo
var numero = 42; // int
var texto = "Matrix"; // String
var decimal = 3.14; // double
```

### Tipos Inferidos

```JAVA
// Tipos complexos
var mapa = new HashMap<String, Integer>();
var executor = Executors.newFixedThreadPool(10);
var padrao = Pattern.compile("\\w+");
```

## RestriÃ§Ãµes

### Onde NÃ£o Usar

```JAVA
// NÃ£o permitido:
var campo; // Sem inicializaÃ§Ã£o
var = "valor"; // Sem nome
var[] array = new int[10]; // Arrays
var mÃ©todo() { } // Retorno de mÃ©todo
```

### LimitaÃ§Ãµes

```
RESTRICTIONS
â”œâ”€â”€ VariÃ¡veis de classe
â”œâ”€â”€ ParÃ¢metros de mÃ©todo
â”œâ”€â”€ Retorno de mÃ©todo
â””â”€â”€ Catch blocks
```

## Usos Comuns

### Loops

```JAVA
// IteraÃ§Ã£o em collections
for (var item : lista) {
    System.out.println(item);
}

// Loop tradicional
for (var i = 0; i < 10; i++) {
    // cÃ³digo
}
```

### Lambda

```JAVA
// Com var em parÃ¢metros (Java 11+)
Consumer<String> consumer = (@NonNull var s) -> 
    System.out.println(s);
```

### Try-with-resources

```JAVA
try (var arquivo = new FileInputStream
```



# Operadores em Java

## VisÃ£o Geral

```
OPERATOR TYPES
â”œâ”€â”€ AritmÃ©ticos (+, -, *, /, %)
â”œâ”€â”€ LÃ³gicos (&&, ||, !)
â””â”€â”€ Bit a Bit (&, |, ^, ~, <<, >>, >>>)
```

## Categorias Principais

### ClassificaÃ§Ã£o

```
OPERATOR CATEGORIES
â”œâ”€â”€ UnÃ¡rios (++, --, !, ~)
â”œâ”€â”€ BinÃ¡rios (+, -, *, /, &, |)
â””â”€â”€ TernÃ¡rio (?:)
```

## PrecedÃªncia

### Ordem de ExecuÃ§Ã£o

```
PRECEDENCE ORDER
â”œâ”€â”€ UnÃ¡rios (++, --, !)
â”œâ”€â”€ Multiplicativos (*, /, %)
â”œâ”€â”€ Aditivos (+, -)
â”œâ”€â”€ Shift (<<, >>, >>>)
â”œâ”€â”€ Relacionais (<, >, <=, >=)
â”œâ”€â”€ Igualdade (==, !=)
â”œâ”€â”€ Bit a Bit (&, ^, |)
â”œâ”€â”€ LÃ³gicos (&&, ||)
â””â”€â”€ AtribuiÃ§Ã£o (=, +=, -=, etc)
```

## PrÃ³ximos Passos

### TÃ³picos Detalhados

* [Operadores AritmÃ©ticos](arithmetic.html)

* [Operadores LÃ³gicos](logical.html)

* [Operadores Bit a Bit](bitwise.html)

[Operadores AritmÃ©ticos](arithmetic.html)

Tip:

"Os operadores sÃ£o como os comandos bÃ¡sicos da Matrix - eles transformam e manipulam os dados em sua forma mais fundamental."



# Operadores AritmÃ©ticos

## Operadores BÃ¡sicos

### OperaÃ§Ãµes Fundamentais

```JAVA
// AdiÃ§Ã£o
int soma = 5 + 3;        // 8

// SubtraÃ§Ã£o
int diferenca = 10 - 4;  // 6

// MultiplicaÃ§Ã£o
int produto = 3 * 4;     // 12

// DivisÃ£o
int quociente = 15 / 3;  // 5

// MÃ³dulo (resto)
int resto = 17 % 5;      // 2
```

## Incremento e Decremento

### PrÃ© e PÃ³s

```JAVA
int x = 5;
int y = ++x;  // x = 6, y = 6 (prÃ©-incremento)
int z = x++;  // z = 6, x = 7 (pÃ³s-incremento)

int a = 5;
int b = --a;  // a = 4, b = 4 (prÃ©-decremento)
int c = a--;  // c = 4, a = 3 (pÃ³s-decremento)
```

## Operadores Compostos

### AtribuiÃ§Ã£o com OperaÃ§Ã£o

```JAVA
int valor = 10;
valor += 5;   // valor = valor + 5
valor -= 3;   // valor = valor - 3
valor *= 2;   // valor = valor * 2
valor /= 4;   // valor = valor / 4
valor %= 3;   // valor = valor % 3
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [Operadores LÃ³gicos](logical.html)

* [Operadores Bit a Bit](bitwise.html)

* [ExpressÃµes](null)

[Operadores LÃ³gicos](logical.html)



# Operadores LÃ³gicos

## Operadores BÃ¡sicos

### Booleanos

```JAVA
// AND lÃ³gico (&&)
boolean and = true && false;  // false

// OR lÃ³gico (||)
boolean or = true || false;   // true

// NOT lÃ³gico (!)
boolean not = !true;         // false
```

## Curto-Circuito

### AvaliaÃ§Ã£o Otimizada

```JAVA
// AND com curto-circuito
if (obj != null && obj.getValue() > 0) {
    // Segundo termo sÃ³ Ã© avaliado se obj != null
}

// OR com curto-circuito
if (cache.containsKey(key) || loadFromDatabase()) {
    // loadFromDatabase() sÃ³ Ã© chamado se necessÃ¡rio
}
```

## Operadores Bit a Bit Booleanos

### OperaÃ§Ãµes sem Curto-Circuito

```JAVA
// AND bit a bit (&)
boolean bitwiseAnd = true & false;

// OR bit a bit (|)
boolean bitwiseOr = true | false;

// XOR bit a bit (^)
boolean xor = true ^ false;
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [Operadores Bit a Bit](bitwise.html)

* [Estruturas Condicionais](conditionals.html)

* [ExpressÃµes Booleanas](null)

[Operadores Bit a Bit](bitwise.html)



# Operadores Bit a Bit

## Operadores BÃ¡sicos

### ManipulaÃ§Ã£o de Bits

```JAVA
// AND bit a bit (&)
int and = 12 & 5;   // 1100 & 0101 = 0100 (4)

// OR bit a bit (|)
int or = 12 | 5;    // 1100 | 0101 = 1101 (13)

// XOR bit a bit (^)
int xor = 12 ^ 5;   // 1100 ^ 0101 = 1001 (9)

// NOT bit a bit (~)
int not = ~12;      // ~1100 = ...11110011
```

## Operadores de Deslocamento

### Shift de Bits

```JAVA
// Shift left (<<)
int left = 8 << 2;    // 1000 -> 100000 (32)

// Shift right (>>)
int right = 8 >> 2;   // 1000 -> 0010 (2)

// Shift right sem sinal (>>>)
int unsignedRight = -8 >>> 2;  // Preenche com 0
```

## AplicaÃ§Ãµes PrÃ¡ticas

### Uso Comum

```JAVA
// Flags de bit
int FLAG_READ = 1;     // 0001
int FLAG_WRITE = 2;    // 0010
int FLAG_EXECUTE = 4;  // 0100

// Combinando flags
int permissions = FLAG_READ | FLAG_WRITE;  // 0011

// Verificando flags
boolean canRead = (permissions & FLAG_READ) != 0;
```

### OtimizaÃ§Ãµes

```JAVA
// MultiplicaÃ§Ã£o por 2
int multiply = num << 1;  // Equivalente a num * 2

// DivisÃ£o por 2
int divide = num >> 1;    // Equivalente a num / 2

// AlternÃ¢ncia de bit
int toggleBit = num ^ (1 << position);
```

## MÃ¡scaras de Bits

### TÃ©cnicas de Mascaramento

```JAVA
// MÃ¡scara para Ãºltimos 8 bits
int mask = 0xFF;

// Aplicando mÃ¡scara
int lastByte = number & mask;

// Limpando bits
int clearBits = number & ~mask;
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [Tipos Primitivos](primitive-types.html)

* [Operadores LÃ³gicos](logical.html)

[Tipos Primitivos](primitive-types.html)

Tip:

"Os operadores bit a bit sÃ£o como os comandos de baixo nÃ­vel da Matrix - manipulando a realidade digital bit por bit."



# InternacionalizaÃ§Ã£o (i18n)

## Conceitos BÃ¡sicos

### Locale

```JAVA
// Criando Locales
Locale brLocale = new Locale("pt", "BR");
Locale usLocale = Locale.US;
Locale currentLocale = Locale.getDefault();

// Definindo Locale padrÃ£o
Locale.setDefault(brLocale);
```

### ResourceBundle

```JAVA
// Arquivo: messages_pt_BR.properties
// mensagem=OlÃ¡, {0}!

// Arquivo: messages_en_US.properties
// message=Hello, {0}!

ResourceBundle bundle = ResourceBundle.getBundle("messages", brLocale);
String msg = bundle.getString("mensagem");
```

## Textos e Mensagens

### Properties Files

```PROPERTIES
# messages_pt_BR.properties
welcome=Bem-vindo
error.notfound=NÃ£o encontrado
app.title=Minha AplicaÃ§Ã£o

# messages_en_US.properties
welcome=Welcome
error.notfound=Not found
app.title=My Application
```

### Uso em CÃ³digo

```JAVA
public class I18nDemo {
    private ResourceBundle messages;
    
    public void setLocale(Locale locale) {
        messages = ResourceBundle.getBundle("messages", locale);
    }
    
    public String getMessage(String key) {
        return messages.getString(key);
    }
}
```

## Boas PrÃ¡ticas

### OrganizaÃ§Ã£o

* Separar textos em arquivos properties

* Usar chaves hierÃ¡rquicas

* Manter consistÃªncia entre traduÃ§Ãµes

* Documentar contexto das mensagens

### Dicas de ImplementaÃ§Ã£o

```JAVA
// Uso de MessageFormat
String pattern = messages.getString("welcome.user");
MessageFormat formatter = new MessageFormat(pattern);
String result = formatter.format(new Object[]{"JoÃ£o"});

// Fallback para locale padrÃ£o
try {
    String msg = messages.getString("key");
} catch (MissingResourceException e) {
    msg = defaultMessages.getString("key");
}
```

## Frameworks e Ferramentas

### Spring Framework

```JAVA
@Configuration
public class I18nConfig {
    @Bean
    public MessageSource messageSource() {
        ResourceBundleMessageSource source = new ResourceBundleMessageSource();
        source.setBasenames("messages");
        source.setDefaultEncoding("UTF-8");
        return source;
    }
}
```

### Ferramentas de GestÃ£o

* POEditor

* Crowdin

* Lokalise

* Trados

## Testes

### Testando InternacionalizaÃ§Ã£o

```JAVA
@Test
public void testMessageInDifferentLocales() {
    ResourceBundle ptBR = ResourceBundle.getBundle("messages", new Locale("pt", "BR"));
    ResourceBundle enUS = ResourceBundle.getBundle("messages", Locale.US);
    
    assertEquals("OlÃ¡", ptBR.getString("greeting"));
    assertEquals("Hello", enUS.getString("greeting"));
}
```

## PrÃ³ximos Passos

* [FormataÃ§Ã£o de Datas](date-formatting.html)

* [FormataÃ§Ã£o de NÃºmeros](number-formatting.html)



# FormataÃ§Ã£o de Datas

## DateTimeFormatter

### PadrÃµes BÃ¡sicos

```JAVA
// Formatadores predefinidos
DateTimeFormatter isoDate = DateTimeFormatter.ISO_DATE;
DateTimeFormatter isoTime = DateTimeFormatter.ISO_TIME;
DateTimeFormatter isoDateTime = DateTimeFormatter.ISO_DATE_TIME;

// FormataÃ§Ã£o bÃ¡sica
LocalDate date = LocalDate.now();
String formatted = date.format(isoDate);  // 2024-01-20
```

### PadrÃµes Customizados

```JAVA
// Criando formatadores customizados
DateTimeFormatter custom = DateTimeFormatter.ofPattern("dd/MM/yyyy");
DateTimeFormatter withTime = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");

// Aplicando formataÃ§Ã£o
LocalDateTime now = LocalDateTime.now();
String result = now.format(custom);       // 20/01/2024
```

## LocalizaÃ§Ã£o

### FormataÃ§Ã£o por Locale

```JAVA
// Formatadores localizados
DateTimeFormatter brFormat = 
    DateTimeFormatter.ofPattern("dd/MM/yyyy")
                    .withLocale(new Locale("pt", "BR"));

DateTimeFormatter usFormat = 
    DateTimeFormatter.ofPattern("MM/dd/yyyy")
                    .withLocale(Locale.US);
```

### Nomes Localizados

```JAVA
// Meses e dias da semana
DateTimeFormatter monthFormat = 
    DateTimeFormatter.ofPattern("MMMM", new Locale("pt", "BR"));
String mes = monthFormat.format(LocalDate.now());  // "janeiro"
```

## Parsing

### ConversÃ£o de Strings

```JAVA
// Parse bÃ¡sico
String dateStr = "2024-01-20";
LocalDate date = LocalDate.parse(dateStr);

// Parse com formato especÃ­fico
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
LocalDate customDate = LocalDate.parse("20/01/2024", formatter);
```

### Tratamento de Erros

```JAVA
try {
    LocalDate date = LocalDate.parse("data-invÃ¡lida");
} catch (DateTimeParseException e) {
    System.err.println("Formato de data invÃ¡lido");
}
```

## Casos Especiais

### Zonas de Tempo

```JAVA
// FormataÃ§Ã£o com timezone
ZonedDateTime zdt = ZonedDateTime.now();
DateTimeFormatter zoneFormat = 
    DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm z");
String withZone = zdt.format(zoneFormat);  // "20/01/2024 15:30 BRT"
```

### PerÃ­odos e DuraÃ§Ãµes

```JAVA
// Formatando perÃ­odos
Period period = Period.between(
    LocalDate.of(2023, 1, 1),
    LocalDate.of(2024, 1, 1)
);
// P1Y (ISO-8601)

// Formatando duraÃ§Ãµes
Duration duration = Duration.between(
    LocalDateTime.now(),
    LocalDateTime.now().plusHours(2)
);
// PT2H (ISO-8601)
```

## Boas PrÃ¡ticas

### Constantes de Formato

```JAVA
public class DateUtils {
    public static final DateTimeFormatter BR_DATE = 
        DateTimeFormatter.ofPattern("dd/MM/yyyy");
    
    public static final DateTimeFormatter BR_DATE_TIME = 
        DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
}
```

### ValidaÃ§Ã£o

```JAVA
public boolean isValidDate(String dateStr, DateTimeFormatter formatter) {
    try {
        LocalDate.parse(dateStr, formatter);
        return true;
    } catch (DateTimeParseException e) {
        return false;
    }
}
```

## PrÃ³ximos Passos

* [FormataÃ§Ã£o de NÃºmeros](number-formatting.html)

* [InternacionalizaÃ§Ã£o](i18n.html)



# FormataÃ§Ã£o de NÃºmeros

## NumberFormat

### FormataÃ§Ã£o BÃ¡sica

```JAVA
// Formatadores bÃ¡sicos
NumberFormat nf = NumberFormat.getInstance();
NumberFormat currencyFormat = NumberFormat.getCurrencyInstance();
NumberFormat percentFormat = NumberFormat.getPercentInstance();

// Exemplos
double number = 1234.56;
String formatted = nf.format(number);          // "1,234.56"
String currency = currencyFormat.format(number);// "$1,234.56"
String percent = percentFormat.format(0.75);   // "75%"
```

### LocalizaÃ§Ã£o

```JAVA
// Formatadores localizados
Locale brLocale = new Locale("pt", "BR");
NumberFormat brCurrency = NumberFormat.getCurrencyInstance(brLocale);
String brValue = brCurrency.format(1234.56);   // "R$ 1.234,56"

Locale frLocale = new Locale("fr", "FR");
NumberFormat frCurrency = NumberFormat.getCurrencyInstance(frLocale);
String frValue = frCurrency.format(1234.56);   // "1 234,56 â‚¬"
```

## DecimalFormat

### PadrÃµes Customizados

```JAVA
// PadrÃµes de formataÃ§Ã£o
DecimalFormat df = new DecimalFormat("#,###.##");
String num = df.format(1234567.89);    // "1,234,567.89"

// Zeros Ã  esquerda
DecimalFormat df2 = new DecimalFormat("000000.00");
String padded = df2.format(123.4);     // "000123.40"

// Sufixos e prefixos
DecimalFormat df3 = new DecimalFormat("â‚¬ #,###.00");
String euro = df3.format(1234.56);     // "â‚¬ 1,234.56"
```

### SÃ­mbolos Customizados

```JAVA
DecimalFormatSymbols symbols = new DecimalFormatSymbols(Locale.US);
symbols.setDecimalSeparator(',');
symbols.setGroupingSeparator('.');

DecimalFormat custom = new DecimalFormat("#,###.##", symbols);
String result = custom.format(1234.56); // "1.234,56"
```

## Parsing

### ConversÃ£o de Strings

```JAVA
// Parse bÃ¡sico
NumberFormat nf = NumberFormat.getInstance();
Number num = nf.parse("1,234.56");

// Parse com locale
NumberFormat frFormat = NumberFormat.getInstance(Locale.FRANCE);
Number frNum = frFormat.parse("1 234,56");

// Tratamento de erros
try {
    Number value = nf.parse("invalid");
} catch (ParseException e) {
    System.err.println("Formato invÃ¡lido");
}
```

## Casos Especiais

### NÃºmeros CientÃ­ficos

```JAVA
// NotaÃ§Ã£o cientÃ­fica
DecimalFormat scientific = new DecimalFormat("0.###E0");
String sci = scientific.format(123456.789); // "1.235E5"

// PrecisÃ£o customizada
DecimalFormat precise = new DecimalFormat("0.000000");
String precision = precise.format(Math.PI); // "3.141593"
```

### Arredondamento

```JAVA
DecimalFormat df = new DecimalFormat("#,###.##");
df.setRoundingMode(RoundingMode.HALF_UP);

String rounded = df.format(123.456);  // "123.46"
```

## Boas PrÃ¡ticas

### Constantes de Formato

```JAVA
public class NumberUtils {
    public static final DecimalFormat MONEY_FORMAT = 
        new DecimalFormat("#,##0.00");
    
    public static final DecimalFormat PERCENT_FORMAT = 
        new DecimalFormat("#.##%");
}
```

### ValidaÃ§Ã£o

```JAVA
public boolean isValidNumber(String numStr, NumberFormat format) {
    try {
        format.parse(numStr);
        return true;
    } catch (ParseException e) {
        return false;
    }
}
```

## Frameworks e Bibliotecas

### Java Money API

```JAVA
// Usando JavaMoney
MonetaryAmount amount = Money.of(1234.56, "USD");
MonetaryAmountFormat format = 
    MonetaryFormats.getAmountFormat(Locale.US);
String formatted = format.format(amount);
```

## PrÃ³ximos Passos

* [InternacionalizaÃ§Ã£o](i18n.html)

* [FormataÃ§Ã£o de Datas](date-formatting.html)



# Strings em Java

## VisÃ£o Geral

```
STRING CONCEPTS
â”œâ”€â”€ Imutabilidade
â”œâ”€â”€ Pool de Strings
â”œâ”€â”€ ConcatenaÃ§Ã£o
â””â”€â”€ ComparaÃ§Ã£o
```

## CriaÃ§Ã£o de Strings

### Formas de InicializaÃ§Ã£o

```JAVA
// Literal
String comando = "EXECUTE";

// Construtor
String status = new String("ONLINE");

// Pool vs Heap
String s1 = "MATRIX";         // Pool de Strings
String s2 = new String("MATRIX"); // Heap
```

## OperaÃ§Ãµes BÃ¡sicas

### ManipulaÃ§Ã£o

```JAVA
String codigo = "NET_RUNNER";
int tamanho = codigo.length();     // 10
char primeiro = codigo.charAt(0);   // 'N'
String sub = codigo.substring(0,3); // "NET"
```

## PrÃ³ximos Passos

### TÃ³picos Detalhados

* [MÃ©todos de String](string-methods.html)

* [StringBuilder](string-builder.html)

* [FormataÃ§Ã£o de Strings](string-formatting.html)

[MÃ©todos de String](string-methods.html)

Tip:

"Strings sÃ£o como os dados criptografados da Matrix - precisam ser manipulados com precisÃ£o e eficiÃªncia."



# MÃ©todos de String

## MÃ©todos de Busca

### LocalizaÃ§Ã£o

```JAVA
String texto = "CYBERPUNK_2077";

// Busca
int posicao = texto.indexOf("PUNK");    // 5
int ultimo = texto.lastIndexOf("7");     // 12
boolean contem = texto.contains("CYBER"); // true
```

## MÃ©todos de TransformaÃ§Ã£o

### ModificaÃ§Ã£o

```JAVA
String codigo = "NetRunner";

// TransformaÃ§Ãµes
String maiusculo = codigo.toUpperCase(); // "NETRUNNER"
String minusculo = codigo.toLowerCase(); // "netrunner"
String semEspacos = codigo.trim();      // Remove espaÃ§os
String[] partes = codigo.split("R");    // ["Net", "unner"]
```

## MÃ©todos de ComparaÃ§Ã£o

### VerificaÃ§Ã£o

```JAVA
String s1 = "MATRIX";
String s2 = "matrix";

// ComparaÃ§Ãµes
boolean igual = s1.equals(s2);           // false
boolean ignoraCase = s1.equalsIgnoreCase(s2); // true
int comparacao = s1.compareTo(s2);       // ComparaÃ§Ã£o lexicogrÃ¡fica
```

## MÃ©todos de SubstituiÃ§Ã£o

### AlteraÃ§Ã£o

```JAVA
String log = "Error:404:NotFound";

// SubstituiÃ§Ãµes
String novo = log.replace(":", "-");     // "Error-404-NotFound"
String primeiro = log.replaceFirst(":", "-"); // "Error-404:NotFound"
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [StringBuilder](string-builder.html)

* [FormataÃ§Ã£o de Strings](string-formatting.html)

* [ExpressÃµes Regulares](null)

[StringBuilder](string-builder.html)



# StringBuilder

## Conceitos BÃ¡sicos

### CriaÃ§Ã£o

```JAVA
// InicializaÃ§Ã£o
StringBuilder buffer = new StringBuilder();
StringBuilder preset = new StringBuilder("INIT:");
StringBuilder sized = new StringBuilder(32);
```

## OperaÃ§Ãµes Principais

### ManipulaÃ§Ã£o

```JAVA
StringBuilder log = new StringBuilder();

// AdiÃ§Ã£o
log.append("STATUS: ")    // ConcatenaÃ§Ã£o
   .append("ONLINE")      // Encadeamento
   .append(" - ")
   .append(2077);

// InserÃ§Ã£o
log.insert(0, "[LOG] ");  // InÃ­cio
log.insert(6, "DEBUG ");  // Meio

// RemoÃ§Ã£o
log.delete(0, 5);         // Range
log.deleteCharAt(10);     // Caractere Ãºnico

// ReversÃ£o
log.reverse();            // Inverte a string
```

## Performance

### ComparaÃ§Ã£o com String

```JAVA
// MÃ¡ prÃ¡tica (String)
String result = "";
for (int i = 0; i < 1000; i++) {
    result += "Data";  // Cria nova String cada vez
}

// Boa prÃ¡tica (StringBuilder)
StringBuilder builder = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    builder.append("Data");  // Modifica o mesmo objeto
}
String result = builder.toString();
```

## MÃ©todos Ãšteis

### Funcionalidades Adicionais

```JAVA
StringBuilder cmd = new StringBuilder("EXECUTE");

// Capacidade
int cap = cmd.capacity();     // Capacidade atual
cmd.ensureCapacity(100);      // Garante capacidade mÃ­nima

// ModificaÃ§Ã£o
cmd.setCharAt(0, 'e');       // Modifica caractere
cmd.setLength(4);            // Trunca ou expande
cmd.replace(0, 2, "RE");     // Substitui range
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [FormataÃ§Ã£o de Strings](string-formatting.html)

* [StringBuffer](null)

* [Performance](null)

[FormataÃ§Ã£o de Strings](string-formatting.html)



# FormataÃ§Ã£o de Strings

## String.format()

### Sintaxe BÃ¡sica

```JAVA
// FormataÃ§Ã£o bÃ¡sica
String msg = String.format("UsuÃ¡rio: %s, ID: %d", "Neo", 1337);

// NÃºmeros
String num = String.format("%.2f", 3.14159);  // "3.14"
String hex = String.format("%x", 255);        // "ff"
```

## System.out.printf()

### SaÃ­da Formatada

```JAVA
// ImpressÃ£o formatada
System.out.printf("Status: %s%n", "ONLINE");

// MÃºltiplos argumentos
System.out.printf("X: %d, Y: %d%n", 10, 20);
```

## Especificadores de Formato

### Tipos Comuns

```JAVA
// Strings e caracteres
%s  // String
%c  // Caractere
%n  // Nova linha

// NÃºmeros
%d  // Inteiro decimal
%f  // Ponto flutuante
%e  // NotaÃ§Ã£o cientÃ­fica
%x  // Hexadecimal
```

## Flags de FormataÃ§Ã£o

### Modificadores

```JAVA
// Alinhamento e preenchimento
String align = String.format("|%-10s|", "LEFT");   // Alinha Ã  esquerda
String pad = String.format("%05d", 42);            // "00042"

// NÃºmeros
String prec = String.format("%.3f", 3.14159);      // "3.142"
String group = String.format("%,d", 1000000);      // "1,000,000"
```

## MessageFormat

### FormataÃ§Ã£o Complexa

```JAVA
import java.text.MessageFormat;

// PadrÃ£o de mensagem
String pattern = "User {0} logged in at {1}";
String msg = MessageFormat.format(pattern, "Trinity", "12:00");

// NÃºmeros e datas
MessageFormat mf = new MessageFormat("Balance: {0,number,currency}");
String balance = mf.format(new Object[]{1234.56});
```

## PrÃ³ximos Passos

### TÃ³picos Relacionados

* [InternacionalizaÃ§Ã£o](i18n.html)

* [FormataÃ§Ã£o de Datas](date-formatting.html)

* [FormataÃ§Ã£o de NÃºmeros](number-formatting.html)

[InternacionalizaÃ§Ã£o](i18n.html)

Tip:

"A formataÃ§Ã£o de strings Ã© como a interface da Matrix - a forma como apresentamos os dados ao mundo real."



# Projetos BÃ¡sicos

Os projetos nesta seÃ§Ã£o aplicam os conceitos fundamentais de Java em cenÃ¡rios prÃ¡ticos inspirados no universo cyberpunk.

## VisÃ£o Geral dos Projetos

```MERMAID
graph LR
    A[Matrix Code Generator] --> D[VisualizaÃ§Ã£o de Dados]
    B[Cyber Deck Simulator] --> E[Interface de Comando]
    C[Data Encryptor] --> F[SeguranÃ§a de Dados]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#33ccff
    style E fill:#1a1a1a,stroke:#33ccff
    style F fill:#1a1a1a,stroke:#33ccff
```

## Objetivos de Aprendizado

### Matrix Code Generator

* ManipulaÃ§Ã£o de strings e caracteres

* Loops e controle de fluxo

* TemporizaÃ§Ã£o bÃ¡sica

* SaÃ­da formatada no console

* Arrays unidimensionais e bidimensionais

### Cyber Deck Simulator

* Entrada e saÃ­da do usuÃ¡rio

* Estruturas condicionais

* Comandos e argumentos

* FormataÃ§Ã£o de terminal

* Processamento de strings

### Data Encryptor

* OperaÃ§Ãµes com bytes

* Algoritmos bÃ¡sicos

* ManipulaÃ§Ã£o de arquivos

* GeraÃ§Ã£o de chaves

* ConversÃ£o de tipos

## Habilidades Desenvolvidas

| Projeto |Conceitos Principais |Dificuldade |
----------------------------------------------
| Matrix Code Generator |Strings, Arrays, Loops |â­â­ |
| Cyber Deck Simulator |I/O, Condicionais |â­â­ |
| Data Encryptor |Bytes, Arquivos |â­â­â­ |

## PrÃ©-requisitos

```JAVA
// Conhecimentos necessÃ¡rios
public class Prerequisites {
    // Sintaxe bÃ¡sica
    String[] fundamentals = {
        "VariÃ¡veis",
        "Tipos de dados",
        "Operadores",
        "Estruturas de controle"
    };
    
    // Ambiente de desenvolvimento
    boolean ready = hasJDK() && hasIDE();
}
```

## Estrutura dos Projetos

```
PROJETO
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/
â”‚   â”‚   â””â”€â”€ java/
â”‚   â”‚       â””â”€â”€ com/
â”‚   â”‚           â””â”€â”€ netrunner/
â”‚   â”‚               â””â”€â”€ project/
â”‚   â”‚                   â”œâ”€â”€ Main.java
â”‚   â”‚                   â””â”€â”€ core/
â”‚   â””â”€â”€ test/
â”‚       â””â”€â”€ java/
â””â”€â”€ README.md
```

## Dicas de ImplementaÃ§Ã£o

* Comece com uma versÃ£o bÃ¡sica funcional

* Adicione recursos gradualmente

* Teste cada nova funcionalidade

* Mantenha o cÃ³digo organizado

* Documente as partes importantes

## Desafios Extras

### Matrix Code Generator

* Adicionar cores diferentes

* Implementar velocidades variÃ¡veis

* Criar padrÃµes personalizados

### Cyber Deck Simulator

* Adicionar novos comandos

* Implementar histÃ³rico

* Criar aliases para comandos

### Data Encryptor

* Suportar mÃºltiplos algoritmos

* Adicionar compressÃ£o

* Implementar assinaturas digitais

## Recursos Adicionais

### ReferÃªncias

* [Java Documentation](https://docs.oracle.com/en/java/)

* [Console Colors](https://stackoverflow.com/questions/5762491/how-to-print-color-in-console-using-system-out-println)

* [File Handling in Java](https://www.w3schools.com/java/java_files.asp)

### Ferramentas Ãšteis

* Terminal: [JLine](https://github.com/jline/jline3)

* Criptografia: [Bouncy Castle](https://www.bouncycastle.org/)

* Logging: [SLF4J](http://www.slf4j.org/)

## PrÃ³ximos Passos

ApÃ³s completar estes projetos bÃ¡sicos, vocÃª estarÃ¡ preparado para:

* Explorar projetos mais complexos

* Aprender sobre design patterns

* Trabalhar com bibliotecas externas

* Desenvolver aplicaÃ§Ãµes mais robustas

```

## ConclusÃ£o

Estes projetos fornecem uma base sÃ³lida em programaÃ§Ã£o Java atravÃ©s de aplicaÃ§Ãµes prÃ¡ticas e envolventes. Cada projeto pode ser expandido e personalizado de acordo com seus interesses e necessidades de aprendizado.
```



# Calculadora BÃ¡sica

## Conceitos Aplicados

* VariÃ¡veis primitivas (`int`, `double`)

* Operadores aritmÃ©ticos

* Type casting

* Palavra-chave `var`

## ImplementaÃ§Ã£o Base

```JAVA
public class Calculator {
    // Usando tipos primitivos para armazenar resultados
    private double result;
    
    // DemonstraÃ§Ã£o de operadores aritmÃ©ticos bÃ¡sicos
    public double add(double a, double b) {
        result = a + b;
        return result;
    }
    
    public double subtract(double a, double b) {
        result = a - b;
        return result;
    }
    
    // Exemplo de casting implÃ­cito
    public double multiply(int a, double b) {
        result = a * b; // int Ã© automaticamente convertido para double
        return result;
    }
    
    // DemonstraÃ§Ã£o de var com inferÃªncia de tipo
    public double divide(double a, double b) {
        var quotient = a / b; // var infere double
        result = quotient;
        return result;
    }
}
```

## ExercÃ­cios Propostos

1. Implementar operaÃ§Ãµes com diferentes tipos numÃ©ricos

2. Praticar conversÃµes explÃ­citas entre tipos

3. Explorar precedÃªncia de operadores

4. Usar var em diferentes contextos

## Desafios

1. Adicionar operaÃ§Ãµes com nÃºmeros inteiros e decimais

2. Implementar conversÃµes entre tipos numÃ©ricos

3. Criar operaÃ§Ãµes com diferentes precedÃªncias



# Conversor de Temperatura

## Conceitos Aplicados

* Tipos primitivos (`double`)

* Operadores aritmÃ©ticos

* Type casting

* Operadores lÃ³gicos

## ImplementaÃ§Ã£o Base

```JAVA
public class TemperatureConverter {
    // DemonstraÃ§Ã£o de constantes com tipos primitivos
    private static final double ABSOLUTE_ZERO_C = -273.15;
    
    // Uso de operadores aritmÃ©ticos e type casting
    public double celsiusToFahrenheit(double celsius) {
        return (celsius * 9/5) + 32;
    }
    
    public double fahrenheitToCelsius(double fahrenheit) {
        return (fahrenheit - 32) * 5/9;
    }
    
    // DemonstraÃ§Ã£o de operadores lÃ³gicos
    public boolean isValidTemperature(double celsius) {
        return celsius >= ABSOLUTE_ZERO_C;
    }
}
```

## ExercÃ­cios Propostos

1. Trabalhar com diferentes escalas de precisÃ£o

2. Implementar validaÃ§Ãµes usando operadores lÃ³gicos

3. Praticar conversÃµes entre tipos numÃ©ricos

4. Explorar formataÃ§Ã£o de nÃºmeros decimais

## Desafios

1. Adicionar validaÃ§Ãµes de temperatura

2. Implementar arredondamento de resultados

3. Criar verificaÃ§Ãµes de limites fÃ­sicos



# Manipulador de Strings

## Conceitos Aplicados

* String como tipo de referÃªncia

* MÃ©todos de String

* StringBuilder

* String formatting

## ImplementaÃ§Ã£o Base

```JAVA
public class StringManipulator {
    // DemonstraÃ§Ã£o de String como tipo de referÃªncia
    private String text;
    
    public StringManipulator(String text) {
        this.text = text;
    }
    
    // Uso de mÃ©todos de String
    public String toUpperCase() {
        return text.toUpperCase();
    }
    
    // DemonstraÃ§Ã£o de StringBuilder
    public String reverse() {
        StringBuilder builder = new StringBuilder(text);
        return builder.reverse().toString();
    }
    
    // Exemplo de String formatting
    public String format() {
        return String.format("Texto: %s, Tamanho: %d", 
                           text, text.length());
    }
}
```

## ExercÃ­cios Propostos

1. Explorar mÃ©todos da classe String

2. Praticar concatenaÃ§Ã£o com StringBuilder

3. Implementar diferentes formatos de string

4. Trabalhar com substrings e caracteres

## Desafios

1. Criar diferentes formatos de saÃ­da

2. Implementar manipulaÃ§Ãµes de texto

3. Otimizar operaÃ§Ãµes com StringBuilder



# Controle de Fluxo

![Control Flow Banner](control-flow-banner.png)

```
>> Inicializando mÃ³dulo de controle...
>> Carregando padrÃµes de decisÃ£o...
>> Estabelecendo loops de execuÃ§Ã£o...
```

## VisÃ£o Geral

O controle de fluxo Ã© fundamental para direcionar a execuÃ§Ã£o do seu cÃ³digo. Como um netrunner navegando pela matrix, vocÃª precisa tomar decisÃµes e repetir aÃ§Ãµes de forma eficiente.

```MERMAID
graph TD
    A[Entrada] --> B{DecisÃ£o}
    B -->|CondiÃ§Ã£o 1| C[ExecuÃ§Ã£o A]
    B -->|CondiÃ§Ã£o 2| D[ExecuÃ§Ã£o B]
    C --> E[PrÃ³ximo Passo]
    D --> E
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#00ff00
```

## Elementos Principais

### 1. Estruturas Condicionais

* if/else

* switch/case

* operador ternÃ¡rio

### 2. Estruturas de RepetiÃ§Ã£o

* while

* do-while

* for

* for-each

### 3. Controle de Fluxo

* break

* continue

* return

## Exemplo PrÃ¡tico

```JAVA
public class AccessControl {
    private static final int MAX_ATTEMPTS = 3;
    
    public void validateAccess(String code) {
        int attempts = 0;
        
        while (attempts < MAX_ATTEMPTS) {
            if (code.equals("MATRIX")) {
                System.out.println("Acesso concedido");
                return;
            } else {
                attempts++;
                if (attempts == MAX_ATTEMPTS) {
                    System.out.println("Sistema bloqueado");
                    break;
                }
                System.out.println("Tentativa " + attempts);
                continue;
            }
        }
    }
}
```

## PadrÃµes de Uso

### Estrutura Condicional

```JAVA
if (condicao) {
    // cÃ³digo para condiÃ§Ã£o verdadeira
} else if (outraCondicao) {
    // cÃ³digo para outra condiÃ§Ã£o
} else {
    // cÃ³digo para nenhuma condiÃ§Ã£o verdadeira
}
```

### Loop com For

```JAVA
for (int i = 0; i < 10; i++) {
    // cÃ³digo a ser repetido
    if (condicaoParada) {
        break;
    }
}
```

### Switch Expression (Java 14+)

```JAVA
String status = switch (code) {
    case 200 -> "Success";
    case 404 -> "Not Found";
    case 500 -> "Server Error";
    default -> "Unknown";
};
```

## Boas PrÃ¡ticas

1. Clareza nas CondiÃ§Ãµes

* Use nomes descritivos

* Evite negaÃ§Ãµes complexas

* Mantenha condiÃ§Ãµes simples

2. Estrutura dos Loops

* Defina condiÃ§Ãµes de parada claras

* Evite loops infinitos

* Use o tipo correto de loop

3. OtimizaÃ§Ã£o

* Minimize aninhamentos

* Use break/continue com critÃ©rio

* Prefira switch para mÃºltiplas condiÃ§Ãµes

## PrÃ³ximos Passos

Explore cada conceito em detalhes:

* [Condicionais](conditionals.html)

* [Loops](loops.html)

* [Switch Expressions](switch-expressions.html)

* [Pattern Matching](pattern-matching.html)

[Condicionais](conditionals.html)

Tip:

"O controle de fluxo Ã© como navegar pela Matrix - vocÃª precisa saber quando dobrar as regras e quando quebrÃ¡-las."



# Estruturas Condicionais

```
>> Inicializando sistema de decisÃ£o...
>> Carregando Ã¡rvores lÃ³gicas...
>> Estabelecendo caminhos de execuÃ§Ã£o...
```

## VisÃ£o Geral

As estruturas condicionais sÃ£o como os checkpoints da Matrix - elas determinam quais caminhos seu cÃ³digo pode seguir.

## Estruturas BÃ¡sicas

### 1. if-else

```JAVA
if (condicao) {
    // cÃ³digo executado se verdadeiro
} else {
    // cÃ³digo executado se falso
}
```

#### Exemplo PrÃ¡tico

```JAVA
int securityLevel = 5;
if (securityLevel >= 4) {
    System.out.println("Acesso concedido ao mainframe");
} else {
    System.out.println("Acesso negado");
}
```

### 2. else-if

```JAVA
if (condicao1) {
    // cÃ³digo para condiÃ§Ã£o 1
} else if (condicao2) {
    // cÃ³digo para condiÃ§Ã£o 2
} else {
    // cÃ³digo padrÃ£o
}
```

#### Exemplo PrÃ¡tico

```JAVA
int threatLevel = 3;
if (threatLevel == 1) {
    System.out.println("Alerta Verde");
} else if (threatLevel == 2) {
    System.out.println("Alerta Amarelo");
} else {
    System.out.println("Alerta Vermelho");
}
```

### 3. Operador TernÃ¡rio

```JAVA
resultado = (condicao) ? valorSeVerdadeiro : valorSeFalso;
```

#### Exemplo PrÃ¡tico

```JAVA
int energia = 50;
String status = (energia > 20) ? "Online" : "Offline";
```

## Operadores de ComparaÃ§Ã£o

| Operador |DescriÃ§Ã£o |
-----------------------
| `==` |Igual a |
| `!=` |Diferente de |
| `>` |Maior que |
| `<` |Menor que |
| `>=` |Maior ou igual |
| `<=` |Menor ou igual |

## Operadores LÃ³gicos

| Operador |DescriÃ§Ã£o |
-----------------------
| `&&` |AND lÃ³gico |
| `\\|\\|` |OR lÃ³gico |
| `!` |NOT lÃ³gico |

## Boas PrÃ¡ticas

1. Clareza nas CondiÃ§Ãµes

```JAVA
// Ruim
if (x == 1 && y == 2 || z == 3 && !w) { }

// Bom
boolean isValidX = (x == 1);
boolean isValidY = (y == 2);
boolean isValidZ = (z == 3 && !w);
if (isValidX && isValidY || isValidZ) { }
```

2. Evite Aninhamento Excessivo

```JAVA
// Evite
if (a) {
    if (b) {
        if (c) {
            // cÃ³digo
        }
    }
}

// Prefira
if (!a || !b || !c) return;
// cÃ³digo
```

3. Use Chaves Sempre

```JAVA
// Evite
if (condicao) comando;

// Prefira
if (condicao) {
    comando;
}
```

## PadrÃµes AvanÃ§ados

### Switch Expression (Java 14+)

```JAVA
String mensagem = switch (nivelAcesso) {
    case 1 -> "Acesso BÃ¡sico";
    case 2 -> "Acesso IntermediÃ¡rio";
    case 3 -> "Acesso Total";
    default -> "Sem Acesso";
};
```

### Pattern Matching (Preview)

```JAVA
if (obj instanceof String s && s.length() > 5) {
    System.out.println("String longa: " + s);
}
```

## ExercÃ­cios PrÃ¡ticos

1. Sistema de AutenticaÃ§Ã£o

```JAVA
public boolean verificarAcesso(String usuario, int nivel) {
    if (usuario == null || usuario.isEmpty()) {
        return false;
    }
    return nivel >= 3 && usuario.startsWith("ADMIN_");
}
```

2. Validador de Status

```JAVA
public String verificarStatus(int memoria, int cpu) {
    if (memoria < 10 || cpu > 90) {
        return "CRÃTICO";
    } else if (memoria < 30 || cpu > 70) {
        return "ALERTA";
    }
    return "NORMAL";
}
```

## PrÃ³ximos Passos

* Explore estruturas de repetiÃ§Ã£o em [Loops](loops.html)

* Aprenda sobre expressÃµes switch em [Switch Expressions](switch-expressions.html)

* Descubra pattern matching em [Pattern Matching](pattern-matching.html)

[Loops](loops.html)



# Estruturas de RepetiÃ§Ã£o

```
>> Iniciando ciclos de execuÃ§Ã£o...
>> Configurando iteradores...
>> Estabelecendo pontos de controle...
```

## VisÃ£o Geral

Loops sÃ£o como rotinas de hack - eles permitem executar operaÃ§Ãµes repetitivas de forma eficiente e controlada.

## Tipos de Loops

### 1. for Loop

```JAVA
for (inicializaÃ§Ã£o; condiÃ§Ã£o; incremento) {
    // cÃ³digo a ser repetido
}
```

#### Exemplo PrÃ¡tico

```JAVA
for (int i = 0; i < 5; i++) {
    System.out.println("Tentativa de acesso: " + i);
}
```

### 2. while Loop

```JAVA
while (condiÃ§Ã£o) {
    // cÃ³digo a ser repetido
}
```

#### Exemplo PrÃ¡tico

```JAVA
int tentativas = 0;
while (tentativas < 3) {
    System.out.println("Tentando conexÃ£o...");
    tentativas++;
}
```

### 3. do-while Loop

```JAVA
do {
    // cÃ³digo a ser repetido
} while (condiÃ§Ã£o);
```

#### Exemplo PrÃ¡tico

```JAVA
int senha;
do {
    senha = gerarSenha();
} while (!validarSenha(senha));
```

### 4. for-each Loop

```JAVA
for (tipo elemento : coleÃ§Ã£o) {
    // cÃ³digo a ser repetido
}
```

#### Exemplo PrÃ¡tico

```JAVA
String[] servidores = {"Alpha", "Beta", "Gamma"};
for (String servidor : servidores) {
    System.out.println("Verificando servidor: " + servidor);
}
```

## Controle de Loop

### break

Interrompe a execuÃ§Ã£o do loop completamente.

```JAVA
for (int i = 0; i < 100; i++) {
    if (detectarIntruso()) {
        break; // Sai do loop imediatamente
    }
}
```

### continue

Pula para a prÃ³xima iteraÃ§Ã£o do loop.

```JAVA
for (int porta = 0; porta < 1024; porta++) {
    if (!portaVulneravel(porta)) {
        continue; // Verifica prÃ³xima porta
    }
    atacarPorta(porta);
}
```

## PadrÃµes de Uso

### 1. Loop Infinito Controlado

```JAVA
while (true) {
    if (condicaoParada()) {
        break;
    }
    // processamento
}
```

### 2. Loop com MÃºltiplas VariÃ¡veis

```JAVA
for (int i = 0, j = 10; i < j; i++, j--) {
    System.out.printf("i: %d, j: %d%n", i, j);
}
```

### 3. Loop Aninhado

```JAVA
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        System.out.printf("[%d,%d] ", i, j);
    }
    System.out.println();
}
```

## Boas PrÃ¡ticas

1. Use o Loop Adequado

```JAVA
// Para nÃºmero conhecido de iteraÃ§Ãµes
for (int i = 0; i < tamanho; i++) { }

// Para condiÃ§Ã£o desconhecida
while (temDados()) { }

// Para arrays/collections
for (Elemento e : colecao) { }
```

2. Evite Loop Infinito Acidental

```JAVA
// Ruim - possÃ­vel loop infinito
while (x > 0) {
    // esqueceu de modificar x
}

// Bom
while (x > 0) {
    x--;
    // processamento
}
```

3. Mantenha Loops Simples

```JAVA
// Evite
for (int i = 0; i < 100; i++) {
    // muito cÃ³digo aqui
}

// Prefira
for (int i = 0; i < 100; i++) {
    processarItem(i);
}
```

## Exemplos AvanÃ§ados

### 1. Loop com Timer

```JAVA
long inicio = System.currentTimeMillis();
long limite = 5000; // 5 segundos

while (System.currentTimeMillis() - inicio < limite) {
    // processamento limitado por tempo
}
```

### 2. Loop com Retry

```JAVA
int maxTentativas = 3;
int tentativa = 0;

while (tentativa < maxTentativas) {
    try {
        conectar();
        break;
    } catch (Exception e) {
        tentativa++;
        if (tentativa == maxTentativas) {
            throw new RuntimeException("Falha na conexÃ£o");
        }
    }
}
```

### 3. Loop com Buffer

```JAVA
StringBuilder buffer = new StringBuilder();
for (int i = 0; i < dados.length; i++) {
    buffer.append(dados[i]);
    if (buffer.length() >= 1000) {
        processarBuffer(buffer.toString());
        buffer.setLength(0);
    }
}
```

## ExercÃ­cios PrÃ¡ticos

1. Scanner de Portas

```JAVA
public void scanearPortas(int inicio, int fim) {
    for (int porta = inicio; porta <= fim; porta++) {
        if (portaAberta(porta)) {
            System.out.println("Porta " + porta + " estÃ¡ aberta");
        }
    }
}
```

2. Processador de Dados

```JAVA
public void processarDados(List<String> dados) {
    int processados = 0;
    while (!dados.isEmpty()) {
        String dado = dados.remove(0);
        processar(dado);
        processados++;
        if (processados % 100 == 0) {
            System.out.println("Progresso: " + processados);
        }
    }
}
```

## PrÃ³ximos Passos

* Aprenda sobre condicionais em [Conditionals](conditionals.html)

* Explore expressÃµes switch em [Switch Expressions](switch-expressions.html)

* Descubra pattern matching em [Pattern Matching](pattern-matching.html)

[Pattern Matching](pattern-matching.html)



# Switch Expressions

```
>> Inicializando sistema de expressÃµes switch...
>> Carregando padrÃµes de correspondÃªncia...
>> Estabelecendo rotas de decisÃ£o...
```

## IntroduÃ§Ã£o

O switch expression Ã© uma feature moderna do Java que oferece uma forma mais concisa e segura de escrever estruturas de decisÃ£o mÃºltipla.

## Sintaxe BÃ¡sica

### Switch Expression Tradicional

```JAVA
String status = switch (statusCode) {
    case 200 -> "OK";
    case 404 -> "Not Found";
    case 500 -> "Internal Server Error";
    default -> "Unknown Status";
};
```

### Switch com MÃºltiplos Casos

```JAVA
String category = switch (score) {
    case 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100 -> "A";
    case 80, 81, 82, 83, 84, 85, 86, 87, 88, 89 -> "B";
    case 70, 71, 72, 73, 74, 75, 76, 77, 78, 79 -> "C";
    default -> "F";
};
```

## Recursos AvanÃ§ados

### Yield

```JAVA
String message = switch (level) {
    case "INFO" -> {
        logInfo();
        yield "Information message";
    }
    case "WARNING" -> {
        logWarning();
        yield "Warning message";
    }
    case "ERROR" -> {
        logError();
        yield "Error message";
    }
    default -> "Unknown level";
};
```

### Pattern Matching (Preview)

```JAVA
String typeCheck = switch (obj) {
    case String s -> "Text: " + s;
    case Integer i -> "Number: " + i;
    case Long l -> "Long: " + l;
    case null -> "Null value";
    default -> "Unknown type";
};
```

## Boas PrÃ¡ticas

1. Expressividade

* Use nomes descritivos para variÃ¡veis

* Mantenha casos relacionados agrupados

* Evite lÃ³gica complexa dentro dos casos

2. OrganizaÃ§Ã£o

* Ordene os casos de forma lÃ³gica

* Agrupe casos similares

* Use comentÃ¡rios para documentar casos complexos

3. Manutenibilidade

* Evite fallthrough entre casos

* Sempre inclua um caso default

* Mantenha a lÃ³gica simples e direta

## Exemplos PrÃ¡ticos

### Processador de Status HTTP

```JAVA
HttpResponse processStatus(int code) {
    return switch (code) {
        case 200, 201, 202 -> new SuccessResponse();
        case 400, 401, 403 -> new ClientErrorResponse();
        case 500, 502, 503 -> new ServerErrorResponse();
        default -> new UnknownResponse();
    };
}
```

### Calculadora Simples

```JAVA
double calculate(double a, double b, String operator) {
    return switch (operator) {
        case "+" -> a + b;
        case "-" -> a - b;
        case "*" -> a * b;
        case "/" -> {
            if (b == 0) {
                throw new ArithmeticException("DivisÃ£o por zero");
            }
            yield a / b;
        }
        default -> throw new IllegalArgumentException("Operador invÃ¡lido");
    };
}
```

## Troubleshooting

### Problemas Comuns

1. Esquecimento do Default

```JAVA
// Incorreto - CompilaÃ§Ã£o falha
String result = switch (value) {
    case 1 -> "Um";
    case 2 -> "Dois";
}; // Erro: falta caso default

// Correto
String result = switch (value) {
    case 1 -> "Um";
    case 2 -> "Dois";
    default -> "Outro";
};
```

1. Mistura de Arrow e Block

```JAVA
// Incorreto - Sintaxe inconsistente
String result = switch (value) {
    case 1 -> "Um"
    case 2: yield "Dois";
};

// Correto
String result = switch (value) {
    case 1 -> "Um";
    case 2 -> "Dois";
};
```

## ExercÃ­cios PrÃ¡ticos

1. Conversor de Dia da Semana

```JAVA
String getDayName(int day) {
    return switch (day) {
        case 1 -> "Domingo";
        case 2 -> "Segunda";
        case 3 -> "TerÃ§a";
        case 4 -> "Quarta";
        case 5 -> "Quinta";
        case 6 -> "Sexta";
        case 7 -> "SÃ¡bado";
        default -> "Dia invÃ¡lido";
    };
}
```

1. Classificador de Notas

```JAVA
String classifyGrade(double grade) {
    return switch ((int) grade / 10) {
        case 10, 9 -> "A";
        case 8 -> "B";
        case 7 -> "C";
        case 6 -> "D";
        default -> "F";
    };
}
```

## PrÃ³ximos Passos

* Explore pattern matching em [Pattern Matching](pattern-matching.html)

* Pratique com exercÃ­cios em [Control Flow Projects](control-flow-projects.html)

* Aprenda sobre expressÃµes lambda em [Lambda](lambda.html)

[Pattern Matching](pattern-matching.html)



# Pattern Matching

```
>> Inicializando sistema de correspondÃªncia de padrÃµes...
>> Carregando tipos de dados...
>> Estabelecendo regras de matching...
```

## IntroduÃ§Ã£o

Pattern Matching Ã© uma feature moderna do Java que permite testar e extravar valores de objetos de forma mais elegante e segura.

## Pattern Matching com instanceof

### Sintaxe Tradicional vs. Nova

```JAVA
// Forma antiga
if (obj instanceof String) {
    String str = (String) obj;
    System.out.println(str.length());
}

// Pattern Matching
if (obj instanceof String str) {
    System.out.println(str.length());
}
```

### Uso com NegaÃ§Ã£o

```JAVA
if (!(obj instanceof String str)) {
    return;
}
// str estÃ¡ disponÃ­vel aqui
System.out.println(str.length());
```

## Pattern Matching em Switch (Preview)

### Matching por Tipo

```JAVA
String formatted = switch (obj) {
    case String str -> "String: " + str.toUpperCase();
    case Integer num -> "Int: " + num.toString();
    case Double d -> "Double: " + String.format("%.2f", d);
    case null -> "null";
    default -> "Unknown: " + obj.toString();
};
```

### Guarded Patterns

```JAVA
String checkNumber = switch (num) {
    case Integer i when i < 0 -> "Negativo";
    case Integer i when i > 0 -> "Positivo";
    case Integer i -> "Zero";
    default -> "NÃ£o Ã© um nÃºmero";
};
```

## Casos de Uso AvanÃ§ados

### Hierarquia de Classes

```JAVA
public sealed interface Shape 
    permits Circle, Rectangle, Triangle {}

record Circle(double radius) implements Shape {}
record Rectangle(double width, double height) implements Shape {}
record Triangle(double base, double height) implements Shape {}

double calculateArea(Shape shape) {
    return switch (shape) {
        case Circle c -> Math.PI * c.radius() * c.radius();
        case Rectangle r -> r.width() * r.height();
        case Triangle t -> (t.base() * t.height()) / 2;
    };
}
```

### Processamento de Dados

```JAVA
String processData(Object data) {
    return switch (data) {
        case String s when s.length() > 10 -> "String longa: " + s.substring(0, 10) + "...";
        case String s -> "String: " + s;
        case List<?> list when list.isEmpty() -> "Lista vazia";
        case List<?> list -> "Lista com " + list.size() + " elementos";
        case Map<?, ?> map -> "Map com " + map.size() + " entradas";
        case null -> "Dado nulo";
        default -> "Tipo nÃ£o suportado";
    };
}
```

## Boas PrÃ¡ticas

1. Clareza

* Use nomes descritivos para variÃ¡veis de pattern

* Mantenha padrÃµes simples e diretos

* Documente casos complexos

2. OrganizaÃ§Ã£o

* Ordene casos do mais especÃ­fico para o mais genÃ©rico

* Agrupe padrÃµes relacionados

* Use guards para refinar a lÃ³gica

3. Performance

* Evite operaÃ§Ãµes pesadas em guards

* Considere a ordem dos padrÃµes

* Mantenha o cÃ³digo eficiente

## Exemplos PrÃ¡ticos

### Validador de Dados

```JAVA
String validateInput(Object input) {
    return switch (input) {
        case String s when s.isBlank() -> "String vazia";
        case String s when s.matches("\\d+") -> "NÃºmero vÃ¡lido: " + s;
        case String s -> "Texto vÃ¡lido: " + s;
        case Integer i when i >= 0 -> "NÃºmero positivo: " + i;
        case Integer i -> "NÃºmero negativo: " + i;
        case null -> "Input nulo";
        default -> "Input invÃ¡lido";
    };
}
```

### Processador de Eventos

```JAVA
void processEvent(Event event) {
    switch (event) {
        case UserEvent u when u.isAdmin() -> handleAdminEvent(u);
        case UserEvent u -> handleUserEvent(u);
        case SystemEvent s when s.isCritical() -> handleCriticalSystemEvent(s);
        case SystemEvent s -> handleSystemEvent(s);
        case null -> throw new IllegalArgumentException("Evento nulo");
        default -> handleUnknownEvent(event);
    }
}
```

## Troubleshooting

### Problemas Comuns

1. Ordem dos Patterns

```JAVA
// Incorreto - PadrÃ£o inalcanÃ§Ã¡vel
switch (obj) {
    case Object o -> "Objeto";    // Captura tudo
    case String s -> "String";    // Nunca alcanÃ§ado
}

// Correto
switch (obj) {
    case String s -> "String";    // Mais especÃ­fico primeiro
    case Object o -> "Objeto";    // Mais genÃ©rico depois
}
```

1. Null Handling

```JAVA
// Incorreto - NullPointerException possÃ­vel
switch (obj) {
    case String s -> s.length();
    default -> 0;
}

// Correto
switch (obj) {
    case null -> 0;
    case String s -> s.length();
    default -> 0;
}
```

## ExercÃ­cios PrÃ¡ticos

1. Analisador de Dados

```JAVA
String analyzeData(Object data) {
    return switch (data) {
        case String s when s.contains("@") -> "Email: " + s;
        case String s when s.matches("\\d{10}") -> "Telefone: " + s;
        case String s -> "Texto: " + s;
        case Integer i -> "NÃºmero: " + i;
        case List<?> l -> "Lista[" + l.size() + "]";
        case null -> "NULO";
        default -> "Desconhecido";
    };
}
```

1. Calculadora de Formas

```JAVA
record Point(int x, int y) {}
record Circle(Point center, double radius) {}
record Rectangle(Point topLeft, double width, double height) {}

String describeShape(Object shape) {
    return switch (shape) {
        case Circle c -> 
            String.format("CÃ­rculo em (%d,%d) com raio %.2f",
                c.center().x(), c.center().y(), c.radius());
        case Rectangle r -> 
            String.format("RetÃ¢ngulo em (%d,%d) de %.2fx%.2f",
                r.topLeft().x(), r.topLeft().y(), r.width(), r.height());
        case null -> "Forma nula";
        default -> "Forma nÃ£o reconhecida";
    };
}
```

## PrÃ³ximos Passos

* Explore expressÃµes switch em [Switch Expressions](switch-expressions.html)

* Pratique com projetos em [Control Flow Projects](control-flow-projects.html)

* Aprenda sobre sealed classes em [Sealed Classes](sealed-classes.html)

[Control Flow Projects](control-flow-projects.html)



# Projetos de Controle de Fluxo

```
>> Iniciando simulaÃ§Ã£o de projetos...
>> Carregando cenÃ¡rios de teste...
>> Executando casos de uso...
```

## VisÃ£o Geral

Esta seÃ§Ã£o apresenta trÃªs projetos prÃ¡ticos que demonstram diferentes aspectos do controle de fluxo em Java, todos ambientados em um contexto cyberpunk.

```MERMAID
graph TD
    A[Projetos de Controle] --> B[Jogo de NÃºmeros]
    A --> C[Sistema de Menu]
    A --> D[MÃ¡quina de Estados]
    
    B --> E[if/else]
    B --> F[while]
    
    C --> G[switch]
    C --> H[break]
    
    D --> I[switch/case]
    D --> J[estados]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#33ccff
    style F fill:#1a1a1a,stroke:#33ccff
    style G fill:#1a1a1a,stroke:#33ccff
    style H fill:#1a1a1a,stroke:#33ccff
    style I fill:#1a1a1a,stroke:#33ccff
    style J fill:#1a1a1a,stroke:#33ccff
```

## Projetos DisponÃ­veis

### 1. Jogo de NÃºmeros

* [Jogo de NÃºmeros](number-game.html) - Um jogo de adivinhaÃ§Ã£o que utiliza loops e condicionais

* Demonstra uso de `while`, `if/else` e operadores de comparaÃ§Ã£o

* Implementa sistema de pontuaÃ§Ã£o e feedback ao usuÃ¡rio

### 2. Sistema de Menu

* [Sistema de Menu](menu-system.html) - Interface de comando baseada em menus

* Explora uso extensivo de `switch/case`

* Demonstra navegaÃ§Ã£o entre diferentes estados do menu

### 3. MÃ¡quina de Estados

* [MÃ¡quina de Estados](state-machine.html) - Sistema de seguranÃ§a com estados

* Implementa uma mÃ¡quina de estados simples

* Utiliza combinaÃ§Ã£o de `switch/case` e controle de fluxo

## Conceitos Aplicados

1. Estruturas Condicionais

* `if/else`

* `switch/case`

* Operadores de comparaÃ§Ã£o

2. Loops

* `while`

* Controle de iteraÃ§Ã£o

* CondiÃ§Ãµes de saÃ­da

3. Controle de Fluxo

* `break`

* `continue`

* Estados e transiÃ§Ãµes

## Objetivos de Aprendizado

* Praticar diferentes estruturas de controle

* Entender fluxo de execuÃ§Ã£o

* Implementar lÃ³gica de decisÃ£o

* Gerenciar estados do programa

## PrÃ³ximos Passos

ApÃ³s completar estes projetos, vocÃª estarÃ¡ preparado para:

1. Desenvolver sistemas mais complexos

2. Combinar diferentes estruturas de controle

3. Implementar lÃ³gica de negÃ³cios mais sofisticada

[Arrays e ColeÃ§Ãµes](arrays-collections.html)

Tip:

"O controle de fluxo Ã© como hackear a Matrix - vocÃª precisa saber exatamente onde e quando dobrar as regras."



# Jogo de NÃºmeros

## DescriÃ§Ã£o do Projeto

Desenvolva um jogo de adivinhaÃ§Ã£o onde o jogador tenta adivinhar um nÃºmero gerado aleatoriamente pelo sistema.

## Conceitos Aplicados

* Loops (while/do-while)

* Condicionais (if/else)

* Switch Expressions

* Pattern Matching

## ImplementaÃ§Ã£o Base

```JAVA
public class NumberGame {
    public static void main(String[] args) {
        // ConfiguraÃ§Ãµes do jogo usando tipos primitivos
        int numeroSecreto = 42; // NÃºmero fixo para simplificar
        int tentativasMaximas = 5;
        int tentativas = 0;
        boolean jogoAtivo = true;
        
        // Mensagem inicial usando Text Block
        System.out.println("""
            === JOGO DE ADIVINHAÃ‡ÃƒO ===
            Tente adivinhar o nÃºmero entre 1 e 100
            VocÃª tem 5 tentativas!
            =========================
            """);
        
        // Loop principal do jogo
        while (jogoAtivo && tentativas < tentativasMaximas) {
            System.out.println("\nTentativa " + (tentativas + 1) + " de " + tentativasMaximas);
            System.out.print("Digite seu palpite: ");
            
            // Simulando entrada do usuÃ¡rio (vocÃª pode modificar para testar)
            var palpite = 50; // Simula entrada do usuÃ¡rio
            
            // Incrementa tentativas
            tentativas++;
            
            // Verifica o palpite
            if (palpite == numeroSecreto) {
                System.out.println("ParabÃ©ns! VocÃª acertou em " + tentativas + " tentativas!");
                jogoAtivo = false;
            } else {
                // Verifica se ainda tem tentativas
                if (tentativas >= tentativasMaximas) {
                    System.out.println("Game Over! O nÃºmero era " + numeroSecreto);
                } else {
                    // DÃ¡ dicas baseadas no palpite
                    if (palpite < numeroSecreto) {
                        System.out.println("Tente um nÃºmero MAIOR!");
                    } else {
                        System.out.println("Tente um nÃºmero MENOR!");
                    }
                    
                    // Mostra tentativas restantes
                    System.out.println("Tentativas restantes: " + (tentativasMaximas - tentativas));
                }
            }
            
            // Pequena pausa para simular processamento
            System.out.println("Processando...");
        }
        
        // PontuaÃ§Ã£o final
        int pontuacao = 0;
        if (!jogoAtivo) { // Se acertou
            pontuacao = (tentativasMaximas - tentativas + 1) * 100;
            System.out.println("Sua pontuaÃ§Ã£o: " + pontuacao);
        }
        
        System.out.println("Fim do jogo!");
    }
}
```

## Interface com UsuÃ¡rio

```JAVA
public class NumberGameUI {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        NumberGame game = new NumberGame(100, 5);
        
        System.out.println("=== Jogo de AdivinhaÃ§Ã£o ===");
        System.out.println("Tente adivinhar o nÃºmero entre 1 e 100");
        
        do {
            System.out.print("Digite seu palpite: ");
            if (scanner.hasNextInt()) {
                int guess = scanner.nextInt();
                String result = game.processGuess(guess);
                System.out.println(result);
            } else {
                System.out.println("Por favor, digite um nÃºmero vÃ¡lido!");
                scanner.next();
            }
        } while (!game.isGameOver());
    }
}
```

## Desafios de ExtensÃ£o

1. NÃ­veis de Dificuldade

```JAVA
public enum Difficulty {
    EASY(1, 10, 6),
    MEDIUM(1, 100, 5),
    HARD(1, 1000, 4);

    final int min, max, attempts;
    
    Difficulty(int min, int max, int attempts) {
        this.min = min;
        this.max = max;
        this.attempts = attempts;
    }
}
```

1. Sistema de PontuaÃ§Ã£o

```JAVA
public int calculateScore() {
    return switch (state) {
        case WON -> (maxAttempts - attempts + 1) * 100;
        case LOST -> 0;
        default -> throw new IllegalStateException("Jogo ainda em andamento");
    };
}
```

## PrÃ³ximos Passos

* Implemente o sistema de dificuldade

* Adicione um sistema de recordes

* Crie um modo multiplayer

[Menu System](menu-system.html)



# Sistema de Menu

## DescriÃ§Ã£o do Projeto

Desenvolva um sistema de menu interativo estilo cyberpunk para uma interface de terminal.

## Conceitos Aplicados

* Switch Expressions

* Pattern Matching

* Loops

* Condicionais Aninhados

## ImplementaÃ§Ã£o Base

```JAVA
public class MenuSystem {
    public static void main(String[] args) {
        // Estado atual do menu usando String
        String menuAtual = "PRINCIPAL";
        
        // Flag para controle do loop
        boolean sistemaAtivo = true;
        
        // Mensagem de boas-vindas usando Text Block
        System.out.println("""
            === SISTEMA CYBERDECK v1.0 ===
            Menu Principal:
            1. Iniciar Sistema
            2. ConfiguraÃ§Ãµes
            3. Status
            4. Sair
            ===========================
            """);
        
        // Loop principal do sistema
        while (sistemaAtivo) {
            System.out.println("\nMenu atual: " + menuAtual);
            System.out.print("Digite uma opÃ§Ã£o: ");
            
            // Simulando entrada do usuÃ¡rio (vocÃª pode modificar para testar)
            var opcao = "1"; // Simula entrada do usuÃ¡rio
            
            // Controle de fluxo baseado no menu atual
            switch (menuAtual) {
                case "PRINCIPAL":
                    switch (opcao) {
                        case "1":
                            menuAtual = "SISTEMA";
                            System.out.println("""
                                === Menu do Sistema ===
                                1. Verificar Status
                                2. Executar DiagnÃ³stico
                                3. Voltar
                                """);
                            break;
                        case "2":
                            menuAtual = "CONFIG";
                            System.out.println("""
                                === Menu de ConfiguraÃ§Ãµes ===
                                1. Display
                                2. SeguranÃ§a
                                3. Rede
                                4. Voltar
                                """);
                            break;
                        case "3":
                            System.out.println("""
                                Status do Sistema:
                                - MemÃ³ria: OK
                                - Processador: OK
                                - Rede: OK
                                """);
                            break;
                        case "4":
                            sistemaAtivo = false;
                            break;
                    }
                    break;
                    
                case "CONFIG":
                    switch (opcao) {
                        case "1":
                            System.out.println("Configurando Display...");
                            break;
                        case "2":
                            System.out.println("Configurando SeguranÃ§a...");
                            break;
                        case "3":
                            System.out.println("Configurando Rede...");
                            break;
                        case "4":
                            menuAtual = "PRINCIPAL";
                            System.out.println("Voltando ao Menu Principal...");
                            break;
                    }
                    break;
                    
                case "SISTEMA":
                    switch (opcao) {
                        case "1":
                            System.out.println("Verificando status...");
                            break;
                        case "2":
                            System.out.println("Executando diagnÃ³stico...");
                            break;
                        case "3":
                            menuAtual = "PRINCIPAL";
                            System.out.println("Voltando ao Menu Principal...");
                            break;
                    }
                    break;
            }
            
            // Pequena pausa para simular processamento
            System.out.println("Processando...");
        }
        
        System.out.println("Sistema finalizado.");
    }
}
```

## Interface com UsuÃ¡rio

```JAVA
public class MenuSystemUI {
    public static void main(String[] args) {
        MenuSystem menu = new MenuSystem();
        Scanner scanner = new Scanner(System.in);
        
        System.out.println("""
            === SISTEMA CYBERDECK v1.0 ===
            Iniciando interface...
            """);
        
        String input;
        do {
            System.out.print("> ");
            input = scanner.nextLine().trim();
            String response = menu.processInput(input);
            System.out.println(response);
        } while (!input.equals("exit"));
    }
}
```

## Recursos AvanÃ§ados

1. AnimaÃ§Ãµes de Terminal

```JAVA
public class TerminalEffects {
    public static void typeWriter(String text) {
        for (char c : text.toCharArray()) {
            System.out.print(c);
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        System.out.println();
    }
}
```

1. Sistema de Cores

```JAVA
public class ColoredOutput {
    public static final String ANSI_GREEN = "\u001B[32m";
    public static final String ANSI_RED = "\u001B[31m";
    public static final String ANSI_RESET = "\u001B[0m";
    
    public static String success(String text) {
        return ANSI_GREEN + text + ANSI_RESET;
    }
    
    public static String error(String text) {
        return ANSI_RED + text + ANSI_RESET;
    }
}
```

## Desafios de ExtensÃ£o

1. Adicione autenticaÃ§Ã£o de usuÃ¡rio

2. Implemente submenus dinÃ¢micos

3. Crie um sistema de logs

4. Adicione efeitos visuais ASCII art

## PrÃ³ximos Passos

* Implemente mais funcionalidades no menu

* Adicione persistÃªncia de configuraÃ§Ãµes

* Crie uma interface grÃ¡fica ASCII mais elaborada

[State Machine](state-machine.html)



# MÃ¡quina de Estados

## DescriÃ§Ã£o do Projeto

Implemente uma mÃ¡quina de estados que simula um sistema de seguranÃ§a cyberpunk.

## Conceitos Aplicados

* Pattern Matching

* Switch Expressions

* Loops Controlados por Estado

* Condicionais Complexos

## ImplementaÃ§Ã£o Base

```JAVA
public class StateMachine {
    public static void main(String[] args) {
        // Estados possÃ­veis usando String
        String estado = "TRAVADO";  // estado inicial
        
        // Contadores e flags usando tipos primitivos
        int tentativasInvalidas = 0;
        boolean sistemaAtivo = true;
        
        // Mensagem de boas-vindas usando Text Block
        System.out.println("""
            === SISTEMA DE SEGURANÃ‡A CYBERPUNK ===
            Estados: TRAVADO, DESTRAVADO, ALERTA
            Comandos: 
            1 - Inserir cÃ³digo vÃ¡lido
            2 - Inserir cÃ³digo invÃ¡lido
            3 - Travar sistema
            4 - Sair
            ====================================
            """);
        
        // Loop principal do sistema
        while (sistemaAtivo) {
            System.out.println("\nEstado atual: " + estado);
            System.out.print("Digite um comando: ");
            
            // Simulando entrada do usuÃ¡rio (vocÃª pode modificar os valores para testar)
            var comando = "1"; // Simula entrada do usuÃ¡rio
            
            // Controle de fluxo baseado no estado atual
            switch (estado) {
                case "TRAVADO":
                    if (comando.equals("1")) {
                        estado = "DESTRAVADO";
                        tentativasInvalidas = 0;
                        System.out.println("Acesso concedido!");
                    } else if (comando.equals("2")) {
                        tentativasInvalidas++;
                        if (tentativasInvalidas >= 3) {
                            estado = "ALERTA";
                            System.out.println("ALERTA: MÃºltiplas tentativas invÃ¡lidas!");
                        } else {
                            System.out.println("CÃ³digo invÃ¡lido. Tentativas restantes: " + (3 - tentativasInvalidas));
                        }
                    }
                    break;
                    
                case "DESTRAVADO":
                    if (comando.equals("3")) {
                        estado = "TRAVADO";
                        System.out.println("Sistema travado!");
                    }
                    break;
                    
                case "ALERTA":
                    if (comando.equals("1")) {
                        estado = "TRAVADO";
                        tentativasInvalidas = 0;
                        System.out.println("Sistema resetado!");
                    }
                    break;
            }
            
            // CondiÃ§Ã£o de saÃ­da
            if (comando.equals("4")) {
                sistemaAtivo = false;
                System.out.println("Encerrando sistema...");
            }
            
            // Pequena pausa para simular processamento
            System.out.println("Processando...");
        }
    }
}
```

## Interface com UsuÃ¡rio

```JAVA
public class SecuritySystemUI {
    public static void main(String[] args) {
        SecuritySystem system = new SecuritySystem();
        Scanner scanner = new Scanner(System.in);
        
        System.out.println("""
            === SISTEMA DE SEGURANÃ‡A CYBERPUNK ===
            Digite 'help' para ver os comandos disponÃ­veis
            """);
        
        while (true) {
            System.out.print(">> ");
            String input = scanner.nextLine().toUpperCase();
            
            if (input.equals("EXIT")) break;
            
            try {
                SecurityEvent event = SecurityEvent.valueOf(input);
                String result = system.processEvent(event);
                System.out.println(result);
            } catch (IllegalArgumentException e) {
                if (input.equals("HELP")) {
                    showHelp();
                } else {
                    System.out.println("Comando invÃ¡lido");
                }
            }
        }
    }
    
    private static void showHelp() {
        System.out.println("""
            Comandos disponÃ­veis:
            VALID_CODE - Tentar cÃ³digo de acesso
            INVALID_CODE - CÃ³digo invÃ¡lido
            LOCK - Travar sistema
            EMERGENCY - Ativar emergÃªncia
            MAINTENANCE_KEY - Modo manutenÃ§Ã£o
            RESET - Resetar sistema
            SHUTDOWN - Desligar sistema
            EXIT - Sair do programa
            """);
    }
}
```

## Recursos AvanÃ§ados

1. Sistema de Biometria

```JAVA
public class BiometricScanner {
    public boolean validateBiometric(String bioData) {
        return switch (bioData.length()) {
            case 32 -> bioData.matches("[A-F0-9]+");
            case 64 -> bioData.matches("[a-f0-9]+");
            default -> false;
        };
    }
}
```

1. Monitor de Atividades

```JAVA
public class ActivityMonitor {
    private final Queue<SecurityEvent> recentEvents;
    private static final int MAX_EVENTS = 10;
    
    public ActivityMonitor() {
        this.recentEvents = new LinkedList<>();
    }
    
    public void recordEvent(SecurityEvent event) {
        recentEvents.offer(event);
        if (recentEvents.size() > MAX_EVENTS) {
            recentEvents.poll();
        }
    }
    
    public boolean detectSuspiciousActivity() {
        long invalidAttempts = recentEvents.stream()
            .filter(e -> e == SecurityEvent.INVALID_CODE)
            .count();
        return invalidAttempts >= 3;
    }
}
```

## Desafios de ExtensÃ£o

1. Implemente um sistema de nÃ­veis de acesso

2. Adicione criptografia para cÃ³digos de acesso

3. Crie um sistema de backup automÃ¡tico

4. Implemente notificaÃ§Ãµes em tempo real

## PrÃ³ximos Passos

* Adicione mais estados e eventos

* Implemente persistÃªncia de logs

* Crie uma interface grÃ¡fica mais elaborada

* Adicione suporte a mÃºltiplos usuÃ¡rios

[Control Flow](control-flow.html)



# Arrays e ColeÃ§Ãµes

```
DATA STRUCTURES
â”œâ”€â”€ Arrays
â”‚   â”œâ”€â”€ Unidimensionais
â”‚   â””â”€â”€ Multidimensionais
â””â”€â”€ Collections
    â”œâ”€â”€ List
    â”œâ”€â”€ Set
    â”œâ”€â”€ Queue
    â””â”€â”€ Map
```

## VisÃ£o Geral

Esta seÃ§Ã£o explora as estruturas de dados fundamentais em Java, desde arrays bÃ¡sicos atÃ© as coleÃ§Ãµes mais sofisticadas do framework Collections.

```MERMAID
graph TD
    A[Estruturas de Dados] --> B[Arrays]
    A --> C[Collections]
    
    B --> D[Arrays Primitivos]
    B --> E[Arrays de Objetos]
    
    C --> F[List]
    C --> G[Set]
    C --> H[Queue]
    C --> I[Map]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#33ccff
    style E fill:#1a1a1a,stroke:#33ccff
    style F fill:#1a1a1a,stroke:#33ccff
    style G fill:#1a1a1a,stroke:#33ccff
    style H fill:#1a1a1a,stroke:#33ccff
    style I fill:#1a1a1a,stroke:#33ccff
```

## MÃ³dulos do Curso

### 1. Arrays Fundamentais

* [Arrays](arrays.html) - Estruturas bÃ¡sicas e manipulaÃ§Ã£o

* Arrays unidimensionais e multidimensionais

* OperaÃ§Ãµes comuns e boas prÃ¡ticas

### 2. Framework Collections

* [VisÃ£o Geral das Collections](collections-overview.html)

* [Listas](lists.html) - SequÃªncias ordenadas

* [Sets](sets.html) - Conjuntos sem duplicatas

* [Maps](maps.html) - Pares chave-valor

* [Queues](queues.html) - Filas e pilhas

* [Stacks](stacks.html) - Estruturas LIFO

### 3. Projetos PrÃ¡ticos

* [Gerenciador de Tarefas](task-manager.html)

* [Sistema de InventÃ¡rio](inventory-system.html)

* [ImplementaÃ§Ã£o de Cache](cache-implementation.html)

## Conceitos Principais

1. Arrays

* AlocaÃ§Ã£o de memÃ³ria

* IndexaÃ§Ã£o

* IteraÃ§Ã£o

* Arrays multidimensionais

2. Collections Framework

* Interfaces principais

* ImplementaÃ§Ãµes comuns

* Algoritmos de coleÃ§Ãµes

* Iteradores

3. Performance e Uso

* Complexidade de tempo

* Uso de memÃ³ria

* Escolha da estrutura adequada

* OtimizaÃ§Ãµes

## Objetivos de Aprendizado

* Dominar manipulaÃ§Ã£o de arrays

* Entender o framework Collections

* Escolher estruturas apropriadas

* Implementar soluÃ§Ãµes eficientes

## PrÃ³ximos Passos

ApÃ³s esta seÃ§Ã£o, vocÃª estarÃ¡ preparado para:

1. Trabalhar com estruturas de dados complexas

2. Implementar algoritmos eficientes

3. Desenvolver sistemas escalÃ¡veis

[Fundamentos de OOP](oop-fundamentals.html)

Tip:

"Em um mundo digital, dados sÃ£o poder. A forma como vocÃª os estrutura determina sua eficiÃªncia no combate."



# Arrays em Java

```
ARRAY OPERATIONS
â”œâ”€â”€ DeclaraÃ§Ã£o (Como registrar clientes em um bordel)
â”œâ”€â”€ InicializaÃ§Ã£o (Abrir as portas)
â”œâ”€â”€ Acesso (Encontrar seu favorito)
â”œâ”€â”€ ModificaÃ§Ã£o (Trocar os nÃºmeros)
â””â”€â”€ IteraÃ§Ã£o (Fazer a ronda noturna)
```

## Fundamentos

Arrays sÃ£o como um bordel bem organizado - cada quarto tem seu nÃºmero, e vocÃª sabe exatamente o que esperar em cada um. Sem surpresas desagradÃ¡veis.

```JAVA
// DeclaraÃ§Ã£o e inicializaÃ§Ã£o
int[] quartos = new int[5];  // 5 quartos vazios
String[] servicos = {"BASICO", "ESPECIAL", "COMPLETO"};

// Array multidimensional (como um prÃ©dio com vÃ¡rios andares)
int[][] predio = new int[3][3];
```

## CaracterÃ­sticas Principais

### 1. Tamanho Fixo (Como um Motel Lotado)

```JAVA
// Uma vez definido o nÃºmero de quartos, nÃ£o dÃ¡ pra criar mais
int numQuartos = 10;
double[] precos = new double[numQuartos];

// Nem adianta chorar, nÃ£o vai caber mais
System.out.println("Quartos disponÃ­veis: " + precos.length);
```

### 2. IndexaÃ§Ã£o Base-Zero (Como Idade de PolÃ­tico)

```JAVA
// O primeiro sempre comeÃ§a do zero
int primeiro = quartos[0];  // Quarto 0 (mas na placa tÃ¡ 1)

// O Ãºltimo Ã© sempre um a menos que o total
int ultimo = quartos[quartos.length - 1];
```

### 3. Tipo HomogÃªneo (Como Menu de Boteco)

```JAVA
// Aqui sÃ³ serve cachaÃ§a, amigo
String[] drinks = new String[3];
drinks[0] = "51";
drinks[1] = "Velho Barreiro";
drinks[2] = "PitÃº";
```

## OperaÃ§Ãµes Comuns

### IteraÃ§Ã£o (Como Fazer a Ronda)

```JAVA
// MÃ©todo tradicional (checando quarto por quarto)
for (int i = 0; i < quartos.length; i++) {
    System.out.println("Verificando quarto " + i);
}

// MÃ©todo moderno (cÃ¢meras de seguranÃ§a)
for (String drink : drinks) {
    System.out.println("Bebida disponÃ­vel: " + drink);
}
```

### ManipulaÃ§Ã£o (Como Gerenciar o Estabelecimento)

```JAVA
// Resetar preÃ§os (promoÃ§Ã£o de segunda)
Arrays.fill(precos, 29.90);

// Ordenar por preÃ§o (do mais barato pro mais caro)
Arrays.sort(precos);

// Procurar aquele cliente especial
int indice = Arrays.binarySearch(drinks, "51");
```

## Arrays Multidimensionais (Como um Cassino de Luxo)

### Matrizes

```JAVA
// Mapa do cassino (3 andares, cada um com 3 salas)
int[][] cassino = {
    {1, 2, 3},  // CaÃ§a-nÃ­queis
    {4, 5, 6},  // Poker
    {7, 8, 9}   // Roleta
};

// Encontrar mesa especÃ­fica
int mesa = cassino[1][2];  // Mesa 6 de poker
```

### IteraÃ§Ã£o em Matrizes (InspeÃ§Ã£o SanitÃ¡ria)

```JAVA
// Verificando todas as mesas
for (int andar = 0; andar < cassino.length; andar++) {
    for (int sala = 0; sala < cassino[andar].length; sala++) {
        System.out.print("Verificando mesa " + cassino[andar][sala]);
    }
    System.out.println(" - Andar limpo!");
}
```

## Boas PrÃ¡ticas (Regras da Casa)

1. ValidaÃ§Ã£o de Ãndices (Checagem de ID)

```JAVA
if (quarto >= 0 && quarto < quartos.length) {
    // Cliente pode entrar
    return quartos[quarto];
}
```

1. CÃ³pia de Arrays (Expandindo o NegÃ³cio)

```JAVA
// Abrindo filial com mesma configuraÃ§Ã£o
int[] filial = Arrays.copyOf(quartos, quartos.length);

// Pegando sÃ³ o melhor da casa
int[] vips = Arrays.copyOfRange(quartos, 1, 4);
```

## ExercÃ­cios PrÃ¡ticos

1. Implemente um sistema de rodÃ­zio de "funcionÃ¡rios"

2. Crie um controle de mesas de poker

3. Desenvolva um algoritmo de distribuiÃ§Ã£o de gorjetas

## PrÃ³ximos Passos

Depois de dominar esse bordel de arrays, vocÃª estarÃ¡ pronto para:

1. Gerenciar uma rede de estabelecimentos

2. Implementar sistemas de fidelidade

3. Expandir para o mercado internacional

[Collections: Quando Um NÃ£o Ã© Suficiente](collections-overview.html)

Tip:

"Arrays sÃ£o como um bordel bem administrado - cada elemento no seu lugar, e vocÃª sempre sabe onde encontrar o que procura."



# Collections Framework: O Submundo das Estruturas de Dados

```
COLLECTIONS HIERARCHY
â”œâ”€â”€ List (Como uma Lista de Devedores)
â”œâ”€â”€ Set (Clube Exclusivo, Sem Repetidos)
â”œâ”€â”€ Queue (Fila do PÃ£o, Mas Com Classe)
â””â”€â”€ Map (Agenda TelefÃ´nica do Traficante)
```

## Anatomia do Submundo

Imagine o Collections Framework como uma organizaÃ§Ã£o criminosa bem estruturada - cada famÃ­lia tem sua especialidade, mas todas trabalham juntas quando necessÃ¡rio.

```JAVA
// As principais famÃ­lias
List<String> listaDaChantagem = new ArrayList<>();
Set<String> membrosVIP = new HashSet<>();
Queue<String> filaDeEspera = new LinkedList<>();
Map<String, Double> contasAReceber = new HashMap<>();
```

## FamÃ­lias Principais

### 1. List (A Lista Negra)

```JAVA
List<String> alvos = new ArrayList<>();
alvos.add("JoÃ£o Caloteiro");    // Adiciona no final
alvos.add(0, "Maria Malandra"); // Adiciona no inÃ­cio
String proximo = alvos.get(0);  // PrÃ³xima vÃ­tima
```

### 2. Set (Clube dos Exclusivos)

```JAVA
Set<String> vips = new HashSet<>();
vips.add("Don Corleone");     // Entra no clube
vips.add("Don Corleone");     // Tenta entrar de novo (falha)
boolean isMembro = vips.contains("Don Corleone"); // TÃ¡ na lista?
```

### 3. Queue (Fila do Desespero)

```JAVA
Queue<String> esperando = new LinkedList<>();
esperando.offer("ZÃ© Devedor");  // Entra na fila
String proximo = esperando.poll(); // PrÃ³ximo a ser "atendido"
String espiadinha = esperando.peek(); // Quem Ã© o prÃ³ximo sem tirar
```

### 4. Map (Livro Caixa)

```JAVA
Map<String, Double> dividas = new HashMap<>();
dividas.put("ZÃ©", 1000.0);     // Deve mil
dividas.put("Maria", 2000.0);   // Deve dois mil
Double quanto = dividas.get("ZÃ©"); // Quanto o ZÃ© deve?
```

## Escolhendo sua Arma

### ArrayList vs LinkedList

```JAVA
// ArrayList: Acesso rÃ¡pido, como endereÃ§o fixo
List<String> enderecos = new ArrayList<>();  // Ã“timo para consultas

// LinkedList: InserÃ§Ã£o rÃ¡pida, como mensageiro
List<String> mensagens = new LinkedList<>();  // Bom para alteraÃ§Ãµes
```

### HashSet vs TreeSet

```JAVA
// HashSet: RÃ¡pido e caÃ³tico, como bar de porto
Set<String> frequentadores = new HashSet<>();  // NÃ£o liga pra ordem

// TreeSet: Organizado e lento, como clube de madame
Set<String> clientesVIP = new TreeSet<>();     // Tudo ordenadinho
```

### HashMap vs TreeMap

```JAVA
// HashMap: BagunÃ§ado mas eficiente, como caderno de agiota
Map<String, Double> pagamentos = new HashMap<>();

// TreeMap: Organizado e metÃ³dico, como livro contÃ¡bil
Map<String, Double> contabilidade = new TreeMap<>();
```

## OperaÃ§Ãµes Especiais

### IteraÃ§Ã£o (Fazendo a Ronda)

```JAVA
// For each moderno
for (String devedor : alvos) {
    System.out.println("Procurando: " + devedor);
}

// Iterator (modo old school)
Iterator<String> it = alvos.iterator();
while (it.hasNext()) {
    String alvo = it.next();
    if (alvo.contains("Delator")) {
        it.remove(); // Remove o X9
    }
}
```

### OrdenaÃ§Ã£o (Organizando a Casa)

```JAVA
// Ordenar a lista de devedores por nome
Collections.sort(alvos);

// Ordenar por valor da dÃ­vida
alvos.sort((a, b) -> dividas.get(a).compareTo(dividas.get(b)));
```

## Dicas de SobrevivÃªncia

1. Escolha Certa

* ArrayList para acesso rÃ¡pido

* LinkedList para muitas alteraÃ§Ãµes

* HashSet para unicidade

* TreeSet para ordem natural

* HashMap para acesso por chave

* TreeMap para ordem nas chaves

2. Performance

```JAVA
// Defina o tamanho inicial se souber
List<String> lista = new ArrayList<>(1000);

// Use a estrutura certa pro trabalho
Set<String> conjunto = new HashSet<>();  // Mais rÃ¡pido que List pra busca
```

## ExercÃ­cios PrÃ¡ticos

1. Implemente um sistema de controle de territÃ³rio

2. Crie um gerenciador de dÃ­vidas com juros compostos

3. Desenvolva uma lista de "proteÃ§Ã£o" com prioridades

## PrÃ³ximos Passos

Depois de dominar as Collections, vocÃª estarÃ¡ pronto para:

1. Gerenciar dados como um profissional

2. Implementar estruturas complexas

3. Otimizar operaÃ§Ãµes de dados

[Arrays: De Volta ao BÃ¡sico](arrays.html)
[Lists: Quando a Ordem Importa](lists.html)

Tip:

"Collections sÃ£o como uma famÃ­lia do crime organizado - cada uma tem seu papel, e juntas controlam toda a cidade dos dados."



# Lists: A Playlist do Baile Funk

```
LIST TYPES
â”œâ”€â”€ ArrayList (Camarote VIP)
â””â”€â”€ LinkedList (Fila do Open Bar)
```

## Fundamentos

Lists sÃ£o como uma festa funk - tem ordem, repetiÃ§Ã£o e sempre cabe mais um.

```JAVA
// Criando a lista de convidados
List<String> convidados = new ArrayList<>();
convidados.add("MC Kevinho");    // Adiciona no fim da lista
convidados.add(0, "MC Livinho"); // Fura a fila (adiciona no inÃ­cio)
```

## ArrayList vs LinkedList

### ArrayList (Camarote VIP)

```JAVA
// RÃ¡pido pra achar alguÃ©m, como camarote numerado
ArrayList<String> camarote = new ArrayList<>();
camarote.add("Anitta");
camarote.get(0);         // Acesso direto, mesa 0
```

### LinkedList (Fila do Open Bar)

```JAVA
// Melhor pra galera entrar e sair, como fila de open bar
LinkedList<String> openBar = new LinkedList<>();
openBar.addFirst("Sedento");   // Furando fila
openBar.addLast("Paciente");   // Entrando no fim
```

## OperaÃ§Ãµes BÃ¡sicas (Como Gerenciar o Baile)

### AdiÃ§Ã£o (Deixa Entrar)

```JAVA
// VÃ¡rios jeitos de deixar a galera entrar
List<String> baile = new ArrayList<>();
baile.add("DanÃ§arino");           // Fim da fila
baile.add(0, "DJ");               // VIP, direto pro inÃ­cio
baile.addAll(Arrays.asList("MC", "DJ", "Beat Maker")); // Grupo
```

### RemoÃ§Ã£o (Expulsando da Festa)

```JAVA
// Diferentes formas de expulsar
baile.remove("ConfusÃ£o");          // Remove elemento especÃ­fico
baile.remove(0);                   // Remove da posiÃ§Ã£o
baile.removeIf(x -> x.contains("Briga")); // Remove todos briguentos
```

### Acesso (Procurando na MultidÃ£o)

```JAVA
// Encontrando a galera
String vip = baile.get(0);         // Pega pela posiÃ§Ã£o
int pos = baile.indexOf("DJ");     // Onde tÃ¡ o DJ?
boolean temMC = baile.contains("MC"); // O MC chegou?
```

## Lists Especializadas (Ãreas VIP)

### Vector (Antiga Casa de Show)

```JAVA
// Synchronized por padrÃ£o, como seguranÃ§a old school
Vector<String> casaAntiga = new Vector<>();
casaAntiga.add("DanÃ§arino ClÃ¡ssico");
```

### Stack (Pilha de Caixas de Som)

```JAVA
// LIFO - Last In, First Out
Stack<String> equipamento = new Stack<>();
equipamento.push("Grave");     // Empilha
String topo = equipamento.pop(); // Desempilha
```

## OrdenaÃ§Ã£o (Organizando o Line-up)

```JAVA
// Ordenando a lista de apresentaÃ§Ãµes
List<String> lineup = new ArrayList<>();
lineup.addAll(Arrays.asList("MC Late", "DJ Early", "MC Prime"));

// Ordem alfabÃ©tica
Collections.sort(lineup);

// Ordem personalizada
lineup.sort((a, b) -> a.length() - b.length()); // Por tamanho do nome
```

## IteraÃ§Ã£o (Passando o Som)

```JAVA
// For tradicional (Contagem regressiva)
for (int i = 0; i < lineup.size(); i++) {
    System.out.println("PrÃ³ximo: " + lineup.get(i));
}

// For each (Passando o som)
for (String artista : lineup) {
    System.out.println("No palco: " + artista);
}

// Iterator (Revista na entrada)
Iterator<String> revista = lineup.iterator();
while (revista.hasNext()) {
    String pessoa = revista.next();
    if (pessoa.contains("Problema")) {
        revista.remove(); // Barrado
    }
}
```

## Dicas Pro Baile

1. Escolha Certa

* ArrayList: Quando precisa acessar rÃ¡pido

* LinkedList: Quando a galera entra e sai muito

2. Performance

```JAVA
// Define o tamanho se souber quantos vem
List<String> convidados = new ArrayList<>(100);

// Limpa a lista depois da festa
convidados.clear();
```

## ExercÃ­cios PrÃ¡ticos

1. Implemente um sistema de fila de entrada

2. Crie um gerenciador de playlists

3. Desenvolva um controlador de pedidos de mÃºsica

## PrÃ³ximos Passos

Depois de dominar as Lists, vocÃª estarÃ¡ pronto para:

1. Gerenciar qualquer tipo de sequÃªncia ordenada

2. Implementar filas e pilhas eficientes

3. Organizar dados com repetiÃ§Ã£o

[Collections Overview](collections-overview.html)
[Sets: Sem Repeteco](sets.html)

Tip:

"Lists sÃ£o como um baile funk: tem ordem, aceita repetiÃ§Ã£o e sempre cabe mais um na pista!"



# Sets: O Clube dos Ãšnicos

```
SET TYPES
â”œâ”€â”€ HashSet (Balada Alternativa)
â”œâ”€â”€ LinkedHashSet (Festa TemÃ¡tica)
â””â”€â”€ TreeSet (Clube da Alta Sociedade)
```

## Fundamentos

Sets sÃ£o como uma festa exclusiva - nÃ£o tem repetido e cada um Ã© Ãºnico.

```JAVA
// Criando a lista do clube mais exclusivo
Set<String> clubeDosUnicos = new HashSet<>();
clubeDosUnicos.add("Hipster");    // Entra
clubeDosUnicos.add("Hipster");    // Barrado! JÃ¡ tem um igual
```

## Tipos de Sets (Diferentes Baladas)

### HashSet (Balada Alternativa)

```JAVA
// RÃ¡pido e caÃ³tico, como uma rave
HashSet<String> rave = new HashSet<>();
rave.add("Raver");      // Ordem? Que ordem?
rave.add("DJ");         // Entra onde der
```

### LinkedHashSet (Festa TemÃ¡tica)

```JAVA
// MantÃ©m a ordem de entrada, como fila organizada
LinkedHashSet<String> tematica = new LinkedHashSet<>();
tematica.add("Anos 80");  // Primeiro
tematica.add("Anos 90");  // Segundo
```

### TreeSet (Clube da Alta Sociedade)

```JAVA
// Sempre ordenado, como lista de socialites
TreeSet<String> clubeSocial = new TreeSet<>();
clubeSocial.add("Baronesa");   // SerÃ¡ ordenado
clubeSocial.add("Condessa");   // Automaticamente
```

## OperaÃ§Ãµes BÃ¡sicas (Regras do Clube)

### AdiÃ§Ã£o (Tentando Entrar)

```JAVA
Set<String> clube = new HashSet<>();
clube.add("SÃ³cio");            // Bem-vindo ao clube
clube.add("SÃ³cio");            // Negado! JÃ¡ Ã© membro
clube.addAll(Arrays.asList("VIP", "Premium")); // Grupo VIP
```

### RemoÃ§Ã£o (Cancelando Sociedade)

```JAVA
// Diferentes formas de expulsar
clube.remove("Ex-sÃ³cio");       // Remove especÃ­fico
clube.removeIf(x -> x.startsWith("Inadimplente")); // Remove todos inadimplentes
```

### VerificaÃ§Ã£o (Lista na Porta)

```JAVA
// Checando quem pode entrar
boolean isMembro = clube.contains("VIP");     // EstÃ¡ na lista?
boolean todosVIP = clube.containsAll(vips);   // Grupo inteiro na lista?
```

## OperaÃ§Ãµes de Conjunto (Misturando as Tribos)

```JAVA
Set<String> metaleiros = new HashSet<>();
Set<String> punks = new HashSet<>();

// UniÃ£o (Festa de Rock)
Set<String> rockeiros = new HashSet<>(metaleiros);
rockeiros.addAll(punks);

// InterseÃ§Ã£o (Amigos em Comum)
Set<String> hibridos = new HashSet<>(metaleiros);
hibridos.retainAll(punks);

// DiferenÃ§a (SÃ³ Metaleiros)
Set<String> puristas = new HashSet<>(metaleiros);
puristas.removeAll(punks);
```

## IteraÃ§Ã£o (Fazendo a Social)

```JAVA
// For each (Cumprimentando todo mundo)
for (String socio : clube) {
    System.out.println("Boa noite, " + socio);
}

// Iterator (Revista VIP)
Iterator<String> revista = clube.iterator();
while (revista.hasNext()) {
    String pessoa = revista.next();
    if (pessoa.contains("Indesejado")) {
        revista.remove(); // Tchau!
    }
}
```

## Dicas de Etiqueta

1. Escolha do Clube

* HashSet: Quando sÃ³ importa ser Ãºnico

* LinkedHashSet: Quando a ordem de entrada importa

* TreeSet: Quando precisa manter tudo ordenado

2. Performance

```JAVA
// Define tamanho inicial se souber
Set<String> vips = new HashSet<>(100);

// Use o tipo certo pra cada ocasiÃ£o
Set<String> ordenados = new TreeSet<>();  // Sempre ordenado
```

## ExercÃ­cios PrÃ¡ticos

1. Implemente um sistema de controle de sÃ³cios

2. Crie um gerenciador de eventos exclusivos

3. Desenvolva um verificador de duplicatas

## PrÃ³ximos Passos

Depois de dominar os Sets, vocÃª estarÃ¡ pronto para:

1. Gerenciar coleÃ§Ãµes sem duplicatas

2. Implementar sistemas de membros

3. Trabalhar com conjuntos matemÃ¡ticos

[Lists: A SequÃªncia](lists.html)
[Maps: Chave e Valor](maps.html)

Tip:

"Sets sÃ£o como clubes exclusivos - nÃ£o importa quantas vezes vocÃª tente entrar, sÃ³ passa uma vez!"



# Maps: O Guarda-Volumes da Matrix

```
MAP TYPES
â”œâ”€â”€ HashMap (ArmÃ¡rio Digital)
â”œâ”€â”€ LinkedHashMap (ArmÃ¡rio com HistÃ³rico)
â””â”€â”€ TreeMap (ArmÃ¡rio Ordenado)
```

## Fundamentos

Maps sÃ£o como um guarda-volumes high-tech - cada item tem sua chave Ãºnica, e vocÃª pode guardar qualquer coisa lÃ¡ dentro.

```JAVA
// Criando um guarda-volumes digital
Map<String, String> lockers = new HashMap<>();
lockers.put("A123", "Katana Digital");    // Guarda item
lockers.get("A123");                      // Recupera item
```

## Tipos de Maps (Diferentes Sistemas)

### HashMap (ArmÃ¡rio Quantum)

```JAVA
// RÃ¡pido e aleatÃ³rio, como teletransporte
HashMap<Integer, String> quantum = new HashMap<>();
quantum.put(42, "Dados Encriptados");  // Ordem? Irrelevante!
quantum.put(7, "CÃ³digo Fonte");        // Acesso instantÃ¢neo
```

### LinkedHashMap (Registro CronolÃ³gico)

```JAVA
// MantÃ©m ordem de inserÃ§Ã£o, como log de sistema
LinkedHashMap<String, String> logs = new LinkedHashMap<>();
logs.put("09:00", "Login");    // Primeiro registro
logs.put("09:01", "Download"); // Segundo registro
```

### TreeMap (Mainframe Ordenado)

```JAVA
// Sempre ordenado pela chave, como diretÃ³rio indexado
TreeMap<String, String> mainframe = new TreeMap<>();
mainframe.put("sys.exe", "Sistema");     // OrdenaÃ§Ã£o
mainframe.put("hack.exe", "Ferramentas"); // automÃ¡tica
```

## OperaÃ§Ãµes BÃ¡sicas (Protocolos de Acesso)

### InserÃ§Ã£o (Upload)

```JAVA
Map<String, Object> database = new HashMap<>();
database.put("user.dat", new User());          // Novo registro
database.putIfAbsent("backup.dat", new Data()); // SÃ³ se nÃ£o existir
```

### RecuperaÃ§Ã£o (Download)

```JAVA
// Diferentes formas de acessar
Object data = database.get("user.dat");        // Acesso direto
Object safe = database.getOrDefault("temp.dat", new Data()); // Com fallback
```

### RemoÃ§Ã£o (Delete)

```JAVA
// Limpando registros
database.remove("temp.dat");              // Remove entrada
database.remove("user.dat", oldUser);     // Remove se valor bater
```

## NavegaÃ§Ã£o (Scanning)

```JAVA
Map<String, String> matrix = new HashMap<>();

// Iterando chaves (Scanning IDs)
for (String key : matrix.keySet()) {
    System.out.println("ID: " + key);
}

// Iterando valores (Data Mining)
for (String value : matrix.values()) {
    System.out.println("Data: " + value);
}

// Iterando pares (Full Scan)
for (Map.Entry<String, String> entry : matrix.entrySet()) {
    System.out.println(entry.getKey() + " -> " + entry.getValue());
}
```

## OperaÃ§Ãµes AvanÃ§adas (Hacks)

```JAVA
// ComputaÃ§Ã£o condicional
matrix.compute("stats", (k, v) -> v == null ? "new" : v + "_updated");

// Merge de dados
matrix.merge("downloads", 1, (old, new) -> old + new);

// OperaÃ§Ãµes em massa
matrix.replaceAll((k, v) -> v.toUpperCase());
```

## Dicas de SeguranÃ§a

1. Escolha do Sistema

* HashMap: Para acesso rÃ¡pido e aleatÃ³rio

* LinkedHashMap: Quando ordem de inserÃ§Ã£o importa

* TreeMap: Para manter chaves ordenadas

2. Performance

```JAVA
// Inicialize com tamanho se souber
Map<String, String> system = new HashMap<>(100);

// Use o tipo certo para cada operaÃ§Ã£o
Map<String, Integer> sorted = new TreeMap<>();  // Para dados ordenados
```

## ExercÃ­cios PrÃ¡ticos

1. Implemente um sistema de cache

2. Crie um gerenciador de sessÃµes

3. Desenvolva um contador de frequÃªncia

## PrÃ³ximos Passos

Depois de dominar os Maps, vocÃª estarÃ¡ pronto para:

1. Criar sistemas de armazenamento chave-valor

2. Implementar caches eficientes

3. Gerenciar dados indexados

[Sets: Exclusividade](sets.html)
[Queues: Processamento](queues.html)

Tip:

"Maps sÃ£o como o guarda-volumes da Matrix - cada segredo tem sua chave, e sÃ³ vocÃª sabe onde procurar!"



# Queues: A Fila do Banco Digital

```
QUEUE TYPES
â”œâ”€â”€ Queue (Fila Normal)
â”œâ”€â”€ Deque (Fila Premium)
â””â”€â”€ PriorityQueue (Fila Preferencial)
```

## Fundamentos

Queues sÃ£o como filas de banco digitais - primeiro a chegar, primeiro a ser atendido (FIFO).

```JAVA
// Criando uma fila digital
Queue<String> fila = new LinkedList<>();
fila.offer("Cliente#1");    // Entra na fila
String proximo = fila.poll(); // PrÃ³ximo a ser atendido
```

## Tipos de Queues

### Queue BÃ¡sica

```JAVA
Queue<String> atendimento = new LinkedList<>();
atendimento.offer("UsuÃ¡rio");  // Adiciona ao fim
atendimento.poll();            // Remove do inÃ­cio
atendimento.peek();            // Consulta prÃ³ximo
```

### Deque (Double-Ended Queue)

```JAVA
Deque<String> premium = new ArrayDeque<>();
premium.offerFirst("VIP");     // Fura fila
premium.offerLast("Regular");  // Entra normal
premium.pollFirst();           // Remove do inÃ­cio
premium.pollLast();           // Remove do fim
```

### PriorityQueue

```JAVA
// Fila com prioridades
PriorityQueue<Integer> senha = new PriorityQueue<>();
senha.offer(3);  // Organiza automaticamente
senha.offer(1);  // por ordem natural
senha.offer(2);  // ou comparador customizado
```

## OperaÃ§Ãµes Comuns

### InserÃ§Ã£o

```JAVA
Queue<String> fila = new LinkedList<>();
fila.offer("Normal");      // Preferido (retorna boolean)
fila.add("ForÃ§a");        // LanÃ§a exceÃ§Ã£o se cheio
```

### RemoÃ§Ã£o

```JAVA
String cliente = fila.poll();     // Retorna null se vazio
String proximo = fila.remove();   // LanÃ§a exceÃ§Ã£o se vazio
```

### Consulta

```JAVA
String espiar = fila.peek();      // Retorna null se vazio
String primeiro = fila.element(); // LanÃ§a exceÃ§Ã£o se vazio
```

## Casos de Uso

1. Processamento de TransaÃ§Ãµes

```JAVA
Queue<Transaction> transactions = new LinkedList<>();
transactions.offer(new Transaction("DepÃ³sito"));
processTransaction(transactions.poll());
```

1. Sistema de Mensagens

```JAVA
PriorityQueue<Message> messages = new PriorityQueue<>();
messages.offer(new Message("Urgente", 1));
messages.offer(new Message("Normal", 2));
```

## Dicas de Performance

```JAVA
// Inicialize com tamanho se souber
Queue<String> fila = new LinkedList<>(100);

// Use o tipo certo para o caso
Deque<String> rapido = new ArrayDeque<>();  // Mais eficiente que LinkedList
```

## ExercÃ­cios PrÃ¡ticos

1. Implemente um sistema de atendimento

2. Crie um processador de eventos

3. Desenvolva um escalonador de tarefas

## PrÃ³ximos Passos

Depois de dominar Queues, vocÃª estarÃ¡ pronto para:

1. Gerenciar filas de processamento

2. Implementar sistemas de mensageria

3. Criar escalonadores de tarefas

[Maps: Chave-Valor](maps.html)
[Stacks: Pilha](stacks.html)

Tip:

"Queues sÃ£o como filas digitais: justas, ordenadas e sempre processando na ordem certa!"



# Stacks: A Pilha de Downloads

```
STACK OPERATIONS
â”œâ”€â”€ push() (Upload)
â”œâ”€â”€ pop()  (Download)
â””â”€â”€ peek() (Preview)
```

## Fundamentos

Stacks sÃ£o como uma pilha de downloads - o Ãºltimo arquivo baixado Ã© o primeiro que vocÃª acessa (LIFO).

```JAVA
// Criando uma pilha de downloads
Stack<String> downloads = new Stack<>();
downloads.push("arquivo.zip");    // Adiciona no topo
String ultimo = downloads.pop();  // Remove do topo
```

## OperaÃ§Ãµes BÃ¡sicas

### Push (Upload)

```JAVA
Stack<String> stack = new Stack<>();
stack.push("Camada 1");  // Base
stack.push("Camada 2");  // Meio
stack.push("Camada 3");  // Topo
```

### Pop (Download)

```JAVA
String top = stack.pop();     // Remove e retorna topo
String peek = stack.peek();   // SÃ³ espia o topo
boolean vazia = stack.empty(); // Checa se estÃ¡ vazia
```

### Busca

```JAVA
int posicao = stack.search("Camada 1"); // Busca na pilha
// Retorna posiÃ§Ã£o (1 = topo) ou -1 se nÃ£o encontrar
```

## Casos de Uso

### 1. HistÃ³rico de NavegaÃ§Ã£o

```JAVA
Stack<String> historico = new Stack<>();
historico.push("homepage.html");
historico.push("perfil.html");
String voltar = historico.pop(); // Volta pÃ¡gina
```

### 2. Desfazer/Refazer

```JAVA
Stack<Command> undoStack = new Stack<>();
undoStack.push(new Command("save"));
Command lastCommand = undoStack.pop(); // Desfaz
```

### 3. ValidaÃ§Ã£o de Sintaxe

```JAVA
Stack<Character> brackets = new Stack<>();
brackets.push('{');  // Abre
char close = brackets.pop(); // Fecha
// VÃ¡lido se stack vazia no final
```

## ImplementaÃ§Ã£o Alternativa

```JAVA
// Usando Deque como Stack (mais moderno)
Deque<String> stack = new ArrayDeque<>();
stack.push("Novo");
String top = stack.pop();
```

## Dicas de Performance

```JAVA
// Vector Ã© thread-safe mas mais lento
Stack<Integer> threadsafe = new Stack<>();

// ArrayDeque Ã© mais rÃ¡pido mas nÃ£o thread-safe
Deque<Integer> fast = new ArrayDeque<>();
```

## ExercÃ­cios PrÃ¡ticos

1. Implemente um verificador de parÃªnteses

2. Crie um sistema de desfazer/refazer

3. Desenvolva um navegador simplificado

## PrÃ³ximos Passos

Depois de dominar Stacks, vocÃª estarÃ¡ pronto para:

1. Implementar histÃ³ricos e navegaÃ§Ã£o

2. Criar sistemas de desfazer/refazer

3. Validar expressÃµes e sintaxe

[Queues: Filas](queues.html)
[Collections Projects](collections-projects.html)

Tip:

"Stacks sÃ£o como downloads: o Ãºltimo que chegou Ã© o primeiro que vocÃª acessa!"



# Projetos PrÃ¡ticos: Collections em AÃ§Ã£o

## Projeto 1: Task Manager (Lista de Contratos)

### Objetivo

Criar um sistema de gerenciamento de tarefas usando diferentes Collections.

```JAVA
public class TaskManager {
    private List<Task> allTasks = new ArrayList<>();
    private Map<String, Task> taskById = new HashMap<>();
    private PriorityQueue<Task> urgentTasks = new PriorityQueue<>();
    
    public void addTask(Task task) {
        allTasks.add(task);
        taskById.put(task.getId(), task);
        if (task.isUrgent()) {
            urgentTasks.offer(task);
        }
    }
    
    public Task getNextUrgentTask() {
        return urgentTasks.poll();
    }
}
```

### Funcionalidades

* Adicionar/remover tarefas

* PriorizaÃ§Ã£o automÃ¡tica

* Busca por ID/status

* HistÃ³rico de alteraÃ§Ãµes

## Projeto 2: Inventory System (Controle de Arsenal)

### Objetivo

Implementar um sistema de inventÃ¡rio com controle de estoque.

```JAVA
public class InventorySystem {
    private Map<String, Item> inventory = new HashMap<>();
    private Set<String> lowStock = new HashSet<>();
    private Queue<Order> pendingOrders = new LinkedList<>();
    
    public void addItem(Item item) {
        inventory.put(item.getCode(), item);
        checkStock(item);
    }
    
    private void checkStock(Item item) {
        if (item.getQuantity() < item.getMinimum()) {
            lowStock.add(item.getCode());
            createRestockOrder(item);
        }
    }
}
```

### Funcionalidades

* Controle de estoque

* Alertas de baixo estoque

* Processamento de pedidos

* RelatÃ³rios de inventÃ¡rio

## Projeto 3: Cache Implementation (MemÃ³ria TemporÃ¡ria)

### Objetivo

Desenvolver um sistema de cache com polÃ­tica de expiraÃ§Ã£o.

```JAVA
public class CacheSystem<K, V> {
    private Map<K, CacheEntry<V>> cache = new LinkedHashMap<>();
    private Queue<K> expirationQueue = new PriorityQueue<>();
    
    public void put(K key, V value, long ttl) {
        cache.put(key, new CacheEntry<>(value, ttl));
        expirationQueue.offer(key);
        cleanExpired();
    }
    
    public V get(K key) {
        CacheEntry<V> entry = cache.get(key);
        return (entry != null && !entry.isExpired()) ? entry.getValue() : null;
    }
}
```

### Funcionalidades

* Cache com TTL (Time To Live)

* PolÃ­tica LRU (Least Recently Used)

* Limpeza automÃ¡tica

* EstatÃ­sticas de hit/miss

## Desafios Extras

### 1. Sistema Multi-Thread

```JAVA
public class ThreadSafeTaskManager {
    private final ConcurrentHashMap<String, Task> tasks = new ConcurrentHashMap<>();
    private final BlockingQueue<Task> taskQueue = new LinkedBlockingQueue<>();
    
    public void processTask() {
        while (true) {
            Task task = taskQueue.take(); // Bloqueia atÃ© ter tarefa
            executeTask(task);
        }
    }
}
```

### 2. Sistema de Eventos

```JAVA
public class EventSystem {
    private final Deque<Event> eventHistory = new ArrayDeque<>();
    private final Map<String, List<EventHandler>> handlers = new HashMap<>();
    
    public void emit(Event event) {
        eventHistory.push(event);
        notifyHandlers(event);
    }
    
    public void undo() {
        if (!eventHistory.isEmpty()) {
            revertEvent(eventHistory.pop());
        }
    }
}
```

## PrÃ³ximos Passos

1. Implemente os projetos base

2. Adicione funcionalidades extras

3. Otimize o cÃ³digo

4. Adicione testes unitÃ¡rios

5. Documente seu cÃ³digo

[Stacks: Pilhas](stacks.html)
[OOP Fundamentals](oop-fundamentals.html)

Tip:

"A verdadeira maestria vem da prÃ¡tica. Cada projeto Ã© uma chance de aperfeiÃ§oar suas habilidades!"



# Task Manager: Gerenciador de Tarefas Digital

## Objetivo do Projeto

Criar um gerenciador de tarefas simples usando arrays e collections bÃ¡sicas.

## Estruturas de Dados Utilizadas

```JAVA
// Lista de tarefas usando array
String[] tarefas = new String[100];
int[] prioridades = new int[100];
boolean[] concluidas = new boolean[100];
int totalTarefas = 0;

// Lista dinÃ¢mica usando ArrayList
ArrayList<String> tarefasDinamicas = new ArrayList<>();

// Fila de tarefas urgentes
Queue<String> tarefasUrgentes = new LinkedList<>();

// Mapa para busca rÃ¡pida
HashMap<String, Integer> indiceTarefas = new HashMap<>();
```

## Funcionalidades Principais

### 1. Adicionar Tarefa

```JAVA
public static void adicionarTarefa(String tarefa, int prioridade) {
    if (totalTarefas < tarefas.length) {
        tarefas[totalTarefas] = tarefa;
        prioridades[totalTarefas] = prioridade;
        concluidas[totalTarefas] = false;
        
        // Adiciona nas estruturas dinÃ¢micas
        tarefasDinamicas.add(tarefa);
        indiceTarefas.put(tarefa, totalTarefas);
        
        if (prioridade > 8) {
            tarefasUrgentes.offer(tarefa);
        }
        
        totalTarefas++;
        System.out.println("Tarefa adicionada: " + tarefa);
    }
}
```

### 2. Listar Tarefas

```JAVA
public static void listarTarefas() {
    System.out.println("\n=== Lista de Tarefas ===");
    for (int i = 0; i < totalTarefas; i++) {
        String status = concluidas[i] ? "[X]" : "[ ]";
        System.out.printf("%s %s (Prioridade: %d)%n", 
            status, tarefas[i], prioridades[i]);
    }
}
```

### 3. Marcar Como ConcluÃ­da

```JAVA
public static void concluirTarefa(String tarefa) {
    Integer indice = indiceTarefas.get(tarefa);
    if (indice != null) {
        concluidas[indice] = true;
        System.out.println("Tarefa concluÃ­da: " + tarefa);
    }
}
```

### 4. Buscar Tarefas

```JAVA
public static void buscarTarefa(String termo) {
    System.out.println("\n=== Resultados da Busca ===");
    for (int i = 0; i < totalTarefas; i++) {
        if (tarefas[i].toLowerCase().contains(termo.toLowerCase())) {
            System.out.println("- " + tarefas[i]);
        }
    }
}
```

### 5. PrÃ³xima Tarefa Urgente

```JAVA
public static String proximaTarefaUrgente() {
    return tarefasUrgentes.poll();
}
```

## Exemplo de Uso

```JAVA
public static void main(String[] args) {
    // Adicionar algumas tarefas
    adicionarTarefa("Debugar cÃ³digo", 9);
    adicionarTarefa("Backup sistema", 7);
    adicionarTarefa("Atualizar firewall", 10);
    
    // Listar todas as tarefas
    listarTarefas();
    
    // Concluir uma tarefa
    concluirTarefa("Backup sistema");
    
    // Buscar tarefas
    buscarTarefa("firewall");
    
    // Verificar prÃ³xima tarefa urgente
    String urgente = proximaTarefaUrgente();
    System.out.println("PrÃ³xima urgente: " + urgente);
}
```

## Desafios para Praticar

1. Filtrar por Prioridade

```JAVA
public static void filtrarPorPrioridade(int minimo) {
    for (int i = 0; i < totalTarefas; i++) {
        if (prioridades[i] >= minimo) {
            System.out.println(tarefas[i]);
        }
    }
}
```

1. Remover Tarefa

```JAVA
public static void removerTarefa(String tarefa) {
    Integer indice = indiceTarefas.get(tarefa);
    if (indice != null) {
        // Shift elements
        for (int i = indice; i < totalTarefas - 1; i++) {
            tarefas[i] = tarefas[i + 1];
            prioridades[i] = prioridades[i + 1];
            concluidas[i] = concluidas[i + 1];
        }
        totalTarefas--;
        
        // Atualizar estruturas dinÃ¢micas
        tarefasDinamicas.remove(tarefa);
        indiceTarefas.remove(tarefa);
    }
}
```

## ExercÃ­cios Propostos

1. Implementar ordenaÃ§Ã£o por prioridade

2. Adicionar data limite para tarefas

3. Criar filtro por status (pendente/concluÃ­da)

4. Implementar sistema de tags usando arrays

5. Adicionar persistÃªncia em arquivo texto

## PrÃ³ximos Passos

* [Inventory System](inventory-system.html)

* [Cache Implementation](cache-implementation.html)

Tip:

"Uma tarefa bem organizada Ã© uma tarefa meio feita!"



# Sistema de InventÃ¡rio (Arsenal)

Um sistema de inventÃ¡rio cyberpunk para gerenciar equipamentos e recursos.

## Objetivos de Aprendizado

* Implementar um sistema usando `Map`, `Set` e `Queue`

* Gerenciar estoque com estruturas de dados apropriadas

* Aplicar lÃ³gica de negÃ³cios com coleÃ§Ãµes

## Conceitos Aplicados

* HashMap para armazenamento principal

* HashSet para itens em baixo estoque

* Queue para pedidos pendentes

* Encapsulamento de dados

* ValidaÃ§Ãµes de negÃ³cio

## ImplementaÃ§Ã£o Base

### Classe Item

```JAVA
public class Item {
    private String code;
    private String name;
    private int quantity;
    private int minimum;
    private double price;

    public Item(String code, String name, int quantity, int minimum, double price) {
        this.code = code;
        this.name = name;
        this.quantity = quantity;
        this.minimum = minimum;
        this.price = price;
    }

    // Getters e Setters
    public String getCode() { return code; }
    public String getName() { return name; }
    public int getQuantity() { return quantity; }
    public int getMinimum() { return minimum; }
    public double getPrice() { return price; }

    public void setQuantity(int quantity) { this.quantity = quantity; }
}
```

### Classe Order

```JAVA
public class Order {
    private String itemCode;
    private int quantity;
    private String status;

    public Order(String itemCode, int quantity) {
        this.itemCode = itemCode;
        this.quantity = quantity;
        this.status = "PENDING";
    }

    // Getters e Setters
    public String getItemCode() { return itemCode; }
    public int getQuantity() { return quantity; }
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
}
```

### Sistema Principal

```JAVA
public class InventorySystem {
    private Map<String, Item> inventory = new HashMap<>();
    private Set<String> lowStock = new HashSet<>();
    private Queue<Order> pendingOrders = new LinkedList<>();
    
    // Adicionar item ao inventÃ¡rio
    public void addItem(Item item) {
        inventory.put(item.getCode(), item);
        checkStock(item);
    }
    
    // Verificar nÃ­vel de estoque
    private void checkStock(Item item) {
        if (item.getQuantity() < item.getMinimum()) {
            lowStock.add(item.getCode());
            createRestockOrder(item);
        }
    }
    
    // Criar pedido de reposiÃ§Ã£o
    private void createRestockOrder(Item item) {
        int orderQuantity = item.getMinimum() - item.getQuantity();
        Order order = new Order(item.getCode(), orderQuantity);
        pendingOrders.offer(order);
    }
    
    // Remover item do inventÃ¡rio
    public void removeItem(String code) {
        inventory.remove(code);
        lowStock.remove(code);
    }
    
    // Atualizar quantidade
    public void updateQuantity(String code, int quantity) {
        Item item = inventory.get(code);
        if (item != null) {
            item.setQuantity(quantity);
            checkStock(item);
        }
    }
    
    // Listar itens em baixo estoque
    public Set<String> getLowStockItems() {
        return new HashSet<>(lowStock);
    }
    
    // Processar prÃ³ximo pedido
    public Order processNextOrder() {
        return pendingOrders.poll();
    }
}
```

## Exemplo de Uso

```JAVA
public class InventoryDemo {
    public static void main(String[] args) {
        InventorySystem system = new InventorySystem();
        
        // Adicionar itens
        system.addItem(new Item("HACK001", "NetHack Module", 5, 10, 299.99));
        system.addItem(new Item("DECK002", "CyberDeck", 2, 5, 999.99));
        
        // Verificar baixo estoque
        Set<String> lowStock = system.getLowStockItems();
        System.out.println("Itens em baixo estoque: " + lowStock);
        
        // Processar pedidos
        Order nextOrder = system.processNextOrder();
        if (nextOrder != null) {
            System.out.println("Processando pedido: " + nextOrder.getItemCode());
        }
    }
}
```

## ExercÃ­cios Propostos

1. Implementar RelatÃ³rios

* Gerar relatÃ³rio de valor total do inventÃ¡rio

* Listar itens por faixa de preÃ§o

* Calcular estatÃ­sticas de pedidos

2. Adicionar ValidaÃ§Ãµes

* Verificar cÃ³digos duplicados

* Validar quantidades negativas

* Implementar limites de estoque

3. Expandir Funcionalidades

* Adicionar categorias de itens

* Implementar sistema de alertas

* Criar histÃ³rico de transaÃ§Ãµes

## Desafios AvanÃ§ados

1. Sistema de Prioridade

* Implementar PriorityQueue para pedidos

* Definir critÃ©rios de priorizaÃ§Ã£o

* Gerenciar pedidos urgentes

2. PersistÃªncia de Dados

* Salvar estado do inventÃ¡rio

* Carregar dados de arquivo

* Implementar backup automÃ¡tico

## Dicas de ImplementaÃ§Ã£o

* Use enums para status e categorias

* Implemente tratamento de exceÃ§Ãµes

* Mantenha o cÃ³digo modular

* Documente as funcionalidades

* Adicione logs de operaÃ§Ãµes

## PrÃ³ximos Passos

* [Cache Implementation](cache-implementation.html)

* [Collections Overview](collections-overview.html)

* [Maps](maps.html)

Tip:

"Um bom arsenal nÃ£o Ã© apenas sobre quantidade, mas sobre organizaÃ§Ã£o e controle."



# ImplementaÃ§Ã£o de Cache

Um sistema de cache Ã© uma estrutura de dados que armazena temporariamente dados frequentemente acessados para melhorar a performance. Neste projeto, implementaremos um cache simples usando arrays e conceitos bÃ¡sicos de Java.

## Arquitetura do Sistema

```MERMAID
graph TD
    A[Cliente] --> B[Cache]
    B --> C[Armazenamento]
    B --> D[EstatÃ­sticas]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
```

## Componentes Principais

### Estrutura de Dados

* Arrays paralelos para chaves e valores

* Array para timestamps

* Array para contagem de acessos

* Controle de capacidade e tamanho atual

### OperaÃ§Ãµes BÃ¡sicas

* InserÃ§Ã£o/atualizaÃ§Ã£o de itens

* Busca por chave

* SubstituiÃ§Ã£o de itens menos usados

* Monitoramento de estatÃ­sticas

## ImplementaÃ§Ã£o Base

### SimpleCache.java

```JAVA
public class SimpleCache {
    private String[] keys;
    private String[] values;
    private long[] timestamps;
    private int[] accessCount;
    private int capacity;
    private int size;
    
    public SimpleCache(int maxSize) {
        capacity = maxSize;
        keys = new String[capacity];
        values = new String[capacity];
        timestamps = new long[capacity];
        accessCount = new int[capacity];
        size = 0;
    }
    
    // MÃ©todos principais aqui...
}
```

### PolÃ­tica de SubstituiÃ§Ã£o

O cache utiliza a estratÃ©gia LFU (Least Frequently Used):

1. MantÃ©m contagem de acessos para cada item

2. Quando o cache estÃ¡ cheio, remove o item menos acessado

3. Em caso de empate, mantÃ©m o item mais antigo

## Interface de UsuÃ¡rio

### Menu Principal

```JAVA
System.out.println("\n=== Sistema de Cache ===");
System.out.println("1. Adicionar/Atualizar item");
System.out.println("2. Buscar item");
System.out.println("3. Mostrar estatÃ­sticas");
System.out.println("4. Sair");
```

### VisualizaÃ§Ã£o de EstatÃ­sticas

```
=== Cache Stats ===
Capacity: 5
Current Size: 3

Cache Contents:
Key | Value | Access Count | Age (ms)
------------------------------------
key1 | value1 | 3 | 1500
key2 | value2 | 1 | 1000
key3 | value3 | 2 | 500
```

## Desafios de ExtensÃ£o

1. Implementar Cache GenÃ©rico

```JAVA
public class GenericCache<K, V> {
    private K[] keys;
    private V[] values;
    // ...
}
```

1. Adicionar ExpiraÃ§Ã£o de Items

```JAVA
public boolean isExpired(String key) {
    int index = findKey(key);
    if (index != -1) {
        long age = System.currentTimeMillis() - timestamps[index];
        return age > expirationTime;
    }
    return true;
}
```

1. Implementar Diferentes PolÃ­ticas

* LRU (Least Recently Used)

* FIFO (First In First Out)

* Random Replacement

## PrÃ³ximos Passos

1. Adicione suporte a tipos genÃ©ricos

2. Implemente expiraÃ§Ã£o de itens

3. Crie diferentes polÃ­ticas de substituiÃ§Ã£o

4. Adicione persistÃªncia em arquivo

5. Implemente cache distribuÃ­do

## Conceitos Aplicados

* Arrays e manipulaÃ§Ã£o

* Tipos primitivos

* Strings

* Estruturas de controle

* MÃ©todos e classes

* Entrada/saÃ­da bÃ¡sica

## Dicas de ImplementaÃ§Ã£o

1. Mantenha o cÃ³digo organizado e bem documentado

2. Use constantes para valores fixos

3. Implemente validaÃ§Ãµes de entrada

4. Adicione logs para depuraÃ§Ã£o

5. Considere casos de erro

## ExercÃ­cios Propostos

1. Implemente um cache com limite de tempo

2. Crie um cache que persiste em arquivo

3. Adicione suporte a mÃºltiplos tipos de dados

4. Implemente estatÃ­sticas avanÃ§adas

5. Crie testes unitÃ¡rios

[Inventory System](inventory-system.html)



# Fundamentos da ProgramaÃ§Ã£o Orientada a Objetos

## O que Ã© OOP?

A ProgramaÃ§Ã£o Orientada a Objetos (OOP) Ã© um paradigma de programaÃ§Ã£o que organiza o cÃ³digo em objetos, que contÃªm dados e cÃ³digo. Os objetos sÃ£o instÃ¢ncias de classes, que servem como blueprints para criar objetos.

## Pilares da OOP

```MERMAID
graph TD
    A[OOP] --> B[Encapsulamento]
    A --> C[HeranÃ§a]
    A --> D[Polimorfismo]
    A --> E[AbstraÃ§Ã£o]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#00ff00
```

### Encapsulamento

* Oculta detalhes internos

* Protege dados sensÃ­veis

* Reduz complexidade

### HeranÃ§a

* Reutiliza cÃ³digo

* Estabelece hierarquias

* Especializa comportamentos

### Polimorfismo

* Flexibiliza interfaces

* Adapta comportamentos

* Simplifica cÃ³digo

### AbstraÃ§Ã£o

* Modela conceitos

* Simplifica problemas

* Define interfaces

## Conceitos Fundamentais

### Classes e Objetos

```JAVA
public class Netrunner {
    private String codename;
    private int skillLevel;

    public Netrunner(String codename) {
        this.codename = codename;
        this.skillLevel = 1;
    }
}
```

### Atributos e MÃ©todos

```JAVA
public class CyberDeck {
    // Atributos
    private int power;
    private String model;

    // MÃ©todos
    public void upgrade() {
        this.power++;
    }
}
```

## BenefÃ­cios da OOP

1. Manutenibilidade

* CÃ³digo organizado

* FÃ¡cil de atualizar

* Modular

2. Reusabilidade

* Componentes reutilizÃ¡veis

* Menos duplicaÃ§Ã£o

* Economia de tempo

3. Flexibilidade

* FÃ¡cil de estender

* AdaptÃ¡vel

* EscalÃ¡vel

4. SeguranÃ§a

* Controle de acesso

* Dados protegidos

* CÃ³digo seguro

## PrÃ¡ticas Recomendadas

### Nomenclatura

* Classes: PascalCase

* MÃ©todos: camelCase

* VariÃ¡veis: camelCase

* Constantes: UPPER_CASE

### OrganizaÃ§Ã£o

* Uma classe por arquivo

* Pacotes lÃ³gicos

* Hierarquia clara

### PrincÃ­pios

* Single Responsibility

* Open/Closed

* Liskov Substitution

* Interface Segregation

* Dependency Inversion

## PrÃ³ximos Passos

1. Classes e Objetos

2. Encapsulamento

3. HeranÃ§a

4. Polimorfismo

5. Interfaces e Classes Abstratas

6. Records

7. Sealed Classes

8. Projetos PrÃ¡ticos

## Conceitos Relacionados

* Design Patterns

* SOLID Principles

* Clean Code

* Refactoring

* Testing

[Classes e Objetos](classes-objects.html)

Tip:

"Na Matrix da programaÃ§Ã£o, objetos sÃ£o as unidades fundamentais de poder. Domine-os, e vocÃª dominarÃ¡ o cÃ³digo."



# Classes e Objetos

## Conceito Base

Uma classe Ã© um template para criar objetos, definindo seus atributos e comportamentos. Um objeto Ã© uma instÃ¢ncia de uma classe.

```MERMAID
graph TD
    A[Classe] -->|instancia| B[Objeto]
    B -->|contÃ©m| C[Atributos]
    B -->|contÃ©m| D[MÃ©todos]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
```

## Estrutura de uma Classe

```JAVA
public class CyberHacker {
    // Atributos
    private String handle;
    private int level;
    private double credits;

    // Construtor
    public CyberHacker(String handle) {
        this.handle = handle;
        this.level = 1;
        this.credits = 1000.0;
    }

    // MÃ©todos
    public void hackSystem() {
        this.level++;
        this.credits += 500;
    }
}
```

## Criando Objetos

```JAVA
// Instanciando objetos
CyberHacker hacker1 = new CyberHacker("Shadowbyte");
CyberHacker hacker2 = new CyberHacker("NetPhantom");

// Usando objetos
hacker1.hackSystem();
```

## Componentes Principais

### Atributos

* Representam estado

* Definem caracterÃ­sticas

* Armazenam dados

### MÃ©todos

* Definem comportamento

* Manipulam atributos

* Executam operaÃ§Ãµes

### Construtores

* Inicializam objetos

* Configuram estado inicial

* Validam parÃ¢metros

## Boas PrÃ¡ticas

1. NomeaÃ§Ã£o

* Classes: PascalCase

* MÃ©todos/Atributos: camelCase

2. OrganizaÃ§Ã£o

* Um arquivo por classe

* Agrupamento lÃ³gico

* Pacotes estruturados

3. Responsabilidade

* PropÃ³sito Ãºnico

* CoesÃ£o alta

* Acoplamento baixo

## ExercÃ­cios PrÃ¡ticos

```JAVA
public class DataMatrix {
    private String[] data;
    private int securityLevel;

    // Implemente os mÃ©todos:
    // 1. Construtor
    // 2. encrypt()
    // 3. decrypt()
    // 4. updateSecurity()
}
```

## PrÃ³ximos Passos

[Encapsulamento](encapsulation.html)

Tip:

"No grid digital, cada objeto Ã© um nÃ³ de poder. Construa-os com sabedoria."



# Encapsulamento

## Conceito Base

Encapsulamento Ã© o princÃ­pio de ocultar detalhes internos e fornecer uma interface controlada para interaÃ§Ã£o.

```MERMAID
graph TD
    A[Classe] -->|protege| B[Dados Privados]
    A -->|expÃµe| C[Interface PÃºblica]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
```

## ImplementaÃ§Ã£o

```JAVA
public class SecureDataVault {
    // Dados privados
    private String[] encryptedData;
    private int accessLevel;
    private boolean isLocked;

    // Interface pÃºblica
    public void storeData(String data) {
        if (!isLocked) {
            // LÃ³gica de armazenamento
        }
    }

    public String retrieveData(int index) {
        if (validateAccess()) {
            return encryptedData[index];
        }
        return null;
    }

    private boolean validateAccess() {
        // LÃ³gica de validaÃ§Ã£o
        return accessLevel > 2;
    }
}
```

## Modificadores de Acesso

1. private

* Acesso apenas na classe

* MÃ¡xima proteÃ§Ã£o

* Dados sensÃ­veis

2. protected

* Acesso na hierarquia

* Classes derivadas

* Pacote atual

3. public

* Acesso universal

* Interface externa

* API pÃºblica

## Getters e Setters

```JAVA
public class CyberAccount {
    private double credits;
    private String owner;

    // Getter
    public double getCredits() {
        return credits;
    }

    // Setter com validaÃ§Ã£o
    public void setCredits(double amount) {
        if (amount >= 0) {
            this.credits = amount;
        }
    }
}
```

## BenefÃ­cios

1. SeguranÃ§a

* Controle de acesso

* ValidaÃ§Ã£o de dados

* ProteÃ§Ã£o de estado

2. ManutenÃ§Ã£o

* MudanÃ§as internas

* EvoluÃ§Ã£o segura

* Debugging simples

3. Flexibilidade

* Interface estÃ¡vel

* ImplementaÃ§Ã£o variÃ¡vel

* Versionamento

## ExercÃ­cios PrÃ¡ticos

```JAVA
public class SecuritySystem {
    // Implemente:
    // 1. Dados privados
    // 2. Getters/Setters
    // 3. ValidaÃ§Ãµes
    // 4. MÃ©todos de acesso
}
```

## PrÃ³ximos Passos

[HeranÃ§a](inheritance.html)

Tip:

"Na matrix, a informaÃ§Ã£o Ã© poder. Proteja-a com encapsulamento."



# HeranÃ§a

## Conceito Base

HeranÃ§a permite que uma classe herde atributos e mÃ©todos de outra, estabelecendo uma relaÃ§Ã£o "Ã© um" entre classes.

```MERMAID
graph TD
    A[Netrunner] -->|herda de| B[Hacker]
    B -->|herda de| C[CyberOperator]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
```

## ImplementaÃ§Ã£o BÃ¡sica

```JAVA
public class CyberOperator {
    protected String codename;
    protected int accessLevel;

    public CyberOperator(String codename) {
        this.codename = codename;
        this.accessLevel = 1;
    }

    public void accessNetwork() {
        System.out.println("Basic network access");
    }
}

public class Hacker extends CyberOperator {
    private int hackingSkill;

    public Hacker(String codename) {
        super(codename);
        this.hackingSkill = 50;
    }

    @Override
    public void accessNetwork() {
        System.out.println("Advanced network access");
    }
}
```

## Tipos de HeranÃ§a

### HeranÃ§a Simples

```JAVA
public class Netrunner extends Hacker {
    private String[] cyberdeckModules;
    
    public Netrunner(String codename) {
        super(codename);
        this.cyberdeckModules = new String[]{"Basic"};
    }
}
```

### Hierarquia de Classes

* Superclasse (pai)

* Subclasse (filho)

* Cadeia de heranÃ§a

## Palavra-chave super

```JAVA
public class ICEBreaker extends Netrunner {
    public ICEBreaker(String codename) {
        super(codename);  // Chama construtor pai
    }

    @Override
    public void accessNetwork() {
        super.accessNetwork();  // Chama mÃ©todo pai
        System.out.println("Breaking ICE protocols");
    }
}
```

## Boas PrÃ¡ticas

1. ComposiÃ§Ã£o vs HeranÃ§a

* Prefira composiÃ§Ã£o

* Evite hierarquias profundas

* Mantenha coesÃ£o

2. PrincÃ­pio LSP

* SubstituiÃ§Ã£o de Liskov

* Comportamento consistente

* Contratos respeitados

3. DocumentaÃ§Ã£o

* Documente extensÃµes

* Explique sobreposiÃ§Ãµes

* Defina contratos

## ExercÃ­cios PrÃ¡ticos

```JAVA
// Implemente:
public class SecuritySystem {
    // Base para sistema de seguranÃ§a
}

public class FirewallSystem extends SecuritySystem {
    // Sistema especÃ­fico de firewall
}

public class IntrusionDetection extends SecuritySystem {
    // Sistema de detecÃ§Ã£o
}
```

## PrÃ³ximos Passos

[Polimorfismo](polymorphism.html)

Tip:

"Na hierarquia do cÃ³digo, cada classe herda o poder de seus ancestrais."



# Polimorfismo

## Conceito Base

Polimorfismo permite que objetos de diferentes classes sejam tratados como objetos de uma classe comum, possibilitando comportamentos diferentes atravÃ©s da mesma interface.

```MERMAID
graph TD
    A[CyberProgram] -->|executa como| B[Virus]
    A -->|executa como| C[Firewall]
    A -->|executa como| D[DataMiner]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
```

## Tipos de Polimorfismo

### Sobrescrita (Override)

```JAVA
public class CyberProgram {
    public void execute() {
        System.out.println("Running base program");
    }
}

public class Virus extends CyberProgram {
    @Override
    public void execute() {
        System.out.println("Infiltrating system");
    }
}
```

### Sobrecarga (Overload)

```JAVA
public class DataMiner {
    public void mine(String data) {
        // Processa string
    }

    public void mine(byte[] data) {
        // Processa bytes
    }

    public void mine(String data, int depth) {
        // Processa com profundidade
    }
}
```

## Polimorfismo em AÃ§Ã£o

```JAVA
public class SystemInterface {
    public void executeProgram(CyberProgram program) {
        program.execute();  // Polimorfismo em tempo de execuÃ§Ã£o
    }

    public static void main(String[] args) {
        SystemInterface system = new SystemInterface();
        
        CyberProgram virus = new Virus();
        CyberProgram firewall = new Firewall();
        
        system.executeProgram(virus);    // Executa como Virus
        system.executeProgram(firewall); // Executa como Firewall
    }
}
```

## BenefÃ­cios

1. Flexibilidade

* CÃ³digo genÃ©rico

* Extensibilidade

* Manutenibilidade

2. ReutilizaÃ§Ã£o

* Interfaces comuns

* Comportamento variÃ¡vel

* CÃ³digo limpo

3. AbstraÃ§Ã£o

* SimplificaÃ§Ã£o

* Encapsulamento

* Modularidade

## PadrÃµes Comuns

### Factory Method

```JAVA
public interface CyberTool {
    void activate();
}

public class ToolFactory {
    public CyberTool createTool(String type) {
        return switch (type) {
            case "hack" -> new HackTool();
            case "scan" -> new ScanTool();
            default -> throw new IllegalArgumentException();
        };
    }
}
```

### Strategy Pattern

```JAVA
public interface AttackStrategy {
    void execute();
}

public class CyberAttack {
    private AttackStrategy strategy;
    
    public void setStrategy(AttackStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void execute() {
        strategy.execute();
    }
}
```

## ExercÃ­cios PrÃ¡ticos

```JAVA
// Implemente diferentes tipos de programas:
public interface Program {
    void run();
    void stop();
    String getStatus();
}

// Crie implementaÃ§Ãµes para:
// 1. DataAnalyzer
// 2. NetworkScanner
// 3. SecurityMonitor
```

## PrÃ³ximos Passos

[Interfaces e Classes Abstratas](interfaces-abstract.html)

Tip:

"No ciberespaÃ§o, um programa pode assumir muitas formas. O poder estÃ¡ na adaptaÃ§Ã£o."



# Interfaces e Classes Abstratas

## Interfaces

### DefiniÃ§Ã£o BÃ¡sica

```JAVA
public interface CyberSystem {
    void initialize();
    void shutdown();
    boolean isRunning();
    
    default void restart() {
        shutdown();
        initialize();
    }
}
```

### ImplementaÃ§Ã£o MÃºltipla

```JAVA
public interface Hackable {
    void breach();
    int getSecurityLevel();
}

public class SecurityGateway implements CyberSystem, Hackable {
    private boolean active;
    private int secLevel;

    @Override
    public void initialize() {
        active = true;
    }

    @Override
    public void shutdown() {
        active = false;
    }

    @Override
    public boolean isRunning() {
        return active;
    }

    @Override
    public void breach() {
        secLevel--;
    }

    @Override
    public int getSecurityLevel() {
        return secLevel;
    }
}
```

## Classes Abstratas

### Estrutura Base

```JAVA
public abstract class NetworkNode {
    protected String id;
    protected boolean connected;

    public NetworkNode(String id) {
        this.id = id;
        this.connected = false;
    }

    public abstract void processData(byte[] data);
    
    public void connect() {
        connected = true;
    }
}
```

### ImplementaÃ§Ã£o Concreta

```JAVA
public class DataNode extends NetworkNode {
    private DataProcessor processor;

    public DataNode(String id) {
        super(id);
        this.processor = new DataProcessor();
    }

    @Override
    public void processData(byte[] data) {
        if (connected) {
            processor.analyze(data);
        }
    }
}
```

## ComparaÃ§Ã£o

### Interface vs Classe Abstrata

```MERMAID
graph TD
    A[Interface] -->|CaracterÃ­sticas| B[MÃºltipla implementaÃ§Ã£o<br>Apenas assinaturas<br>MÃ©todos default]
    C[Classe Abstrata] -->|CaracterÃ­sticas| D[HeranÃ§a Ãºnica<br>Estado e comportamento<br>Construtor]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
```

## PadrÃµes de Uso

### Interface Funcional

```JAVA
@FunctionalInterface
public interface DataFilter {
    boolean test(byte[] data);
    
    static DataFilter combine(DataFilter f1, DataFilter f2) {
        return data -> f1.test(data) && f2.test(data);
    }
}
```

### Template Method

```JAVA
public abstract class CyberOperation {
    public final void execute() {
        preCheck();
        runOperation();
        postCheck();
    }

    protected abstract void runOperation();
    
    protected void preCheck() {
        // ImplementaÃ§Ã£o padrÃ£o
    }
    
    protected void postCheck() {
        // ImplementaÃ§Ã£o padrÃ£o
    }
}
```

## ExercÃ­cios PrÃ¡ticos

```JAVA
// 1. Crie uma hierarquia de sistemas de seguranÃ§a
public interface SecurityProtocol {
    void authenticate();
    void encrypt(byte[] data);
    void decrypt(byte[] data);
}

// 2. Implemente um sistema de logs abstrato
public abstract class LogSystem {
    // Implemente mÃ©todos comuns e abstratos
}

// 3. Desenvolva diferentes tipos de nÃ³s de rede
public interface NetworkComponent {
    // Defina operaÃ§Ãµes de rede
}
```

## Boas PrÃ¡ticas

1. Interface Segregation

* Interfaces pequenas e coesas

* Foco em comportamento especÃ­fico

* Evite interfaces gordas

2. AbstraÃ§Ã£o Apropriada

* Use classes abstratas para cÃ³digo comum

* Interfaces para contratos puros

* Balanceie flexibilidade e complexidade

3. Nomenclatura

* Interfaces: capacidade/comportamento

* Classes abstratas: conceito base

* MÃ©todos: verbos/aÃ§Ãµes

## PrÃ³ximos Passos

[Records](records.html)

Tip:

"Na matrix digital, interfaces e abstraÃ§Ãµes sÃ£o as ferramentas que moldam a realidade do cÃ³digo."



# Records

## Conceito Base

Records sÃ£o classes imutÃ¡veis que atuam como portadores transparentes de dados, introduzidos no Java 16.

```MERMAID
graph TD
    A[Record] -->|Gera automaticamente| B[Constructor]
    A -->|Gera automaticamente| C[Getters]
    A -->|Gera automaticamente| D[equals/hashCode]
    A -->|Gera automaticamente| E[toString]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#00ff00
```

## Sintaxe BÃ¡sica

```JAVA
public record NetrunnerCredentials(
    String handle,
    byte[] biometricHash,
    int clearanceLevel
) {}

// Uso
var creds = new NetrunnerCredentials("Phantom", 
    "bio123".getBytes(), 
    5);

System.out.println(creds.handle());        // Getter automÃ¡tico
System.out.println(creds.clearanceLevel()); // Getter automÃ¡tico
```

## CaracterÃ­sticas Principais

### Imutabilidade

```JAVA
public record SecurityToken(
    String id,
    long timestamp,
    Set<String> permissions
) {
    // Construtor canÃ´nico validador
    public SecurityToken {
        // Cria cÃ³pia defensiva imutÃ¡vel
        permissions = Set.copyOf(permissions);
    }
}
```

### MÃ©todos Adicionais

```JAVA
public record DataPacket(
    byte[] payload,
    String destination,
    int priority
) {
    // MÃ©todo instance
    public boolean isHighPriority() {
        return priority > 5;
    }

    // MÃ©todo static
    public static DataPacket createEmergency(String dest) {
        return new DataPacket(new byte[0], dest, 10);
    }
}
```

## Casos de Uso

### DTOs (Data Transfer Objects)

```JAVA
public record UserProfile(
    String id,
    String nickname,
    int reputationScore,
    LocalDateTime lastLogin
) {}

public record NetworkStatus(
    boolean connected,
    int latency,
    List<String> activeNodes
) {}
```

### Value Objects

```JAVA
public record IpAddress(String address) {
    public IpAddress {
        if (!isValid(address)) {
            throw new IllegalArgumentException("Invalid IP");
        }
    }

    private static boolean isValid(String addr) {
        // ValidaÃ§Ã£o de IP
        return addr.matches("^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$");
    }
}
```

## Interoperabilidade

### Com Interfaces

```JAVA
public interface Traceable {
    String getIdentifier();
}

public record TraceRoute(
    String source,
    String destination,
    List<String> hops
) implements Traceable {
    @Override
    public String getIdentifier() {
        return source + "->" + destination;
    }
}
```

### Com Pattern Matching

```JAVA
public void processData(Object data) {
    if (data instanceof DataPacket(var payload, var dest, var priority)) {
        System.out.printf("Packet to %s with priority %d%n", 
            dest, priority);
    }
}
```

## Boas PrÃ¡ticas

1. Uso Apropriado

* Para dados imutÃ¡veis

* Para transferÃªncia de dados

* Para objetos de valor

2. ValidaÃ§Ã£o

* No construtor canÃ´nico

* CÃ³pias defensivas

* Invariantes de negÃ³cio

3. LimitaÃ§Ãµes

* NÃ£o podem estender classes

* Sempre sÃ£o final

* Campos sempre sÃ£o final

## ExercÃ­cios PrÃ¡ticos

```JAVA
// 1. Crie um record para configuraÃ§Ãµes
public record SystemConfig(
    int maxConnections,
    Duration timeout,
    Set<String> allowedIPs
) {
    // Adicione validaÃ§Ãµes
}

// 2. Implemente um record para mÃ©tricas
public record NetworkMetrics(
    long bytesTransferred,
    int activeConnections,
    double throughput
) {
    // Adicione mÃ©todos Ãºteis
}

// 3. Desenvolva um record para eventos
public record SecurityEvent(
    String eventId,
    LocalDateTime timestamp,
    String description,
    SecurityLevel level
) {
    // Implemente lÃ³gica adicional
}
```

## PrÃ³ximos Passos

[Sealed Classes](sealed-classes.html)

Tip:

"Records: quando seus dados precisam ser tÃ£o transparentes quanto o vidro e tÃ£o imutÃ¡veis quanto a lei da fÃ­sica digital."



# Sealed Classes

## Conceito Base

Sealed Classes controlam a hierarquia de heranÃ§a, permitindo apenas classes especÃ­ficas como subclasses.

```MERMAID
graph TD
    A[Sealed Class/Interface] -->|permits| B[Subclasse 1]
    A -->|permits| C[Subclasse 2]
    A -->|permits| D[Subclasse 3]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
```

## Sintaxe BÃ¡sica

```JAVA
public sealed interface CyberwareComponent 
    permits NeuralImplant, BiometricEnhancer, CombatModule {
    
    void initialize();
    int getPowerConsumption();
}

public final class NeuralImplant implements CyberwareComponent {
    @Override
    public void initialize() {
        // ImplementaÃ§Ã£o
    }

    @Override
    public int getPowerConsumption() {
        return 50;
    }
}

public non-sealed class BiometricEnhancer 
    implements CyberwareComponent {
    // ImplementaÃ§Ã£o
}

public sealed class CombatModule implements CyberwareComponent 
    permits RangedModule, MeleeModule {
    // ImplementaÃ§Ã£o
}
```

## Modificadores de PermissÃ£o

### final

```JAVA
public sealed class SecurityProtocol 
    permits BiometricAuth, TokenAuth {
    // Base implementation
}

public final class BiometricAuth extends SecurityProtocol {
    // NÃ£o pode ser estendida
}
```

### non-sealed

```JAVA
public sealed interface DataProcessor 
    permits StreamProcessor, BatchProcessor {
    void process(byte[] data);
}

public non-sealed class StreamProcessor 
    implements DataProcessor {
    // Pode ser estendida por qualquer classe
}
```

### sealed

```JAVA
public sealed interface NetworkNode 
    permits Router, Switch, Firewall {
    void connect();
    void disconnect();
}

public sealed class Router implements NetworkNode 
    permits CoreRouter, EdgeRouter {
    // ImplementaÃ§Ã£o
}
```

## Pattern Matching

```JAVA
public String analyzeComponent(CyberwareComponent component) {
    return switch (component) {
        case NeuralImplant n -> 
            "Neural Implant: Power=" + n.getPowerConsumption();
        case BiometricEnhancer b -> 
            "Biometric: Power=" + b.getPowerConsumption();
        case CombatModule c -> 
            "Combat: Power=" + c.getPowerConsumption();
    };
}
```

## Casos de Uso

### Hierarquia de Comandos

```JAVA
public sealed interface Command 
    permits QueryCommand, UpdateCommand, DeleteCommand {
    void execute();
}

public final class QueryCommand implements Command {
    private final String query;
    
    @Override
    public void execute() {
        // ImplementaÃ§Ã£o
    }
}
```

### Sistema de Plugins

```JAVA
public sealed interface Plugin 
    permits SecurityPlugin, NetworkPlugin, DataPlugin {
    void load();
    void unload();
    String getVersion();
}
```

## Boas PrÃ¡ticas

1. Hierarquia Clara

* Defina hierarquias explÃ­citas

* Limite extensibilidade apropriadamente

* Documente o propÃ³sito de cada permissÃ£o

2. Escolha de Modificadores

* Use `final` para folhas da hierarquia

* Use `non-sealed` para pontos de extensÃ£o

* Use `sealed` para controle intermediÃ¡rio

3. Pattern Matching

* Aproveite o pattern matching exaustivo

* Combine com records quando apropriado

* Mantenha switches concisos

## ExercÃ­cios PrÃ¡ticos

```JAVA
// 1. Sistema de Protocolos de Rede
public sealed interface NetworkProtocol 
    permits TCP, UDP, ICMP {
    void sendPacket(byte[] data);
    void receivePacket();
}

// 2. Hierarquia de Eventos
public sealed class SystemEvent 
    permits UserEvent, NetworkEvent, SecurityEvent {
    private final LocalDateTime timestamp;
    // ImplementaÃ§Ã£o
}

// 3. Framework de Processamento
public sealed interface DataProcessor 
    permits RealTimeProcessor, BatchProcessor {
    void process(List<byte[]> data);
    ProcessingStats getStats();
}
```

## PrÃ³ximos Passos

[Projetos OOP](oop-projects.html)

Tip:

"Em um mundo digital sem fronteiras, sealed classes sÃ£o as muralhas que protegem sua hierarquia de cÃ³digo."



# Projetos OOP

## VisÃ£o Geral

```MERMAID
graph TD
    A[Projetos OOP] --> B[Sistema BancÃ¡rio]
    A --> C[Hierarquia de Formas]
    A --> D[Sistema de Plugins]
    
    B --> B1[Contas]
    B --> B2[TransaÃ§Ãµes]
    B --> B3[SeguranÃ§a]
    
    C --> C1[RenderizaÃ§Ã£o]
    C --> C2[CÃ¡lculos]
    C --> C3[TransformaÃ§Ãµes]
    
    D --> D1[Carregamento]
    D --> D2[Extensibilidade]
    D --> D3[IntegraÃ§Ã£o]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style C fill:#1a1a1a,stroke:#33ccff
    style D fill:#1a1a1a,stroke:#33ccff
```

## Estrutura dos Projetos

```
PROJETO
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/
â”‚   â”‚   â””â”€â”€ java/
â”‚   â”‚       â””â”€â”€ com/
â”‚   â”‚           â””â”€â”€ netrunner/
â”‚   â”‚               â””â”€â”€ project/
â”‚   â”‚                   â”œâ”€â”€ core/
â”‚   â”‚                   â”œâ”€â”€ model/
â”‚   â”‚                   â”œâ”€â”€ service/
â”‚   â”‚                   â””â”€â”€ util/
â”‚   â””â”€â”€ test/
â”‚       â””â”€â”€ java/
â””â”€â”€ README.md
```

## Sistema BancÃ¡rio Digital

### Objetivos de Aprendizado

* Encapsulamento de dados sensÃ­veis

* HeranÃ§a para diferentes tipos de contas

* Polimorfismo em operaÃ§Ãµes financeiras

* Interfaces para serviÃ§os bancÃ¡rios

* Records para transaÃ§Ãµes imutÃ¡veis

* Classes seladas para hierarquia de contas

### Componentes Principais

```JAVA
// Hierarquia de contas
public sealed abstract class Account 
    permits CheckingAccount, SavingsAccount, CryptoAccount {
    
    private final String id;
    private BigDecimal balance;
    private final SecurityModule security;
    
    // MÃ©todos abstratos e concretos
}

// TransaÃ§Ãµes imutÃ¡veis
public record Transaction(
    String id,
    BigDecimal amount,
    LocalDateTime timestamp,
    TransactionType type,
    String description
) {}

// Interface de serviÃ§os
public interface BankingService {
    void processTransaction(Transaction tx);
    Account getAccount(String id);
    List<Transaction> getHistory(String accountId);
}
```

## Hierarquia de Formas

### Objetivos de Aprendizado

* AbstraÃ§Ã£o de formas geomÃ©tricas

* HeranÃ§a para especializaÃ§Ã£o

* Polimorfismo em renderizaÃ§Ã£o

* Interfaces para comportamentos

* Records para pontos e dimensÃµes

* Classes seladas para tipos de formas

### Componentes Principais

```JAVA
// Ponto imutÃ¡vel
public record Point(double x, double y) {
    public double distanceTo(Point other) {
        // CÃ¡lculo de distÃ¢ncia
    }
}

// Hierarquia de formas
public sealed interface Shape 
    permits Circle, Rectangle, Triangle {
    
    double area();
    double perimeter();
    void render(Graphics g);
    boolean contains(Point p);
}

// TransformaÃ§Ãµes
public interface Transformable {
    void rotate(double angle);
    void scale(double factor);
    void translate(Point delta);
}
```

## Sistema de Plugins

### Objetivos de Aprendizado

* Interfaces para extensibilidade

* Carregamento dinÃ¢mico

* Gerenciamento de dependÃªncias

* PadrÃ£o Observer para eventos

* Records para configuraÃ§Ãµes

* Classes seladas para tipos de plugins

### Componentes Principais

```JAVA
// ConfiguraÃ§Ã£o de plugin
public record PluginConfig(
    String name,
    String version,
    Set<String> dependencies,
    Map<String, String> settings
) {}

// Interface base de plugin
public sealed interface Plugin 
    permits SecurityPlugin, NetworkPlugin, DataPlugin {
    
    void initialize(PluginConfig config);
    void start();
    void stop();
    String getStatus();
}

// Gerenciador de plugins
public class PluginManager {
    private final Map<String, Plugin> plugins;
    private final DependencyResolver resolver;
    
    public void loadPlugin(String path) {
        // Carregamento dinÃ¢mico
    }
}
```

## Desafios Extras

### Sistema BancÃ¡rio

* Implementar criptografia de dados

* Adicionar autenticaÃ§Ã£o biomÃ©trica

* Criar sistema de alertas

* Implementar transaÃ§Ãµes programadas

* Adicionar suporte multi-moeda

### Hierarquia de Formas

* Implementar formas 3D

* Adicionar animaÃ§Ãµes

* Criar sistema de colisÃµes

* Implementar exportaÃ§Ã£o SVG

* Adicionar efeitos visuais

### Sistema de Plugins

* Implementar hot-reload

* Adicionar versionamento

* Criar marketplace

* Implementar sandbox

* Adicionar telemetria

## Dicas de ImplementaÃ§Ã£o

1. Planejamento

* Comece com diagramas UML

* Identifique abstraÃ§Ãµes

* Defina interfaces claras

2. Desenvolvimento

* Use TDD

* Refatore frequentemente

* Documente decisÃµes

3. Testes

* Cubra casos de borda

* Teste integraÃ§Ãµes

* Valide seguranÃ§a

## PrÃ³ximos Passos

[Sistema BancÃ¡rio](banking-system.html)

Tip:

"Na Matrix do cÃ³digo orientado a objetos, cada projeto Ã© uma oportunidade de criar um universo digital coerente e extensÃ­vel."



# Sistema BancÃ¡rio Digital

## Arquitetura do Sistema

```MERMAID
graph TD
    A[Sistema BancÃ¡rio] --> B[Core]
    A --> C[ServiÃ§os]
    A --> D[SeguranÃ§a]
    
    B --> B1[Contas]
    B --> B2[TransaÃ§Ãµes]
    B --> B3[UsuÃ¡rios]
    
    C --> C1[TransferÃªncias]
    C --> C2[Investimentos]
    C --> C3[Pagamentos]
    
    D --> D1[AutenticaÃ§Ã£o]
    D --> D2[Criptografia]
    D --> D3[Auditoria]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style C fill:#1a1a1a,stroke:#33ccff
    style D fill:#1a1a1a,stroke:#ff3366
```

## Estrutura do CÃ³digo

### Hierarquia de Contas

```JAVA
public sealed abstract class Account 
    permits CheckingAccount, SavingsAccount, CryptoAccount {
    
    private final String id;
    private final String userId;
    private BigDecimal balance;
    private final SecurityModule security;
    
    public abstract boolean withdraw(BigDecimal amount);
    public abstract boolean deposit(BigDecimal amount);
    public abstract AccountType getType();
    
    protected final void logTransaction(TransactionType type, 
                                      BigDecimal amount) {
        // Logging seguro
    }
}

public final class CheckingAccount extends Account {
    private final BigDecimal overdraftLimit;
    
    @Override
    public boolean withdraw(BigDecimal amount) {
        if (getBalance().add(overdraftLimit).compareTo(amount) < 0) {
            return false;
        }
        // Processamento do saque
        return true;
    }
    // Outros mÃ©todos
}
```

### Sistema de TransaÃ§Ãµes

```JAVA
public record Transaction(
    String id,
    String accountId,
    BigDecimal amount,
    TransactionType type,
    LocalDateTime timestamp,
    String description,
    TransactionStatus status
) {}

public interface TransactionProcessor {
    TransactionResult process(Transaction tx);
    void rollback(String txId);
    TransactionStatus checkStatus(String txId);
}

public class SecureTransactionProcessor 
    implements TransactionProcessor {
    
    private final SecurityModule security;
    private final TransactionLogger logger;
    
    @Override
    public TransactionResult process(Transaction tx) {
        try {
            security.validateTransaction(tx);
            // Processamento
            logger.logSuccess(tx);
            return TransactionResult.success(tx.id());
        } catch (SecurityException e) {
            logger.logFailure(tx, e);
            return TransactionResult.failure(tx.id(), e);
        }
    }
}
```

### MÃ³dulo de SeguranÃ§a

```JAVA
public final class SecurityModule {
    private final EncryptionService encryption;
    private final AuthenticationService auth;
    private final AuditLogger audit;
    
    public void validateTransaction(Transaction tx) {
        if (!auth.isAuthenticated()) {
            throw new SecurityException("NÃ£o autenticado");
        }
        
        if (!encryption.isSecureChannel()) {
            throw new SecurityException("Canal inseguro");
        }
        
        audit.logAccess(tx);
    }
}
```

## ImplementaÃ§Ã£o Passo a Passo

1. ConfiguraÃ§Ã£o Inicial

```JAVA
public class BankSystem {
    private final AccountRepository accounts;
    private final TransactionProcessor txProcessor;
    private final SecurityModule security;

    public BankSystem() {
        this.security = new SecurityModule();
        this.accounts = new AccountRepository();
        this.txProcessor = new SecureTransactionProcessor(security);
    }
}
```

2. CriaÃ§Ã£o de Conta

```JAVA
public class AccountService {
    public Account createAccount(AccountType type, 
                               String userId) {
        return switch (type) {
            case CHECKING -> new CheckingAccount(userId);
            case SAVINGS -> new SavingsAccount(userId);
            case CRYPTO -> new CryptoAccount(userId);
        };
    }
}
```

3. Processamento de TransaÃ§Ãµes

```JAVA
public class TransactionService {
    public TransactionResult transfer(String fromId, 
                                    String toId, 
                                    BigDecimal amount) {
        var tx = new Transaction(
            UUID.randomUUID().toString(),
            fromId,
            amount,
            TransactionType.TRANSFER,
            LocalDateTime.now(),
            "TransferÃªncia entre contas",
            TransactionStatus.PENDING
        );

        return txProcessor.process(tx);
    }
}
```

## Testes

```JAVA
@Test
void testOverdraftLimit() {
    var account = new CheckingAccount("user123");
    account.deposit(new BigDecimal("100.00"));
    
    assertFalse(account.withdraw(new BigDecimal("150.00")));
    assertEquals(new BigDecimal("100.00"), account.getBalance());
}

@Test
void testSecureTransaction() {
    var processor = new SecureTransactionProcessor(
        new SecurityModule()
    );
    
    var tx = new Transaction(/* ... */);
    var result = processor.process(tx);
    
    assertTrue(result.isSuccess());
    assertEquals(TransactionStatus.COMPLETED, 
                processor.checkStatus(tx.id()));
}
```

## ConsideraÃ§Ãµes de SeguranÃ§a

1. Criptografia

* Dados em repouso

* Dados em trÃ¢nsito

* Chaves seguras

2. AutenticaÃ§Ã£o

* Multi-fator

* Biometria

* Tokens JWT

3. Auditoria

* Logs detalhados

* Trilha de auditoria

* Alertas de seguranÃ§a

## PrÃ³ximos Passos

[Hierarquia de Formas](shape-hierarchy.html)

Tip:

"No submundo digital das finanÃ§as, a seguranÃ§a nÃ£o Ã© apenas uma caracterÃ­stica - Ã© uma necessidade."



# Hierarquia de Formas GeomÃ©tricas

## VisÃ£o Geral

Este projeto implementa um sistema de formas geomÃ©tricas usando conceitos avanÃ§ados de ProgramaÃ§Ã£o Orientada a Objetos em Java.

```MERMAID
graph TD
    A[Shape] --> B[Circle]
    A --> C[Rectangle]
    A --> D[Triangle]
    E[Point] --> B
    E --> C
    E --> D
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style C fill:#1a1a1a,stroke:#33ccff
    style D fill:#1a1a1a,stroke:#33ccff
    style E fill:#1a1a1a,stroke:#ff3366
```

## Conceitos Demonstrados

* Classes seladas (sealed classes)

* Records para dados imutÃ¡veis

* HeranÃ§a e polimorfismo

* Classes e mÃ©todos abstratos

* Encapsulamento

* Geometria computacional

## Estrutura do Projeto

### Classe Base: Shape

```JAVA
public sealed abstract class Shape permits Circle, Rectangle, Triangle {
    private Point position;
    private String color;
    
    // MÃ©todos abstratos que todas as formas devem implementar
    public abstract double area();
    public abstract double perimeter();
    public abstract boolean contains(Point point);
}
```

### Record Point

```JAVA
public record Point(double x, double y) {
    public double distanceTo(Point other) {
        double dx = this.x - other.x;
        double dy = this.y - other.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
}
```

## ImplementaÃ§Ãµes

### Circle

* Usa um ponto central e raio

* Ãrea: Ï€rÂ²

* PerÃ­metro: 2Ï€r

* ContÃ©m ponto: distÃ¢ncia ao centro â‰¤ raio

### Rectangle

* Definido por ponto superior esquerdo, largura e altura

* Ãrea: largura Ã— altura

* PerÃ­metro: 2(largura + altura)

* ContÃ©m ponto: verifica coordenadas x,y dentro dos limites

### Triangle

* Definido por trÃªs pontos

* Ãrea: FÃ³rmula de Heron

* PerÃ­metro: soma das distÃ¢ncias entre pontos

* ContÃ©m ponto: coordenadas baricÃªntricas

## Exemplo de Uso

```JAVA
// Criar formas
Circle circle = new Circle(new Point(0, 0), 5, "red");
Rectangle rectangle = new Rectangle(new Point(2, 2), 4, 3, "blue");
Triangle triangle = new Triangle(
    new Point(0, 0),
    new Point(3, 0),
    new Point(0, 4),
    "green"
);

// Array polimÃ³rfico
Shape[] shapes = {circle, rectangle, triangle};

// OperaÃ§Ãµes com formas
for (Shape shape : shapes) {
    System.out.println("Ãrea: " + shape.area());
    System.out.println("PerÃ­metro: " + shape.perimeter());
}
```

## ExercÃ­cios PrÃ¡ticos

1. ExtensÃ£o BÃ¡sica

* Adicione uma nova forma (ex: HexÃ¡gono)

* Implemente rotaÃ§Ã£o para as formas

* Adicione cÃ¡lculo de escala

2. Funcionalidades AvanÃ§adas

* DetecÃ§Ã£o de colisÃ£o entre formas

* TransformaÃ§Ãµes geomÃ©tricas

* SerializaÃ§Ã£o de formas

3. Interface GrÃ¡fica

* RenderizaÃ§Ã£o das formas

* Interface para criar/editar formas

* AnimaÃ§Ãµes de movimento

## Desafios

1. OtimizaÃ§Ã£o

* Melhore o algoritmo de verificaÃ§Ã£o de ponto em triÃ¢ngulo

* Implemente cache para cÃ¡lculos frequentes

* Otimize operaÃ§Ãµes em lote

2. Extensibilidade

* Adicione sistema de eventos

* Implemente padrÃ£o Observer

* Crie sistema de plugins

## Dicas de ImplementaÃ§Ã£o

1. PrecisÃ£o NumÃ©rica

* Use `double` para cÃ¡lculos geomÃ©tricos

* Considere tolerÃ¢ncia em comparaÃ§Ãµes

* Implemente arredondamento adequado

2. Boas PrÃ¡ticas

* Valide parÃ¢metros nos construtores

* Mantenha imutabilidade onde possÃ­vel

* Use nomes descritivos

3. Testes

* Teste casos limites

* Verifique formas degeneradas

* Valide transformaÃ§Ãµes

## Recursos Adicionais

* [Geometria Computacional](https://www.geeksforgeeks.org/computational-geometry-introduction/)

* [Java Graphics2D](https://docs.oracle.com/javase/tutorial/2d/index.html)

* [MatemÃ¡tica para Programadores](https://www.mathsisfun.com/geometry/index.html)

## PrÃ³ximos Passos

* Explore padrÃµes de design relacionados

* Implemente persistÃªncia de dados

* Adicione suporte a formas compostas



# Sistema de Plugins

## VisÃ£o Geral

Este projeto implementa um sistema de plugins bÃ¡sico usando Java, demonstrando conceitos fundamentais de programaÃ§Ã£o orientada a objetos e estruturas de dados bÃ¡sicas.

```MERMAID
graph TD
    A[PluginSystem] --> B[Plugin]
    B --> C[name]
    B --> D[commands]
    B --> E[isEnabled]
    A --> F[plugins array]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style F fill:#1a1a1a,stroke:#ff3366
```

## Componentes Principais

### Classe Plugin

A classe `Plugin` representa um plugin individual no sistema:

```JAVA
public class Plugin {
    private String name;
    private boolean isEnabled;
    private String[] commands;

    // Construtor e mÃ©todos principais
    public Plugin(String name, String[] commands) {
        this.name = name;
        this.isEnabled = false;
        this.commands = commands;
    }

    public void enable() {
        isEnabled = true;
    }

    public void disable() {
        isEnabled = false;
    }

    public void executeCommand(String command) {
        // Executa um comando se o plugin estiver ativado
    }
}
```

### Sistema de Gerenciamento

A classe `PluginSystem` gerencia todos os plugins:

```JAVA
public class PluginSystem {
    private Plugin[] plugins;
    private int pluginCount;
    private static final int MAX_PLUGINS = 10;

    public void addPlugin(Plugin plugin) {
        // Adiciona um novo plugin ao sistema
    }

    public void enablePlugin(String name) {
        // Ativa um plugin especÃ­fico
    }

    public void disablePlugin(String name) {
        // Desativa um plugin especÃ­fico
    }

    public void executeCommand(String pluginName, String command) {
        // Executa um comando em um plugin especÃ­fico
    }
}
```

## Funcionalidades Principais

1. Gerenciamento de Plugins

* Adicionar plugins

* Ativar/desativar plugins

* Listar plugins instalados

2. Sistema de Comandos

* Cada plugin possui seus prÃ³prios comandos

* VerificaÃ§Ã£o de comandos disponÃ­veis

* ExecuÃ§Ã£o segura de comandos

3. Estado dos Plugins

* Controle de estado (ativado/desativado)

* VerificaÃ§Ã£o antes da execuÃ§Ã£o

* Feedback de operaÃ§Ãµes

## Exemplo de Uso

```JAVA
// Criar sistema de plugins
PluginSystem system = new PluginSystem();

// Criar um plugin de calculadora
Plugin calculadora = new Plugin("Calculadora", 
    new String[]{"somar", "subtrair", "multiplicar"});

// Adicionar ao sistema
system.addPlugin(calculadora);

// Ativar o plugin
system.enablePlugin("Calculadora");

// Executar um comando
system.executeCommand("Calculadora", "somar");
```

## ExercÃ­cios PrÃ¡ticos

1. Plugin BÃ¡sico

* Crie um novo plugin com comandos personalizados

* Implemente a lÃ³gica de execuÃ§Ã£o dos comandos

* Teste a ativaÃ§Ã£o e desativaÃ§Ã£o

2. Sistema de Plugins

* Adicione mÃºltiplos plugins ao sistema

* Gerencie as interaÃ§Ãµes entre plugins

* Implemente listagem de plugins

3. Comandos Personalizados

* Crie comandos com parÃ¢metros

* Implemente validaÃ§Ã£o de comandos

* Adicione feedback de execuÃ§Ã£o

## Boas PrÃ¡ticas

1. OrganizaÃ§Ã£o do CÃ³digo

* Mantenha mÃ©todos curtos e focados

* Use nomes descritivos para variÃ¡veis

* Comente seÃ§Ãµes importantes do cÃ³digo

2. ValidaÃ§Ã£o

* Verifique estados antes de executar aÃ§Ãµes

* Valide entradas de usuÃ¡rio

* ForneÃ§a feedback claro

3. ManutenÃ§Ã£o

* Mantenha o cÃ³digo organizado

* Documente funcionalidades

* Teste todas as operaÃ§Ãµes

## PrÃ³ximos Passos

* Adicione mais tipos de plugins

* Implemente sistema de configuraÃ§Ã£o

* Crie uma interface de usuÃ¡rio simples

* Adicione persistÃªncia de dados

## Recursos Adicionais

* [DocumentaÃ§Ã£o Java](https://docs.oracle.com/javase/tutorial/)

* [Boas PrÃ¡ticas de ProgramaÃ§Ã£o](https://www.oracle.com/java/technologies/javase/codeconventions.html)



# Tratamento de Erros em Java

O tratamento de erros Ã© uma parte fundamental da programaÃ§Ã£o em Java, permitindo que vocÃª lide com situaÃ§Ãµes inesperadas de forma elegante e robusta.

## Por que o Tratamento de Erros Ã© Importante?

```MERMAID
graph TD
    A[Programa] --> B{Erro?}
    B -->|Sim| C[Tratamento de Erro]
    B -->|NÃ£o| D[Fluxo Normal]
    C --> E[RecuperaÃ§Ã£o]
    C --> F[Log]
    C --> G[Feedback ao UsuÃ¡rio]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#ff3366
    style C fill:#1a1a1a,stroke:#33ccff
```

### BenefÃ­cios Principais

1. Robustez

* Previne falhas catastrÃ³ficas

* MantÃ©m o programa funcionando

* Garante consistÃªncia dos dados

2. ExperiÃªncia do UsuÃ¡rio

* Mensagens de erro claras

* Feedback apropriado

* RecuperaÃ§Ã£o graciosa

3. Manutenibilidade

* CÃ³digo mais organizado

* Melhor depuraÃ§Ã£o

* Logs mais efetivos

## Conceitos Fundamentais

### Tipos de Erros

1. Erros de CompilaÃ§Ã£o

* Sintaxe incorreta

* Tipos incompatÃ­veis

* Recursos nÃ£o encontrados

2. Erros de Runtime

* DivisÃ£o por zero

* Null pointer

* Array index out of bounds

3. Erros LÃ³gicos

* Bugs de negÃ³cio

* CÃ¡lculos incorretos

* Fluxos inesperados

### Hierarquia de ExceÃ§Ãµes

```JAVA
try {
    // CÃ³digo que pode gerar exceÃ§Ã£o
    riskyOperation();
} catch (Exception e) {
    // Tratamento do erro
    handleError(e);
} finally {
    // CÃ³digo que sempre executa
    cleanup();
}
```

## TÃ³picos Principais

Este mÃ³dulo abordarÃ¡:

* [ExceÃ§Ãµes em Java](exceptions.html)

* [Try-Catch e Finally](try-catch.html)

* [ExceÃ§Ãµes Personalizadas](custom-exceptions.html)

* [Try-with-Resources](try-with-resources.html)

## Melhores PrÃ¡ticas

1. Nunca Ignore ExceÃ§Ãµes

```JAVA
try {
    // operaÃ§Ã£o
} catch (Exception e) {
    // NO MÃNIMO faÃ§a log do erro
    logger.error("Erro na operaÃ§Ã£o", e);
}
```

2. Use ExceÃ§Ãµes EspecÃ­ficas

```JAVA
try {
    // operaÃ§Ã£o
} catch (FileNotFoundException e) {
    // tratamento especÃ­fico
} catch (IOException e) {
    // tratamento mais genÃ©rico
}
```

3. Documente ExceÃ§Ãµes

```JAVA
/**
 * @throws IllegalArgumentException se o valor for negativo
 */
public void setValue(int value) {
    if (value < 0) {
        throw new IllegalArgumentException("Valor nÃ£o pode ser negativo");
    }
}
```

## PrÃ³ximos Passos

* Explore os diferentes tipos de exceÃ§Ãµes

* Pratique criando exceÃ§Ãµes personalizadas

* Implemente tratamento de erros em seus projetos

* Aprenda sobre logging e debugging

## Recursos Adicionais

* [Java Exception Handling Tutorial](https://docs.oracle.com/javase/tutorial/essential/exceptions/)

* [Best Practices for Exception Handling](https://www.oracle.com/java/technologies/javase/exceptions.html)

Tip:

"Em um mundo perfeito, nÃ£o precisarÃ­amos de tratamento de erros. Mas no mundo real, ele Ã© tÃ£o essencial quanto o prÃ³prio cÃ³digo."

[ComeÃ§ar com ExceÃ§Ãµes](exceptions.html)



# ExceÃ§Ãµes em Java

## Hierarquia de ExceÃ§Ãµes

```MERMAID
graph TD
    A[Throwable] --> B[Error]
    A --> C[Exception]
    C --> D[RuntimeException]
    C --> E[CheckedException]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#ff3366
    style C fill:#1a1a1a,stroke:#33ccff
```

## Tipos de ExceÃ§Ãµes

### 1. Checked Exceptions

* Verificadas em tempo de compilaÃ§Ã£o

* Devem ser declaradas ou tratadas

* Exemplos: `IOException`, `SQLException`

```JAVA
public void readFile() throws IOException {
    FileReader file = new FileReader("arquivo.txt");
    // cÃ³digo para ler arquivo
}
```

### 2. Unchecked Exceptions (RuntimeException)

* NÃ£o verificadas em tempo de compilaÃ§Ã£o

* Geralmente indicam erros de programaÃ§Ã£o

* Exemplos: `NullPointerException`, `ArrayIndexOutOfBoundsException`

```JAVA
public void processArray(int[] array) {
    // Pode lanÃ§ar NullPointerException ou ArrayIndexOutOfBoundsException
    int value = array[10];
}
```

### 3. Errors

* Problemas graves na JVM

* NÃ£o devem ser tratados pelo programa

* Exemplos: `OutOfMemoryError`, `StackOverflowError`

## ExceÃ§Ãµes Comuns

1. NullPointerException

```JAVA
String str = null;
str.length(); // LanÃ§a NullPointerException
```

1. ArrayIndexOutOfBoundsException

```JAVA
int[] array = new int[5];
array[10] = 1; // LanÃ§a ArrayIndexOutOfBoundsException
```

1. IllegalArgumentException

```JAVA
public void setAge(int age) {
    if (age < 0) {
        throw new IllegalArgumentException("Idade nÃ£o pode ser negativa");
    }
}
```

## Boas PrÃ¡ticas

1. Seja EspecÃ­fico

* Use exceÃ§Ãµes especÃ­ficas em vez de genÃ©ricas

* Ajuda na identificaÃ§Ã£o e tratamento do problema

1. Documente as ExceÃ§Ãµes

```JAVA
/**
 * @throws IllegalArgumentException se o valor for negativo
 * @throws IOException em caso de erro de leitura
 */
public void processValue(int value) throws IOException {
    // implementaÃ§Ã£o
}
```

1. Mantenha a Granularidade

* Lance exceÃ§Ãµes no nÃ­vel mais baixo possÃ­vel

* Trate no nÃ­vel apropriado da aplicaÃ§Ã£o

## Exemplos PrÃ¡ticos

### Exemplo 1: ValidaÃ§Ã£o de Entrada

```JAVA
public class UserValidator {
    public void validateUsername(String username) {
        if (username == null || username.trim().isEmpty()) {
            throw new IllegalArgumentException("Username nÃ£o pode ser vazio");
        }
        if (username.length() < 3) {
            throw new IllegalArgumentException("Username deve ter no mÃ­nimo 3 caracteres");
        }
    }
}
```

### Exemplo 2: OperaÃ§Ãµes de Arquivo

```JAVA
public class FileProcessor {
    public String readFile(String path) throws IOException {
        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
            return reader.readLine();
        }
    }
}
```

## PrÃ³ximos Passos

* Aprenda sobre [Try-Catch e Finally](try-catch.html)

* Explore [ExceÃ§Ãµes Personalizadas](custom-exceptions.html)

* Estude [Try-with-Resources](try-with-resources.html)

## Recursos Adicionais

* [Java Exception Tutorial](https://docs.oracle.com/javase/tutorial/essential/exceptions/)

* [Java Exception Best Practices](https://www.oracle.com/java/technologies/javase/exceptions.html)



# Try-Catch e Finally em Java

## Estrutura BÃ¡sica

```JAVA
try {
    // CÃ³digo que pode lanÃ§ar exceÃ§Ã£o
} catch (ExceptionType e) {
    // Tratamento da exceÃ§Ã£o
} finally {
    // CÃ³digo que sempre executa
}
```

## Blocos Try-Catch

### Try Block

* ContÃ©m cÃ³digo que pode lanÃ§ar exceÃ§Ãµes

* Pode conter mÃºltiplas linhas

* Deve ser seguido por catch ou finally

```JAVA
try {
    int result = 10 / 0;  // LanÃ§a ArithmeticException
    System.out.println(result);
}
```

### Catch Block

* Captura e trata exceÃ§Ãµes especÃ­ficas

* Pode ter mÃºltiplos blocos catch

* Deve ser ordenado do mais especÃ­fico para o mais genÃ©rico

```JAVA
try {
    // cÃ³digo arriscado
} catch (ArithmeticException e) {
    System.out.println("Erro de divisÃ£o: " + e.getMessage());
} catch (Exception e) {
    System.out.println("Erro genÃ©rico: " + e.getMessage());
}
```

### Finally Block

* Sempre executa, independente de exceÃ§Ã£o

* Ãštil para limpeza de recursos

* Opcional, mas importante para boas prÃ¡ticas

```JAVA
FileReader reader = null;
try {
    reader = new FileReader("file.txt");
    // processar arquivo
} catch (IOException e) {
    System.out.println("Erro ao ler arquivo");
} finally {
    if (reader != null) {
        try {
            reader.close();
        } catch (IOException e) {
            // handle close exception
        }
    }
}
```

## PadrÃµes Comuns

### 1. MÃºltiplos Catch

```JAVA
try {
    // cÃ³digo arriscado
} catch (FileNotFoundException e) {
    // tratamento especÃ­fico para arquivo nÃ£o encontrado
} catch (IOException e) {
    // tratamento para outros erros de I/O
} catch (Exception e) {
    // tratamento para qualquer outra exceÃ§Ã£o
}
```

### 2. Multi-catch (Java 7+)

```JAVA
try {
    // cÃ³digo arriscado
} catch (IOException | SQLException e) {
    // tratamento comum para ambas exceÃ§Ãµes
}
```

### 3. Rethrow

```JAVA
try {
    // cÃ³digo arriscado
} catch (Exception e) {
    // log do erro
    logger.error("Erro durante processamento", e);
    throw e; // relanÃ§a a exceÃ§Ã£o
}
```

## Boas PrÃ¡ticas

1. Seja EspecÃ­fico

```JAVA
// Ruim
try {
    // cÃ³digo
} catch (Exception e) { }

// Bom
try {
    // cÃ³digo
} catch (FileNotFoundException e) {
    // tratamento especÃ­fico
}
```

1. Log Adequado

```JAVA
try {
    // cÃ³digo
} catch (Exception e) {
    logger.error("Contexto do erro: " + e.getMessage(), e);
}
```

1. Limpeza de Recursos

```JAVA
Connection conn = null;
try {
    conn = getConnection();
    // usar conexÃ£o
} finally {
    if (conn != null) {
        conn.close();
    }
}
```

## Exemplos PrÃ¡ticos

### Exemplo 1: Processamento de Arquivo

```JAVA
public class FileProcessor {
    public void processFile(String path) {
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader(path));
            String line;
            while ((line = reader.readLine()) != null) {
                processLine(line);
            }
        } catch (FileNotFoundException e) {
            System.err.println("Arquivo nÃ£o encontrado: " + path);
        } catch (IOException e) {
            System.err.println("Erro ao ler arquivo: " + e.getMessage());
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    System.err.println("Erro ao fechar arquivo");
                }
            }
        }
    }
}
```

### Exemplo 2: OperaÃ§Ãµes de Banco de Dados

```JAVA
public class DatabaseOperations {
    public void updateRecord(int id, String data) {
        Connection conn = null;
        PreparedStatement stmt = null;
        try {
            conn = getConnection();
            stmt = conn.prepareStatement("UPDATE records SET data = ? WHERE id = ?");
            stmt.setString(1, data);
            stmt.setInt(2, id);
            stmt.executeUpdate();
        } catch (SQLException e) {
            System.err.println("Erro de banco de dados: " + e.getMessage());
        } finally {
            closeResources(conn, stmt);
        }
    }
}
```

## PrÃ³ximos Passos

* Aprenda sobre [Try-with-Resources](try-with-resources.html)

* Explore [ExceÃ§Ãµes Personalizadas](custom-exceptions.html)

* Pratique com diferentes tipos de exceÃ§Ãµes

## Recursos Adicionais

* [Java Exception Handling Tutorial](https://docs.oracle.com/javase/tutorial/essential/exceptions/)

* [Best Practices for Exception Handling](https://www.oracle.com/java/technologies/javase/exceptions.html)



# ExceÃ§Ãµes Personalizadas em Java

## IntroduÃ§Ã£o

ExceÃ§Ãµes personalizadas permitem criar tipos especÃ­ficos de erro para seu domÃ­nio de negÃ³cio, tornando o cÃ³digo mais expressivo e manutenÃ­vel.

## Criando ExceÃ§Ãµes Personalizadas

### ExceÃ§Ã£o Verificada (Checked)

```JAVA
public class BusinessException extends Exception {
    public BusinessException(String message) {
        super(message);
    }

    public BusinessException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

### ExceÃ§Ã£o NÃ£o Verificada (Unchecked)

```JAVA
public class ValidationException extends RuntimeException {
    public ValidationException(String message) {
        super(message);
    }

    public ValidationException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

## PadrÃµes Comuns

### 1. ExceÃ§Ãµes de DomÃ­nio

```JAVA
public class UserNotFoundException extends RuntimeException {
    private final String userId;

    public UserNotFoundException(String userId) {
        super("UsuÃ¡rio nÃ£o encontrado: " + userId);
        this.userId = userId;
    }

    public String getUserId() {
        return userId;
    }
}
```

### 2. ExceÃ§Ãµes com Dados Adicionais

```JAVA
public class OrderProcessingException extends Exception {
    private final String orderId;
    private final OrderStatus status;

    public OrderProcessingException(String message, String orderId, OrderStatus status) {
        super(message);
        this.orderId = orderId;
        this.status = status;
    }

    // Getters para informaÃ§Ãµes adicionais
    public String getOrderId() { return orderId; }
    public OrderStatus getStatus() { return status; }
}
```

## Exemplos de Uso

### Exemplo 1: ValidaÃ§Ã£o de NegÃ³cio

```JAVA
public class UserService {
    public void createUser(User user) throws ValidationException {
        if (user.getAge() < 18) {
            throw new ValidationException("UsuÃ¡rio deve ser maior de idade");
        }
        if (user.getEmail() == null || !user.getEmail().contains("@")) {
            throw new ValidationException("Email invÃ¡lido");
        }
        // Continua processamento
    }
}
```

### Exemplo 2: Processamento de Pedidos

```JAVA
public class OrderProcessor {
    public void processOrder(Order order) throws OrderProcessingException {
        try {
            validateOrder(order);
            calculateTotal(order);
            saveOrder(order);
        } catch (Exception e) {
            throw new OrderProcessingException(
                "Erro ao processar pedido",
                order.getId(),
                order.getStatus()
            );
        }
    }
}
```

## Boas PrÃ¡ticas

1. NomeaÃ§Ã£o Clara

```JAVA
// Bom
public class InvalidPasswordException extends RuntimeException { }

// Ruim
public class PasswordException extends RuntimeException { }
```

1. InformaÃ§Ãµes Relevantes

```JAVA
public class DatabaseConnectionException extends Exception {
    public DatabaseConnectionException(String server, int port, Throwable cause) {
        super(String.format("Falha ao conectar ao servidor %s:%d", server, port), cause);
    }
}
```

1. Hierarquia Apropriada

```JAVA
// ExceÃ§Ã£o base para o mÃ³dulo
public abstract class PaymentException extends Exception { }

// ExceÃ§Ãµes especÃ­ficas
public class PaymentDeclinedException extends PaymentException { }
public class InsufficientFundsException extends PaymentException { }
```

## Exemplos PrÃ¡ticos

### Sistema de Pagamento

```JAVA
public class PaymentProcessor {
    public void processPayment(Payment payment) throws PaymentException {
        try {
            validatePayment(payment);
            executeTransaction(payment);
            notifySuccess(payment);
        } catch (ValidationException e) {
            throw new PaymentValidationException("Pagamento invÃ¡lido", e);
        } catch (TransactionException e) {
            throw new PaymentProcessingException("Erro na transaÃ§Ã£o", e);
        }
    }
}
```

### Sistema de Arquivos

```JAVA
public class FileManager {
    public void saveDocument(Document doc) throws DocumentException {
        if (!isValidDocument(doc)) {
            throw new InvalidDocumentException("Documento invÃ¡lido");
        }
        
        try {
            writeToFile(doc);
        } catch (IOException e) {
            throw new DocumentStorageException("Erro ao salvar documento", e);
        }
    }
}
```

## PrÃ³ximos Passos

* Identifique casos de uso para exceÃ§Ãµes personalizadas em seu cÃ³digo

* Crie hierarquias de exceÃ§Ã£o para seu domÃ­nio

* Implemente tratamento adequado para suas exceÃ§Ãµes

## Recursos Adicionais

* [Java Exception Handling Best Practices](https://www.oracle.com/java/technologies/javase/exceptions.html)

* [Design Guidelines for Exceptions](https://docs.oracle.com/javase/tutorial/essential/exceptions/design.html)



# Try-with-Resources em Java

## IntroduÃ§Ã£o

Try-with-resources Ã© um recurso introduzido no Java 7 que simplifica o gerenciamento de recursos que precisam ser fechados apÃ³s o uso.

## Sintaxe BÃ¡sica

```JAVA
try (Resource resource = new Resource()) {
    // uso do recurso
} catch (Exception e) {
    // tratamento de exceÃ§Ã£o
}
```

## Recursos AutoCloseable

### Interface AutoCloseable

```JAVA
public interface AutoCloseable {
    void close() throws Exception;
}
```

### ImplementaÃ§Ã£o BÃ¡sica

```JAVA
public class MyResource implements AutoCloseable {
    public MyResource() {
        System.out.println("Recurso criado");
    }

    @Override
    public void close() throws Exception {
        System.out.println("Recurso fechado");
    }
}
```

## ComparaÃ§Ã£o com Try-Catch-Finally Tradicional

### Antes (Try-Catch-Finally)

```JAVA
FileReader reader = null;
try {
    reader = new FileReader("file.txt");
    // usar reader
} catch (IOException e) {
    // tratamento de erro
} finally {
    if (reader != null) {
        try {
            reader.close();
        } catch (IOException e) {
            // tratamento de erro ao fechar
        }
    }
}
```

### Depois (Try-with-Resources)

```JAVA
try (FileReader reader = new FileReader("file.txt")) {
    // usar reader
} catch (IOException e) {
    // tratamento de erro
}
```

## MÃºltiplos Recursos

### Gerenciando VÃ¡rios Recursos

```JAVA
try (FileInputStream input = new FileInputStream("input.txt");
     FileOutputStream output = new FileOutputStream("output.txt")) {
    // usar input e output
    byte[] buffer = new byte[1024];
    int length;
    while ((length = input.read(buffer)) > 0) {
        output.write(buffer, 0, length);
    }
}
```

## Exemplos PrÃ¡ticos

### Exemplo 1: Processamento de Arquivo

```JAVA
public class FileProcessor {
    public List<String> readLines(String path) throws IOException {
        List<String> lines = new ArrayList<>();
        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
            String line;
            while ((line = reader.readLine()) != null) {
                lines.add(line);
            }
        }
        return lines;
    }
}
```

### Exemplo 2: OperaÃ§Ãµes de Banco de Dados

```JAVA
public class DatabaseOperations {
    public void transferMoney(int fromAccount, int toAccount, double amount) {
        try (Connection conn = getConnection();
             PreparedStatement debit = conn.prepareStatement("UPDATE accounts SET balance = balance - ? WHERE id = ?");
             PreparedStatement credit = conn.prepareStatement("UPDATE accounts SET balance = balance + ? WHERE id = ?")) {
            
            conn.setAutoCommit(false);
            
            debit.setDouble(1, amount);
            debit.setInt(2, fromAccount);
            debit.executeUpdate();
            
            credit.setDouble(1, amount);
            credit.setInt(2, toAccount);
            credit.executeUpdate();
            
            conn.commit();
        }
    }
}
```

## Recursos Personalizados

### Criando Recurso Personalizado

```JAVA
public class DatabaseConnection implements AutoCloseable {
    private final Connection connection;
    
    public DatabaseConnection(String url) throws SQLException {
        this.connection = DriverManager.getConnection(url);
    }
    
    public Connection getConnection() {
        return connection;
    }
    
    @Override
    public void close() throws Exception {
        if (connection != null && !connection.isClosed()) {
            connection.close();
        }
    }
}
```

### Usando Recurso Personalizado

```JAVA
public class CustomResourceExample {
    public void useCustomResource() {
        try (DatabaseConnection db = new DatabaseConnection("jdbc:mysql://localhost/db")) {
            Connection conn = db.getConnection();
            // usar conexÃ£o
        } catch (Exception e) {
            // tratamento de erro
        }
    }
}
```

## Boas PrÃ¡ticas

1. Sempre Use para Recursos AutoCloseable

```JAVA
// Bom
try (InputStream in = new FileInputStream("file.txt")) {
    // cÃ³digo
}

// Evite
InputStream in = new FileInputStream("file.txt");
try {
    // cÃ³digo
} finally {
    in.close();
}
```

1. Ordem de Fechamento

```JAVA
try (ResourceOne one = new ResourceOne();
     ResourceTwo two = new ResourceTwo()) {
    // Os recursos sÃ£o fechados na ord
```



# Projetos de Tratamento de Erros

## VisÃ£o Geral

```MERMAID
graph TD
    A[Projetos de Erros] --> B[Sistema de ValidaÃ§Ã£o]
    A --> C[Logger de Erros]
    A --> D[Circuit Breaker]
    
    B --> B1[Validadores]
    B --> B2[Regras]
    B --> B3[Feedback]
    
    C --> C1[Captura]
    C --> C2[FormataÃ§Ã£o]
    C --> C3[PersistÃªncia]
    
    D --> D1[Monitoramento]
    D --> D2[Fallback]
    D --> D3[RecuperaÃ§Ã£o]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style C fill:#1a1a1a,stroke:#33ccff
    style D fill:#1a1a1a,stroke:#33ccff
```

## Projetos DisponÃ­veis

### 1. Sistema de ValidaÃ§Ã£o

* [Sistema de ValidaÃ§Ã£o](validation-system.html) - Sistema robusto de validaÃ§Ã£o de dados

* Implementa diferentes tipos de validadores

* Fornece feedback detalhado sobre erros

### 2. Logger de Erros

* [Logger de Erros](error-logger.html) - Sistema avanÃ§ado de logging

* Captura e formata exceÃ§Ãµes

* Persiste logs para anÃ¡lise posterior

### 3. Circuit Breaker

* [Circuit Breaker](circuit-breaker.html) - PadrÃ£o de resiliÃªncia

* Previne falhas em cascata

* Implementa estados e recuperaÃ§Ã£o

## Conceitos Aplicados

1. Tratamento de ExceÃ§Ãµes

* Try-catch blocks

* ExceÃ§Ãµes personalizadas

* PropagaÃ§Ã£o de erros

2. ValidaÃ§Ã£o de Dados

* Regras de negÃ³cio

* ValidaÃ§Ã£o de entrada

* Feedback ao usuÃ¡rio

3. Logging

* NÃ­veis de log

* FormataÃ§Ã£o de mensagens

* RotaÃ§Ã£o de arquivos

4. ResiliÃªncia

* Estados do circuit breaker

* Timeouts e retries

* Fallback mechanisms

## Objetivos de Aprendizado

* Implementar tratamento robusto de erros

* Criar sistemas de validaÃ§Ã£o flexÃ­veis

* Desenvolver mecanismos de logging eficientes

* Construir aplicaÃ§Ãµes resilientes

## Boas PrÃ¡ticas

1. ValidaÃ§Ã£o

* Valide entrada no ponto mais prÃ³ximo da origem

* ForneÃ§a mensagens de erro claras

* Mantenha validaÃ§Ãµes consistentes

2. Logging

* Use nÃ­veis apropriados de log

* Inclua contexto relevante

* Evite informaÃ§Ãµes sensÃ­veis

3. ResiliÃªncia

* Implemente timeouts adequados

* Prepare-se para falhas

* Tenha estratÃ©gias de fallback

## Desafios PrÃ¡ticos

1. Sistema de ValidaÃ§Ã£o

* Adicione novos tipos de validadores

* Implemente validaÃ§Ã£o assÃ­ncrona

* Crie regras compostas

2. Logger

* Implemente rotaÃ§Ã£o de arquivos

* Adicione formataÃ§Ã£o personalizada

* Integre com sistemas externos

3. Circuit Breaker

* Adicione mÃ©tricas

* Implemente recuperaÃ§Ã£o gradual

* Crie dashboard de monitoramento

## PrÃ³ximos Passos

* Explore padrÃµes avanÃ§ados de resiliÃªncia

* Integre com frameworks de logging

* Implemente validaÃ§Ã£o distribuÃ­da

* Adicione telemetria e monitoramento

## Recursos Adicionais

* [Java Exception Handling Best Practices](https://docs.oracle.com/javase/tutorial/essential/exceptions/)

* [Resilience4j Documentation](https://resilience4j.readme.io/)

* [SLF4J User Manual](http://www.slf4j.org/manual.html)

Tip:

"Um sistema robusto nÃ£o Ã© aquele que nunca falha, mas sim aquele que sabe lidar com as falhas de forma elegante."

[ComeÃ§ar com Sistema de ValidaÃ§Ã£o](validation-system.html)



# Sistema de ValidaÃ§Ã£o

## VisÃ£o Geral

```MERMAID
graph TD
    A[Sistema de ValidaÃ§Ã£o] --> B[Validadores]
    A --> C[Resultados]
    A --> D[Feedback]
    
    B --> B1[Tipo Dados]
    B1 --> B11[String]
    B1 --> B12[NÃºmero]
    B1 --> B13[Data]
    
    B --> B2[Regras]
    B2 --> B21[Tamanho]
    B2 --> B22[Formato]
    B2 --> B23[Range]
    
    C --> C1[Sucesso]
    C --> C2[Falha]
    C --> C3[Erros]
    
    D --> D1[Mensagens]
    D --> D2[CÃ³digos]
    D --> D3[Detalhes]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style C fill:#1a1a1a,stroke:#33ccff
    style D fill:#1a1a1a,stroke:#33ccff
```

## ImplementaÃ§Ã£o Base

```JAVA
public class ValidationSystem {
    private final List<Validator> validators;
    
    public ValidationResult validate(Object data) {
        // ImplementaÃ§Ã£o
    }
}
```

## Componentes Principais

### 1. Interface Validator

* Define contrato para validadores

* MÃ©todo principal de validaÃ§Ã£o

* Retorno padronizado

### 2. ValidationResult

* Status da validaÃ§Ã£o

* Lista de erros

* Mensagens detalhadas

### 3. ValidationBuilder

* ConstruÃ§Ã£o fluente

* Encadeamento de validaÃ§Ãµes

* ComposiÃ§Ã£o de regras

## Uso PrÃ¡tico

```JAVA
ValidationSystem validator = new ValidationSystem();
validator.addValidator(new EmailValidator());
validator.addValidator(new PasswordValidator());

ValidationResult result = validator.validate(userData);
if (!result.isValid()) {
    System.out.println(result.getErrors());
}
```

## Tipos de Validadores

1. Dados BÃ¡sicos

* String (comprimento, formato)

* NÃºmeros (range, precisÃ£o)

* Datas (formato, perÃ­odo)

2. Regras de NegÃ³cio

* ValidaÃ§Ãµes compostas

* DependÃªncias entre campos

* Regras customizadas

3. ValidaÃ§Ãµes AssÃ­ncronas

* Consultas externas

* VerificaÃ§Ãµes em banco

* APIs de terceiros

## Boas PrÃ¡ticas

1. Desempenho

* Cache de resultados

* ValidaÃ§Ã£o lazy

* OtimizaÃ§Ã£o de regras

2. Manutenibilidade

* Validadores isolados

* Regras reutilizÃ¡veis

* DocumentaÃ§Ã£o clara

3. Usabilidade

* Mensagens claras

* Feedback imediato

* SugestÃµes de correÃ§Ã£o

## ExercÃ­cios PrÃ¡ticos

1. Validador de FormulÃ¡rio

```JAVA
public class FormValidator extends Validator {
    @Override
    public ValidationResult validate(Object data) {
        // Implementar validaÃ§Ã£o
    }
}
```

1. Validador de Documentos

```JAVA
public class DocumentValidator extends Validator {
    @Override
    public ValidationResult validate(Object data) {
        // Implementar validaÃ§Ã£o
    }
}
```

## PrÃ³ximos Passos

* Implementar novos validadores

* Adicionar suporte a anotaÃ§Ãµes

* Criar validaÃ§Ãµes customizadas

* Integrar com frameworks

[PrÃ³ximo: Logger de Erros](error-logger.html)



# Logger de Erros

## VisÃ£o Geral

```MERMAID
graph TD
    A[Logger de Erros] --> B[Captura]
    A --> C[FormataÃ§Ã£o]
    A --> D[PersistÃªncia]
    
    B --> B1[ExceÃ§Ãµes]
    B --> B2[Contexto]
    B --> B3[Stack Trace]
    
    C --> C1[Estrutura]
    C --> C2[NÃ­veis]
    C --> C3[Metadados]
    
    D --> D1[Arquivo]
    D --> D2[Banco]
    D --> D3[ServiÃ§o]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style C fill:#1a1a1a,stroke:#33ccff
    style D fill:#1a1a1a,stroke:#33ccff
```

## ImplementaÃ§Ã£o Base

```JAVA
public class ErrorLogger {
    private final Queue<LogEntry> logQueue;
    
    public void log(Exception e, String context) {
        // ImplementaÃ§Ã£o
    }
}
```

## Componentes Principais

### 1. LogEntry

* Timestamp do erro

* Tipo da exceÃ§Ã£o

* Mensagem detalhada

* Stack trace

### 2. LogProcessor

* Processamento assÃ­ncrono

* FormataÃ§Ã£o de mensagens

* RotaÃ§Ã£o de arquivos

### 3. LogPersistence

* EstratÃ©gias de armazenamento

* PolÃ­ticas de retenÃ§Ã£o

* CompressÃ£o de logs

## NÃ­veis de Log

1. ERROR

* Erros crÃ­ticos

* Falhas de sistema

* ExceÃ§Ãµes nÃ£o tratadas

2. WARN

* SituaÃ§Ãµes inesperadas

* DegradaÃ§Ã£o de performance

* Retry operations

3. INFO

* Eventos importantes

* MudanÃ§as de estado

* OperaÃ§Ãµes principais

## Boas PrÃ¡ticas

1. Performance

* Logging assÃ­ncrono

* Buffer de mensagens

* CompressÃ£o eficiente

2. OrganizaÃ§Ã£o

* Estrutura clara

* RotaÃ§Ã£o de arquivos

* CategorizaÃ§Ã£o

3. SeguranÃ§a

* SanitizaÃ§Ã£o de dados

* Controle de acesso

* Backup regular

## Uso PrÃ¡tico

```JAVA
ErrorLogger logger = new ErrorLogger();

try {
    // OperaÃ§Ã£o que pode falhar
} catch (Exception e) {
    logger.log(e, "Contexto da operaÃ§Ã£o");
}
```

## Formatos de Log

1. JSON

```JSON
{
    "timestamp": "2024-01-20T10:15:30",
    "level": "ERROR",
    "message": "Falha na operaÃ§Ã£o",
    "stackTrace": "..."
}
```

1. Text

```TEXT
[2024-01-20 10:15:30] ERROR: Falha na operaÃ§Ã£o
Context: Processamento de pagamento
Stack: ...
```

## Monitoramento

1. MÃ©tricas

* Taxa de erros

* Tempo de processamento

* Uso de recursos

2. Alertas

* Thresholds

* NotificaÃ§Ãµes

* EscalaÃ§Ã£o

## ExercÃ­cios PrÃ¡ticos

1. Implementar RotaÃ§Ã£o

```JAVA
public class LogRotator {
    public void rotate(String logFile) {
        // Implementar rotaÃ§Ã£o
    }
}
```

1. Criar Formatador

```JAVA
public class LogFormatter {
    public String format(LogEntry entry) {
        // Implementar formataÃ§Ã£o
    }
}
```

## PrÃ³ximos Passos

* Implementar agregaÃ§Ã£o de logs

* Adicionar anÃ¡lise em tempo real

* Criar dashboards

* Integrar com APM

[PrÃ³ximo: Circuit Breaker](circuit-breaker.html)



# Circuit Breaker

## VisÃ£o Geral

```MERMAID
graph TD
    A[Circuit Breaker] --> B[Estados]
    A --> C[Monitoramento]
    A --> D[RecuperaÃ§Ã£o]
    
    B --> B1[Fechado]
    B --> B2[Aberto]
    B --> B3[Semi-Aberto]
    
    C --> C1[Falhas]
    C --> C2[Timeouts]
    C --> C3[MÃ©tricas]
    
    D --> D1[Fallback]
    D --> D2[Reset]
    D --> D3[Retry]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style C fill:#1a1a1a,stroke:#33ccff
    style D fill:#1a1a1a,stroke:#33ccff
```

## ImplementaÃ§Ã£o Base

```JAVA
public class CircuitBreaker {
    private CircuitState state;
    private int failureCount;
    
    public <T> T execute(Supplier<T> operation) {
        // ImplementaÃ§Ã£o
    }
}
```

## Estados do Circuit Breaker

### 1. CLOSED (Fechado)

* Estado normal

* OperaÃ§Ãµes permitidas

* Monitoramento de falhas

### 2. OPEN (Aberto)

* Falhas detectadas

* Rejeita requisiÃ§Ãµes

* Timeout para reset

### 3. HALF-OPEN (Semi-Aberto)

* PerÃ­odo de teste

* LimitaÃ§Ã£o de requisiÃ§Ãµes

* Monitoramento intensivo

## Componentes Principais

1. Failure Detection

* Contagem de falhas

* Tipos de erro

* Thresholds

2. State Management

* TransiÃ§Ãµes

* Timeouts

* Reset logic

3. Fallback Mechanism

* Respostas default

* Cache

* Alternativas

## Uso PrÃ¡tico

```JAVA
CircuitBreaker breaker = new CircuitBreaker("payment-service");
breaker.addFallback("process-payment", () -> "Fallback Response");

try {
    String result = breaker.execute("process-payment", 
        () -> paymentService.process());
} catch (CircuitBreakerException e) {
    // Handle exception
}
```

## ConfiguraÃ§Ãµes

1. Thresholds

```JAVA
public record BreakerConfig(
    int failureThreshold,
    long resetTimeout,
    int halfOpenCalls
) {}
```

1. MÃ©tricas

```JAVA
public class BreakerMetrics {
    private long failureCount;
    private long successCount;
    private double errorRate;
}
```

## PadrÃµes de Uso

1. Remote Services

* APIs externas

* MicroserviÃ§os

* Banco de dados

2. Resource Protection

* Rate limiting

* Load balancing

* DegradaÃ§Ã£o graciosa

## Boas PrÃ¡ticas

1. ConfiguraÃ§Ã£o

* Thresholds apropriados

* Timeouts adequados

* Fallbacks relevantes

2. Monitoramento

* Logging detalhado

* MÃ©tricas em tempo real

* Alertas

3. RecuperaÃ§Ã£o

* EstratÃ©gias de retry

* Backoff exponencial

* Cache de fallback

## ExercÃ­cios PrÃ¡ticos

1. Implementar MÃ©tricas

```JAVA
public class MetricsCollector {
    public void recordSuccess() {
        // Implementar
    }
    
    public void recordFailure() {
        // Implementar
    }
}
```

1. Criar Fallback

```JAVA
public class FallbackRegistry {
    public void register(String operation, Supplier<?> fallback) {
        // Implementar
    }
}
```

## IntegraÃ§Ã£o com Sistemas

1. Monitoring

* Prometheus

* Grafana

* Health checks

2. Logging

* Estado changes

* Falhas

* RecuperaÃ§Ãµes

## PrÃ³ximos Passos

* Implementar circuit breaker distribuÃ­do

* Adicionar mÃ©tricas avanÃ§adas

* Criar dashboard de monitoramento

* Integrar com service mesh

[Voltar para Projetos de Erro](error-projects.html)



# Recursos AvanÃ§ados do Java

## VisÃ£o Geral

```MERMAID
mindmap
  root((Recursos<br>AvanÃ§ados))
    (Generics)
      [Type Erasure]
      [Wildcards]
      [Bounds]
    (Lambda)
      [Functional Interfaces]
      [Method References]
      [Closure]
    (Streams)
      [Pipeline]
      [Collectors]
      [Parallel]
    (Optional)
      [Null Safety]
      [Monadic Operations]
    (Modules)
      [Encapsulation]
      [Dependencies]
    (Reflection)
      [Introspection]
      [Dynamic Invocation]
    (Annotations)
      [Runtime]
      [Compile-time]
    (Projetos)
      [Data Processor]
      [Custom Framework]
```

## Recursos Principais

### Generics

Permite criar classes e mÃ©todos type-safe que podem trabalhar com diferentes tipos:

```JAVA
public class Box<T> {
    private T content;
    
    public void set(T content) {
        this.content = content;
    }
    
    public T get() {
        return content;
    }
}
```

### Lambda Expressions

Implementa interfaces funcionais de forma concisa:

```JAVA
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.forEach(name -> System.out.println("Hello, " + name));
```

### Streams API

Processa coleÃ§Ãµes de forma declarativa:

```JAVA
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
                .filter(n -> n % 2 == 0)
                .mapToInt(Integer::intValue)
                .sum();
```

### Optional

Lida com valores nulos de forma segura:

```JAVA
Optional<String> optional = Optional.ofNullable(getValue());
String result = optional.map(String::toUpperCase)
                       .orElse("default");
```

### Sistema de MÃ³dulos

Encapsula e gerencia dependÃªncias:

```JAVA
module com.example.app {
    requires java.base;
    requires java.sql;
    
    exports com.example.api;
}
```

### Reflection

Examina e manipula cÃ³digo em runtime:

```JAVA
Class<?> clazz = MyClass.class;
Method method = clazz.getDeclaredMethod("myMethod");
method.invoke(instance);
```

### Annotations

Define metadados para cÃ³digo:

```JAVA
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Transactional {
    boolean readOnly() default false;
}
```

## AplicaÃ§Ãµes PrÃ¡ticas

### Desenvolvimento de Frameworks

```JAVA
@Controller
@RequestMapping("/api")
public class UserController {
    @Autowired
    private UserService service;
    
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return service.findById(id);
    }
}
```

### Processamento de Dados

```JAVA
public class DataProcessor<T> {
    public List<R> process(
        List<T> data,
        Predicate<T> filter,
        Function<T, R> transformer
    ) {
        return data.stream()
                  .filter(filter)
                  .map(transformer)
                  .collect(Collectors.toList());
    }
}
```

### Plugins DinÃ¢micos

```JAVA
public class PluginLoader {
    public Plugin loadPlugin(String className) {
        Class<?> pluginClass = Class.forName(className);
        return (Plugin) pluginClass.getDeclaredConstructor()
                                 .newInstance();
    }
}
```

## Melhores PrÃ¡ticas

1. Type Safety

* Use Generics apropriadamente

* Evite raw types

* Aplique bounds quando necessÃ¡rio

2. Performance

* Use Streams paralelos com cautela

* Cache resultados de reflection

* Otimize operaÃ§Ãµes lambda crÃ­ticas

3. Modularidade

* Defina interfaces claras

* Encapsule implementaÃ§Ãµes

* Gerencie dependÃªncias explicitamente

## PrÃ³ximos Passos

* [Generics](generics.html)

* [Lambda Expressions](lambda.html)

* [Streams API](streams.html)

* [Optional](optional.html)

* [Modules](modules.html)

* [Reflection](reflection.html)

* [Annotations](annotations.html)

* [Advanced Projects](advanced-projects.html)

## Recursos Adicionais

### DocumentaÃ§Ã£o Oficial

* [Java Language Specification](https://docs.oracle.com/javase/specs/)

* [JDK Documentation](https://docs.oracle.com/en/java/javase/)

### Ferramentas

* IDEs com suporte avanÃ§ado

* Analisadores estÃ¡ticos

* Frameworks de teste

### Comunidade

* FÃ³runs de discussÃ£o

* RepositÃ³rios de exemplo

* Blogs tÃ©cnicos

## Desafios de Aprendizado

1. Implemente um framework de injeÃ§Ã£o de dependÃªncia

2. Crie um processador de anotaÃ§Ãµes customizado

3. Desenvolva um container genÃ©rico thread-safe

4. Construa um sistema de plugins dinÃ¢mico

[Generics](generics.html)



# Generics: Flexibilidade com Tipo Seguro

```
GENERICS MAP
â”œâ”€â”€ Type Parameters
â”œâ”€â”€ Generic Classes
â”œâ”€â”€ Generic Methods
â””â”€â”€ Type Bounds
```

## Conceitos BÃ¡sicos

### Type Parameters

```JAVA
// T Ã© um type parameter comum
public class Box<T> {
    private T content;
    
    public void store(T item) {
        this.content = item;
    }
    
    public T retrieve() {
        return content;
    }
}
```

### ConvenÃ§Ãµes de Nomenclatura

* `T` - Tipo genÃ©rico

* `E` - Elemento

* `K` - Chave

* `V` - Valor

* `N` - NÃºmero

## Wildcards

### Upper Bounded

```JAVA
// Aceita Number ou subtipos
public void process(List<? extends Number> numbers) {
    for (Number n : numbers) {
        System.out.println(n.doubleValue());
    }
}
```

### Lower Bounded

```JAVA
// Aceita Integer ou supertipos
public void addNumbers(List<? super Integer> list) {
    list.add(10);
    list.add(20);
}
```

## Type Erasure

O Java usa type erasure para implementar generics:

```JAVA
// Em tempo de compilaÃ§Ã£o
List<String> strings = new ArrayList<String>();

// Em runtime se torna
List strings = new ArrayList();
```

## PrÃ¡ticas Recomendadas

1. Use Generics para Collections

```JAVA
// Ruim
List lista = new ArrayList();

// Bom
List<String> lista = new ArrayList<>();
```

1. Defina Bounds Quando NecessÃ¡rio

```JAVA
public class NumericBox<T extends Number> {
    private T number;
    
    public double getValue() {
        return number.doubleValue();
    }
}
```

## ExercÃ­cio PrÃ¡tico

Implemente uma classe genÃ©rica `Stack<T>`:

```JAVA
public class Stack<T> {
    private List<T> items = new ArrayList<>();
    
    public void push(T item) {
        items.add(item);
    }
    
    public T pop() {
        if (items.isEmpty()) {
            throw new EmptyStackException();
        }
        return items.remove(items.size() - 1);
    }
}
```



# ExpressÃµes Lambda: ProgramaÃ§Ã£o Funcional em Java

```
LAMBDA CONCEPTS
â”œâ”€â”€ Syntax
â”œâ”€â”€ Functional Interfaces
â”œâ”€â”€ Method References
â””â”€â”€ Common Use Cases
```

## Sintaxe BÃ¡sica

### Forma PadrÃ£o

```JAVA
// Sintaxe: (parÃ¢metros) -> { corpo }
Runnable r = () -> { System.out.println("Executando"); };

// VersÃ£o simplificada
Comparator<String> c = (s1, s2) -> s1.length() - s2.length();
```

## Interfaces Funcionais Comuns

### Function<T,R>

```JAVA
Function<String, Integer> length = str -> str.length();
Integer size = length.apply("NetRunner");
```

### 

Predicate

```JAVA
Predicate<String> isEmpty = str -> str.trim().isEmpty();
boolean result = isEmpty.test("  ");
```

### 

Consumer

```JAVA
Consumer<String> print = msg -> System.out.println(msg);
print.accept("Hello, Runner!");
```

### 

Supplier

```JAVA
Supplier<LocalDateTime> now = () -> LocalDateTime.now();
LocalDateTime time = now.get();
```

## Method References

### Tipos de References

```JAVA
// ReferÃªncia a mÃ©todo estÃ¡tico
Function<String, Integer> parser = Integer::parseInt;

// ReferÃªncia a mÃ©todo de instÃ¢ncia
String str = "NetRunner";
Supplier<Integer> length = str::length;

// ReferÃªncia a construtor
Supplier<ArrayList<String>> constructor = ArrayList::new;
```

## ComposiÃ§Ã£o de FunÃ§Ãµes

### Combining Functions

```JAVA
Function<String, String> upper = String::toUpperCase;
Function<String, String> trim = String::trim;
Function<String, String> combined = upper.andThen(trim);
```

## Exemplo PrÃ¡tico

### Stream com Lambda

```JAVA
List<String> hackers = Arrays.asList("Neo", "Trinity", "Morpheus");

hackers.stream()
    .filter(name -> name.length() > 3)
    .map(String::toUpperCase)
    .forEach(System.out::println);
```

## Boas PrÃ¡ticas

1. Mantenha Lambdas Simples

```JAVA
// Ruim
button.setOnAction(e -> {
    // 20 linhas de cÃ³digo aqui
});

// Bom
button.setOnAction(this::handleClick);
```

1. Use Method References

```JAVA
// Menos legÃ­vel
list.forEach(item -> System.out.println(item));

// Mais legÃ­vel
list.forEach(System.out::println);
```

## ExercÃ­cio

Implemente um sistema de filtro usando lambdas:

```JAVA
public class HackerFilter {
    public static List<Hacker> filterBySkill(
        List<Hacker> hackers,
        Predicate<Hacker> criteria
    ) {
        return hackers.stream()
                     .filter(criteria)
                     .collect(Collectors.toList());
    }
}

// Uso
List<Hacker> eliteHackers = filterBySkill(
    hackerList,
    h -> h.getSkillLevel() > 9000
);
```



# Streams API: Processamento de Dados Fluente

```
STREAMS API
â”œâ”€â”€ Creation
â”œâ”€â”€ Intermediate Ops
â”œâ”€â”€ Terminal Ops
â””â”€â”€ Parallel Streams
```

## Criando Streams

### MÃ©todos de CriaÃ§Ã£o

```JAVA
// De Collection
List<String> list = Arrays.asList("Neo", "Trinity");
Stream<String> stream = list.stream();

// Stream direto
Stream<String> direct = Stream.of("Morpheus", "Tank");

// Stream infinito
Stream<Integer> infinite = Stream.iterate(0, n -> n + 1);
```

## OperaÃ§Ãµes IntermediÃ¡rias

### Filter

```JAVA
List<String> hackers = Arrays.asList("Neo", "Trinity", "Morpheus");
hackers.stream()
      .filter(name -> name.length() > 3)
      .collect(Collectors.toList());
```

### Map

```JAVA
List<Integer> lengths = hackers.stream()
    .map(String::length)
    .collect(Collectors.toList());
```

### FlatMap

```JAVA
List<List<String>> nested = Arrays.asList(
    Arrays.asList("Neo", "Trinity"),
    Arrays.asList("Morpheus", "Tank")
);

List<String> flat = nested.stream()
    .flatMap(List::stream)
    .collect(Collectors.toList());
```

## OperaÃ§Ãµes Terminais

### Collect

```JAVA
// Para Lista
List<String> list = stream.collect(Collectors.toList());

// Para Set
Set<String> set = stream.collect(Collectors.toSet());

// Para Map
Map<String, Integer> map = stream.collect(
    Collectors.toMap(
        s -> s,
        String::length
    )
);
```

### Reduce

```JAVA
Optional<Integer> sum = Stream.of(1, 2, 3)
    .reduce((a, b) -> a + b);

int total = Stream.of(1, 2, 3)
    .reduce(0, Integer::sum);
```

## Streams Paralelos

### Processamento Paralelo

```JAVA
// Stream paralelo de Collection
List<String> result = hackers.parallelStream()
    .filter(name -> name.length() > 3)
    .collect(Collectors.toList());

// Converter para paralelo
Stream<String> parallel = stream.parallel();
```

## Exemplos PrÃ¡ticos

### AnÃ¡lise de Dados

```JAVA
class HackerStats {
    public static Map<String, Long> analyzeSkills(List<Hacker> hackers) {
        return hackers.stream()
            .flatMap(h -> h.getSkills().stream())
            .collect(Collectors.groupingBy(
                skill -> skill,
                Collectors.counting()
            ));
    }
}
```

### Pipeline Complexo

```JAVA
List<Hacker> eliteSquad = hackers.stream()
    .filter(h -> h.getLevel() > 50)
    .sorted(Comparator.comparing(Hacker::getSkillLevel).reversed())
    .limit(5)
    .collect(Collectors.toList());
```

## Boas PrÃ¡ticas

1. Use Parallel com Cautela

```JAVA
// Nem sempre mais rÃ¡pido!
boolean anyMatch = hugeList.parallelStream()
    .anyMatch(predicate);
```

1. Evite Estado MutÃ¡vel

```JAVA
// Ruim
List<String> results = new ArrayList<>();
stream.forEach(results::add);

// Bom
List<String> results = stream.collect(Collectors.toList());
```

## ExercÃ­cio

Implemente um sistema de anÃ¡lise de logs:

```JAVA
public class LogAnalyzer {
    public static Map<String, Long> analyzeErrors(
        List<LogEntry> logs
    ) {
        return logs.stream()
            .filter(log -> log.getLevel() == Level.ERROR)
            .collect(Collectors.groupingBy(
                LogEntry::getErrorCode,
                Collectors.counting()
            ));
    }
}
```



# Optional: Tratamento Elegante de Null

```
OPTIONAL API
â”œâ”€â”€ Creation
â”œâ”€â”€ Checking
â”œâ”€â”€ Extraction
â””â”€â”€ Transformation
```

## Criando Optionals

### MÃ©todos de CriaÃ§Ã£o

```JAVA
// Valor presente
Optional<String> present = Optional.of("Neo");

// Possivelmente null
Optional<String> nullable = Optional.ofNullable(getValue());

// Definitivamente vazio
Optional<String> empty = Optional.empty();
```

## Verificando Valores

### MÃ©todos de VerificaÃ§Ã£o

```JAVA
Optional<String> opt = Optional.of("Trinity");

// Verifica se hÃ¡ valor
boolean hasValue = opt.isPresent();

// Verifica se estÃ¡ vazio
boolean isEmpty = opt.isEmpty(); // Java 11+
```

## Extraindo Valores

### MÃ©todos de ExtraÃ§Ã£o

```JAVA
String value = opt.get(); // Pode lanÃ§ar NoSuchElementException

// Com valor padrÃ£o
String safe = opt.orElse("Default");

// Com supplier
String computed = opt.orElseGet(() -> computeDefault());

// Com exceÃ§Ã£o
String required = opt.orElseThrow(
    () -> new IllegalStateException("Valor requerido")
);
```

## Transformando Valores

### Map e FlatMap

```JAVA
Optional<String> upper = opt.map(String::toUpperCase);

Optional<Optional<String>> nested = 
    Optional.of(Optional.of("Nested"));
Optional<String> flat = nested.flatMap(o -> o);
```

## PadrÃµes de Uso

### Encadeamento

```JAVA
public class UserService {
    public Optional<String> getEmail(String userId) {
        return findUser(userId)
            .map(User::getProfile)
            .map(Profile::getEmail);
    }
}
```

### Consumindo Valores

```JAVA
opt.ifPresent(value -> System.out.println(value));

// Com aÃ§Ã£o alternativa (Java 9+)
opt.ifPresentOrElse(
    value -> System.out.println(value),
    () -> System.out.println("Vazio")
);
```

## Boas PrÃ¡ticas

1. Evite Optional.get()

```JAVA
// Ruim
String value = optional.get();

// Bom
String value = optional.orElse("default");
```

1. NÃ£o use Optional como ParÃ¢metro

```JAVA
// Ruim
public void process(Optional<String> value) {}

// Bom
public void process(String value) {}
```

1. Use para Retornos

```JAVA
public Optional<User> findUser(String id) {
    User user = database.query(id);
    return Optional.ofNullable(user);
}
```

## Exemplo PrÃ¡tico

### Sistema de ConfiguraÃ§Ã£o

```JAVA
public class Config {
    private Map<String, String> settings;

    public Optional<String> getSetting(String key) {
        return Optional.ofNullable(settings.get(key));
    }

    public String getSettingWithDefault(String key) {
        return getSetting(key)
            .map(String::trim)
            .filter(s -> !s.isEmpty())
            .orElse("default");
    }
}
```

## ExercÃ­cio

Implemente um sistema de cache com Optional:

```JAVA
public class Cache<K, V> {
    private Map<K, V> storage = new HashMap<>();

    public Optional<V> get(K key) {
        return Optional.ofNullable(storage.get(key));
    }

    public V getOrCompute(K key, Supplier<V> computer) {
        return get(key)
            .orElseGet(() -> {
                V value = computer.get();
                storage.put(key, value);
                return value;
            });
    }
}
```



# Sistema de MÃ³dulos Java

## VisÃ£o Geral

O sistema de mÃ³dulos do Java (Project Jigsaw) foi introduzido no Java 9 para melhorar a modularidade e escalabilidade de aplicaÃ§Ãµes Java.

## Conceitos Fundamentais

### Estrutura de um MÃ³dulo

```
MODULE STRUCTURE
â”œâ”€â”€ module-info.java
â”œâ”€â”€ com.example.module
â”‚   â”œâ”€â”€ internal
â”‚   â””â”€â”€ api
â””â”€â”€ resources
```

## DeclaraÃ§Ã£o de MÃ³dulo

### Sintaxe BÃ¡sica

```JAVA
module com.example.mymodule {
    requires java.base;
    exports com.example.api;
    provides com.example.spi.MyService with com.example.impl.MyServiceImpl;
}
```

## Diretivas Principais

### Exports

* Controla quais pacotes sÃ£o acessÃ­veis

* Permite exportaÃ§Ã£o seletiva

* Gerencia visibilidade do mÃ³dulo

### Requires

* Define dependÃªncias do mÃ³dulo

* Especifica mÃ³dulos necessÃ¡rios

* Controla transitividade

### Provides/Uses

* Implementa serviÃ§os

* Define interfaces de serviÃ§o

* Permite extensibilidade

## BenefÃ­cios

1. Encapsulamento Forte

* Melhor seguranÃ§a

* Controle de acesso refinado

* Isolamento de implementaÃ§Ã£o

2. DependÃªncias ExplÃ­citas

* Clareza nas relaÃ§Ãµes

* GestÃ£o simplificada

* DetecÃ§Ã£o precoce de problemas

3. Performance

* Carregamento otimizado

* Menor footprint de memÃ³ria

* InicializaÃ§Ã£o mais rÃ¡pida

## PrÃ¡ticas Recomendadas

### OrganizaÃ§Ã£o

* MÃ³dulos coesos

* Interfaces bem definidas

* DependÃªncias mÃ­nimas

### Nomenclatura

* Nomes descritivos

* ConvenÃ§Ãµes consistentes

* Hierarquia lÃ³gica

## Exemplos PrÃ¡ticos

### MÃ³dulo BÃ¡sico

```JAVA
module com.example.core {
    exports com.example.core.api;
    requires java.logging;
}
```

### MÃ³dulo de ServiÃ§o

```JAVA
module com.example.service {
    exports com.example.service;
    provides com.example.spi.Service with com.example.service.impl.ServiceImpl;
}
```

## Ferramentas e Comandos

### jmod

```BASH
jmod create --class-path mods/com.example.mymodule
```

### jdeps

```BASH
jdeps --module-path mods com.example.mymodule
```

## MigraÃ§Ã£o para MÃ³dulos

### Passos

1. AnÃ¡lise de dependÃªncias

2. CriaÃ§Ã£o do module-info

3. RefatoraÃ§Ã£o de cÃ³digo

4. Testes de integraÃ§Ã£o

### Desafios Comuns

* DependÃªncias circulares

* CÃ³digo legado

* Bibliotecas nÃ£o modulares

## Recursos Adicionais

### DocumentaÃ§Ã£o

* [JEP 261](https://openjdk.java.net/jeps/261)

* Java Platform Module System Specification

* Tutorial oficial do Java

### Ferramentas

* Maven plugins

* Gradle support

* IDE integration



# Reflection API

## Fundamentos

### O que Ã© Reflection?

Reflection Ã© a capacidade de examinar e modificar o comportamento de classes, interfaces e mÃ©todos em tempo de execuÃ§Ã£o.

## Principais Componentes

### Class<?>

```JAVA
// Obtendo Class object
Class<?> clazz = MyClass.class;
Class<?> clazz = objeto.getClass();
Class<?> clazz = Class.forName("com.example.MyClass");
```

### MÃ©todos

```JAVA
// Acessando mÃ©todos
Method[] methods = clazz.getDeclaredMethods();
Method method = clazz.getDeclaredMethod("methodName", parameterTypes);
```

### Campos

```JAVA
// Acessando campos
Field[] fields = clazz.getDeclaredFields();
Field field = clazz.getDeclaredField("fieldName");
```

## Casos de Uso

### InspeÃ§Ã£o de Classes

```JAVA
public void inspectClass(Class<?> clazz) {
    System.out.println("Class: " + clazz.getName());
    System.out.println("Superclass: " + clazz.getSuperclass().getName());
    System.out.println("Interfaces: " + Arrays.toString(clazz.getInterfaces()));
}
```

### ManipulaÃ§Ã£o de Objetos

```JAVA
public Object createInstance(String className) throws Exception {
    Class<?> clazz = Class.forName(className);
    return clazz.getDeclaredConstructor().newInstance();
}
```

## Recursos AvanÃ§ados

### AnotaÃ§Ãµes

```JAVA
// Lendo anotaÃ§Ãµes
Annotation[] annotations = clazz.getAnnotations();
MyAnnotation annotation = clazz.getAnnotation(MyAnnotation.class);
```

### Generics

```JAVA
// Trabalhando com tipos genÃ©ricos
Type[] genericTypes = ((ParameterizedType) field.getGenericType())
    .getActualTypeArguments();
```

## Boas PrÃ¡ticas

### Performance

* Cache de reflection

* Minimizar uso em loops

* Preferir acesso direto quando possÃ­vel

### SeguranÃ§a

* Usar setAccessible com cautela

* Validar entrada do usuÃ¡rio

* Considerar polÃ­ticas de seguranÃ§a

## Exemplos PrÃ¡ticos

### Framework de Teste

```JAVA
public class TestRunner {
    public void runTests(Class<?> testClass) throws Exception {
        Object instance = testClass.getDeclaredConstructor().newInstance();
        
        for (Method method : testClass.getDeclaredMethods()) {
            if (method.isAnnotationPresent(Test.class)) {
                method.invoke(instance);
            }
        }
    }
}
```

### InjeÃ§Ã£o de DependÃªncia

```JAVA
public class DependencyInjector {
    public void inject(Object instance) throws Exception {
        Class<?> clazz = instance.getClass();
        
        for (Field field : clazz.getDeclaredFields()) {
            if (field.isAnnotationPresent(Inject.class)) {
                field.setAccessible(true);
                field.set(instance, createDependency(field.getType()));
            }
        }
    }
}
```

## Debugging e Troubleshooting

### Erros Comuns

1. IllegalAccessException

2. NoSuchMethodException

3. InvocationTargetException

### SoluÃ§Ãµes

```JAVA
// Tratamento de exceÃ§Ãµes
try {
    method.setAccessible(true);
    method.invoke(object, args);
} catch (Exception e) {
    handleReflectionException(e);
}
```

## Performance

### OtimizaÃ§Ãµes

```JAVA
// Cache de reflection
private static final Map<Class<?>, Method[]> methodCache = new ConcurrentHashMap<>();

public Method[] getMethods(Class<?> clazz) {
    return methodCache.computeIfAbsent(clazz, Class::getDeclaredMethods);
}
```

## Recursos Adicionais

### DocumentaÃ§Ã£o

* Java Reflection API Documentation

* Tutorial Oracle sobre Reflection

* EspecificaÃ§Ã£o da linguagem Java

### Ferramentas

* ByteBuddy

* Reflections Library

* ASM



# AnotaÃ§Ãµes em Java

## Fundamentos

### O que sÃ£o AnotaÃ§Ãµes?

AnotaÃ§Ãµes sÃ£o metadados que podem ser adicionados ao cÃ³digo Java para fornecer informaÃ§Ãµes adicionais sobre o programa.

## Tipos de AnotaÃ§Ãµes

### Built-in Annotations

```JAVA
@Override
@Deprecated
@SuppressWarnings
@FunctionalInterface
@SafeVarargs
```

### Meta-Annotations

```JAVA
@Retention
@Target
@Documented
@Inherited
@Repeatable
```

## Criando AnotaÃ§Ãµes

### Sintaxe BÃ¡sica

```JAVA
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test {
    String value() default "";
    boolean enabled() default true;
}
```

### Elementos de AnotaÃ§Ã£o

```JAVA
public @interface Configuration {
    String name();              // Elemento obrigatÃ³rio
    int port() default 8080;    // Elemento com valor default
    String[] protocols();       // Array
}
```

## Criando Annotations Personalizadas

### Anatomia de uma Annotation

```JAVA
@Retention(RetentionPolicy.RUNTIME)           // Quando a annotation estÃ¡ disponÃ­vel
@Target({ElementType.METHOD, ElementType.TYPE}) // Onde pode ser usada
@Documented                                   // Incluir na documentaÃ§Ã£o JavaDoc
public @interface MinhaAnnotation {
    String value();                // Elemento obrigatÃ³rio
    int count() default 0;         // Elemento opcional com valor padrÃ£o
    String[] tags() default {};    // Array com valor padrÃ£o vazio
}
```

### Tipos de Elementos Permitidos

```JAVA
public @interface ConfiguracaoCompleta {
    // Tipos primitivos
    int valor();
    boolean ativo();
    
    // String
    String descricao();
    
    // Class
    Class<?> tipo();
    
    // Enum
    NivelLog nivel() default NivelLog.INFO;
    
    // Annotation
    Override referencia() default @Override;
    
    // Arrays
    String[] tags();
}
```

### Valores Default

```JAVA
public @interface Configuracao {
    // Valor Ãºnico sem default (obrigatÃ³rio)
    String nome();
    
    // Valor Ãºnico com default (opcional)
    int timeout() default 1000;
    
    // Array com default vazio
    String[] perfis() default {};
    
    // Array com valores default
    String[] ambientes() default {"dev", "test"};
}
```

### Annotations Simples vs. Complexas

#### Annotation Simples (Marker)

```JAVA
// Annotation marcadora - sem elementos
public @interface Auditavel {}

// Uso
@Auditavel
public class ContaBancaria {}
```

#### Annotation com Valor Ãšnico

```JAVA
public @interface NomeTabela {
    String value();  // Elemento especial 'value'
}

// Uso simplificado
@NomeTabela("usuarios")
public class Usuario {}
```

#### Annotation Complexa

```JAVA
public @interface Entidade {
    String nome();
    String schema() default "";
    boolean auditavel() default false;
    String[] indices() default {};
}

// Uso
@Entidade(
    nome = "produtos",
    schema = "estoque",
    auditavel = true,
    indices = {"idx_nome", "idx_codigo"}
)
public class Produto {}
```

### Annotations Aninhadas

```JAVA
// Annotation interna
public @interface Coluna {
    String nome();
    boolean nullable() default true;
}

// Annotation container
public @interface Colunas {
    Coluna[] value();
}

// Uso
@Colunas({
    @Coluna(nome = "id", nullable = false),
    @Coluna(nome = "nome")
})
public class Exemplo {}
```

### Processamento de Annotations Customizadas

```JAVA
public class ProcessadorAnnotation {
    public void processar(Class<?> classe) {
        // Verificando se a classe tem a annotation
        if (classe.isAnnotationPresent(MinhaAnnotation.class)) {
            // Obtendo a annotation
            MinhaAnnotation annotation = 
                classe.getAnnotation(MinhaAnnotation.class);
            
            // Acessando elementos
            String valor = annotation.value();
            int contador = annotation.count();
            String[] tags = annotation.tags();
            
            // Processamento...
        }
    }
}
```

### Exemplo Completo

```JAVA
// DefiniÃ§Ã£o da annotation
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface ServicoRest {
    String path();
    String versao() default "1.0";
    MetodoHttp[] metodos() default {};
    
    public enum MetodoHttp {
        GET, POST, PUT, DELETE
    }
}

// Uso da annotation
@ServicoRest(
    path = "/usuarios",
    versao = "2.0",
    metodos = {
        ServicoRest.MetodoHttp.GET,
        ServicoRest.MetodoHttp.POST
    }
)
public class UsuarioController {
    // ImplementaÃ§Ã£o...
}

// Processamento
public class ServicoRestScanner {
    public void scanearServicos(String pacote) {
        // LÃ³gica para encontrar classes no pacote
        Class<?>[] classes = // ...
        
        for (Class<?> classe : classes) {
            if (classe.isAnnotationPresent(ServicoRest.class)) {
                ServicoRest servico = 
                    classe.getAnnotation(ServicoRest.class);
                
                // Registrar endpoint
                registrarEndpoint(
                    servico.path(),
                    servico.versao(),
                    servico.metodos()
                );
            }
        }
    }
    
    private void registrarEndpoint(
        String path, 
        String versao, 
        MetodoHttp[] metodos
    ) {
        // ImplementaÃ§Ã£o do registro...
    }
}
```

## Uso de AnotaÃ§Ãµes

### Em Classes

```JAVA
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue
    private Long id;
    
    @Column(nullable = false)
    private String name;
}
```

### Em MÃ©todos

```JAVA
@Test
@Timeout(value = 1000, unit = TimeUnit.MILLISECONDS)
public void testMethod() {
    // Test implementation
}
```

## Processamento de AnotaÃ§Ãµes

### Em Tempo de CompilaÃ§Ã£o

```JAVA
@SupportedAnnotationTypes("com.example.annotations.*")
@SupportedSourceVersion(SourceVersion.RELEASE_17)
public class MyAnnotationProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        // Processamento
        return true;
    }
}
```

### Em Tempo de ExecuÃ§Ã£o

```JAVA
public class AnnotationReader {
    public void readAnnotations(Class<?> clazz) {
        for (Method method : clazz.getDeclaredMethods()) {
            if (method.isAnnotationPresent(Test.class)) {
                Test test = method.getAnnotation(Test.class);
                System.out.println("Test: " + test.value());
            }
        }
    }
}
```

## PadrÃµes de Uso

### ValidaÃ§Ã£o

```JAVA
@NotNull
@Size(min = 5, max = 50)
private String username;

@Email
@NotBlank
private String email;
```

### ConfiguraÃ§Ã£o

```JAVA
@Configuration
@EnableCaching
public class AppConfig {
    @Bean
    @Scope("singleton")
    public CacheManager cacheManager() {
        return new ConcurrentMapCacheManager();
    }
}
```

## Boas PrÃ¡ticas

### Nomenclatura

* Nomes descritivos

* ConvenÃ§Ãµes consistentes

* DocumentaÃ§Ã£o clara

### Design

* Mantenha simples

* Evite duplicaÃ§Ã£o

* Use valores default apropriados

## Exemplos AvanÃ§ados

### AnotaÃ§Ãµes RepetÃ­veis

```JAVA
@Repeatable(Roles.class)
public @interface Role {
    String value();
}

public @interface Roles {
    Role[] value();
}

@Role("ADMIN")
@Role("USER")
public class UserController { }
```

### AnotaÃ§Ãµes Compostas

```JAVA
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@SpringBootApplication
@EnableCaching
@EnableScheduling
public @interface MyApplication { }
```

## Casos de Uso

### Framework de Teste

```JAVA
@Test
@DisplayName("Teste de soma")
@Tag("math")
public void testAdd() {
    assertEquals(4, Calculator.add(2, 2));
}
```

### InjeÃ§Ã£o de DependÃªncia

```JAVA
@Component
public class UserService {
    @Autowired
    private UserRepository repository;
    
    @Transactional
    public void saveUser(User user) {
        repository.save(user);
    }
}
```

## Recursos Adicionais

### DocumentaÃ§Ã£o

* Java Annotation Specification

* Tutorial Oracle sobre Annotations

* Processadores de AnotaÃ§Ã£o

### Frameworks

* Spring Annotations

* JUnit Annotations

* Jakarta EE Annotations



# Projetos AvanÃ§ados

## VisÃ£o Geral

```MERMAID
graph TD
    A[Projetos AvanÃ§ados] --> B[Data Processor]
    A --> C[Functional Calculator]
    A --> D[Custom Framework]
    A --> E[Annotation Processor]
    A --> F[Generic Container]
    A --> G[Reflection Explorer]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style C fill:#1a1a1a,stroke:#33ccff
    style D fill:#1a1a1a,stroke:#33ccff
    style E fill:#1a1a1a,stroke:#33ccff
    style F fill:#1a1a1a,stroke:#33ccff
    style G fill:#1a1a1a,stroke:#33ccff
```

## Estrutura Base dos Projetos

```
PROJETO
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/
â”‚   â”‚   â”œâ”€â”€ java/
â”‚   â”‚   â”‚   â””â”€â”€ com/
â”‚   â”‚   â”‚       â””â”€â”€ netrunner/
â”‚   â”‚   â”‚           â””â”€â”€ project/
â”‚   â”‚   â”‚               â”œâ”€â”€ annotations/
â”‚   â”‚   â”‚               â”œâ”€â”€ processors/
â”‚   â”‚   â”‚               â”œâ”€â”€ core/
â”‚   â”‚   â”‚               â””â”€â”€ util/
â”‚   â”‚   â””â”€â”€ resources/
â”‚   â”‚       â””â”€â”€ META-INF/
â”‚   â”‚           â””â”€â”€ services/
â”‚   â””â”€â”€ test/
â”‚       â””â”€â”€ java/
â””â”€â”€ pom.xml
```

## Data Processor

### Objetivo

Criar um sistema de processamento de dados com anotaÃ§Ãµes personalizadas para validaÃ§Ã£o, transformaÃ§Ã£o e persistÃªncia.

### CaracterÃ­sticas

* AnotaÃ§Ãµes para validaÃ§Ã£o de campos

* Transformadores de dados customizÃ¡veis

* Pipeline de processamento configurÃ¡vel

* Suporte a diferentes formatos de dados

### Exemplo de ImplementaÃ§Ã£o

```JAVA
@Entity
@DataProcessor(version = "1.0")
public class UserData {
    @Validate(pattern = "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,6}$")
    private String email;
    
    @Transform(transformer = EncryptTransformer.class)
    private String password;
    
    @Persist(strategy = "JDBC")
    private UserProfile profile;
}
```

## Functional Calculator

### Objetivo

Implementar uma calculadora avanÃ§ada usando programaÃ§Ã£o funcional e expressÃµes lambda.

### CaracterÃ­sticas

* OperaÃ§Ãµes encadeadas

* HistÃ³rico de operaÃ§Ãµes

* FunÃ§Ãµes customizÃ¡veis

* Suporte a expressÃµes complexas

### Exemplo de ImplementaÃ§Ã£o

```JAVA
public class FunctionalCalculator {
    @Operation("SUM")
    public Function<Double, Double> sum(Double a) {
        return b -> a + b;
    }
    
    @Operation("COMPOSE")
    public <T, R> Function<T, R> compose(
        @OperationParam Function<T, R>... functions
    ) {
        return Arrays.stream(functions)
                    .reduce(Function.identity(), Function::andThen);
    }
}
```

## Custom Framework

### Objetivo

Desenvolver um mini-framework usando reflexÃ£o e anotaÃ§Ãµes para injeÃ§Ã£o de dependÃªncias.

### CaracterÃ­sticas

* InjeÃ§Ã£o de dependÃªncias

* Gerenciamento de ciclo de vida

* ConfiguraÃ§Ã£o via anotaÃ§Ãµes

* Suporte a plugins

### Exemplo de ImplementaÃ§Ã£o

```JAVA
@Component
@Scope("singleton")
public class ServiceManager {
    @Inject
    private ConfigProvider config;
    
    @Initialize
    public void setup() {
        // InicializaÃ§Ã£o
    }
    
    @HandleRequest("/api")
    public Response processRequest(Request request) {
        // Processamento
    }
}
```

## Annotation Processor

### Objetivo

Criar um processador de anotaÃ§Ãµes para geraÃ§Ã£o de cÃ³digo em tempo de compilaÃ§Ã£o.

### CaracterÃ­sticas

* GeraÃ§Ã£o de cÃ³digo

* ValidaÃ§Ã£o em tempo de compilaÃ§Ã£o

* DocumentaÃ§Ã£o automÃ¡tica

* Templates customizÃ¡veis

### Exemplo de ImplementaÃ§Ã£o

```JAVA
@SupportedAnnotationTypes("com.netrunner.annotations.*")
@SupportedSourceVersion(SourceVersion.RELEASE_17)
public class CustomAnnotationProcessor extends AbstractProcessor {
    @Override
    public boolean process(
        Set<? extends TypeElement> annotations,
        RoundEnvironment roundEnv
    ) {
        // Processamento das anotaÃ§Ãµes
        return true;
    }
}
```

## Generic Container

### Objetivo

Implementar um container genÃ©rico com suporte a diferentes tipos de dados e operaÃ§Ãµes.

### CaracterÃ­sticas

* Tipos genÃ©ricos

* OperaÃ§Ãµes type-safe

* ValidaÃ§Ãµes em tempo de compilaÃ§Ã£o

* ConversÃµes automÃ¡ticas

### Exemplo de ImplementaÃ§Ã£o

```JAVA
@Container
public class DataContainer<T extends Comparable<T>> {
    @Validate
    private List<T> elements;
    
    @Operation
    public <R> Optional<R> transform(
        @Transformer Function<T, R> transformer
    ) {
        // TransformaÃ§Ã£o de dados
    }
}
```

## Reflection Explorer

### Objetivo

Criar uma ferramenta para exploraÃ§Ã£o e manipulaÃ§Ã£o de classes usando reflexÃ£o.

### CaracterÃ­sticas

* InspeÃ§Ã£o de classes

* ModificaÃ§Ã£o em runtime

* Proxy dinÃ¢mico

* Carregamento de classes

### Exemplo de ImplementaÃ§Ã£o

```JAVA
public class ReflectionExplorer {
    @Inspect
    public ClassInfo analyze(Class<?> target) {
        return ClassInfo.builder()
                       .methods(getMethods(target))
                       .fields(getFields(target))
                       .annotations(getAnnotations(target))
                       .build();
    }
    
    @Modify
    public Object enhance(
        @Target Object instance,
        @Enhancement Enhancement enhancement
    ) {
        // ModificaÃ§Ã£o dinÃ¢mica
    }
}
```

## Desafios Extras

### Data Processor

* Implementar validaÃ§Ã£o assÃ­ncrona

* Adicionar suporte a expressÃµes regulares complexas

* Criar pipeline de transformaÃ§Ã£o configurÃ¡vel

* Implementar persistÃªncia em diferentes bancos

### Functional Calculator

* Adicionar suporte a operaÃ§Ãµes matemÃ¡ticas avanÃ§adas

* Implementar sistema de plugins para novas operaÃ§Ãµes

* Criar DSL para expressÃµes matemÃ¡ticas

* Adicionar suporte a cÃ¡lculos paralelos

### Custom Framework

* Implementar hot reload de componentes

* Adicionar suporte a aspectos

* Criar sistema de plugins dinÃ¢micos

* Implementar balanceamento de carga

### Annotation Processor

* Gerar documentaÃ§Ã£o automÃ¡tica

* Implementar validaÃ§Ãµes complexas

* Criar templates customizÃ¡veis

* Adicionar suporte a diferentes linguagens

### Generic Container

* Implementar operaÃ§Ãµes batch

* Adicionar suporte a streams

* Criar sistema de cache inteligente

* Implementar serializaÃ§Ã£o customizada

### Reflection Explorer

* Adicionar suporte a bytecode manipulation

* Implementar hot swapping de classes

* Criar visualizaÃ§Ã£o grÃ¡fica de hierarquias

* Implementar debugging dinÃ¢mico

## Dicas de ImplementaÃ§Ã£o

1. Planejamento

* Comece com diagramas UML

* Defina casos de uso claros

* EstabeleÃ§a critÃ©rios de aceitaÃ§Ã£o

* Planeje a arquitetura

2. Desenvolvimento

* Use TDD/BDD

* Implemente incrementalmente

* Documente decisÃµes importantes

* Mantenha o cÃ³digo limpo

3. Testes

* Crie testes unitÃ¡rios

* Implemente testes de integraÃ§Ã£o

* Realize testes de performance

* Valide edge cases

4. OtimizaÃ§Ã£o

* Profile o cÃ³digo

* Otimize pontos crÃ­ticos

* Monitore uso de recursos

* Implemente caching quando necessÃ¡rio

## Recursos Adicionais

### DocumentaÃ§Ã£o

* JavaDoc completo

* Diagramas de arquitetura

* Guias de uso

* Exemplos prÃ¡ticos

### Ferramentas

* IDEs recomendadas

* Plugins Ãºteis

* Frameworks de teste

* Ferramentas de build

### Comunidade

* FÃ³runs de discussÃ£o

* Canais de suporte

* RepositÃ³rios de exemplo

* Artigos relacionados



# Data Processor

## VisÃ£o Geral

O Data Processor Ã© um projeto avanÃ§ado que demonstra o uso de anotaÃ§Ãµes personalizadas para criar um sistema flexÃ­vel de processamento de dados.

## Objetivos

* Implementar um sistema de validaÃ§Ã£o baseado em anotaÃ§Ãµes

* Criar transformadores de dados customizÃ¡veis

* Desenvolver um pipeline de processamento configurÃ¡vel

* Suportar diferentes formatos e fontes de dados

## ImplementaÃ§Ã£o

### 1. AnotaÃ§Ãµes Base

```JAVA
// AnotaÃ§Ã£o principal para marcar classes processÃ¡veis
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface DataProcessor {
    String value() default "";
    String version() default "1.0";
    ProcessingMode mode() default ProcessingMode.SYNC;
    
    public enum ProcessingMode {
        SYNC, ASYNC, BATCH
    }
}

// AnotaÃ§Ã£o para validaÃ§Ã£o de campos
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Validate {
    String pattern() default "";
    boolean required() default true;
    int minLength() default 0;
    int maxLength() default Integer.MAX_VALUE;
    String message() default "";
}

// AnotaÃ§Ã£o para transformaÃ§Ã£o de dados
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Transform {
    Class<? extends DataTransformer<?>> transformer();
    String[] params() default {};
}

// AnotaÃ§Ã£o para persistÃªncia
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Persist {
    String strategy() default "DEFAULT";
    boolean async() default false;
}
```

### 2. Interfaces Base

```JAVA
// Interface para transformadores de dados
public interface DataTransformer<T> {
    T transform(T input, String... params);
}

// Interface para validadores
public interface DataValidator {
    boolean validate(Object value, Validate annotation);
    String getErrorMessage();
}

// Interface para persistÃªncia
public interface DataPersister {
    void persist(Object data, Persist annotation);
    Object retrieve(String id, Class<?> type);
}
```

### 3. ImplementaÃ§Ãµes Principais

```JAVA
// Processador principal
public class DataProcessorEngine {
    private final Map<Class<?>, DataValidator> validators;
    private final Map<Class<?>, DataTransformer<?>> transformers;
    private final Map<String, DataPersister> persisters;

    public <T> ProcessingResult<T> process(T data) {
        Class<?> dataClass = data.getClass();
        
        if (!dataClass.isAnnotationPresent(DataProcessor.class)) {
            throw new IllegalArgumentException("Class not annotated with @DataProcessor");
        }

        ProcessingResult<T> result = new ProcessingResult<>();
        
        // ValidaÃ§Ã£o
        validateFields(data, result);
        
        if (!result.isValid()) {
            return result;
        }

        // TransformaÃ§Ã£o
        T transformed = transformFields(data);
        
        // PersistÃªncia
        persistFields(transformed);

        result.setProcessedData(transformed);
        return result;
    }

    private <T> void validateFields(T data, ProcessingResult<T> result) {
        // ImplementaÃ§Ã£o da validaÃ§Ã£o
    }

    private <T> T transformFields(T data) {
        // ImplementaÃ§Ã£o da transformaÃ§Ã£o
    }

    private <T> void persistFields(T data) {
        // ImplementaÃ§Ã£o da persistÃªncia
    }
}
```

### 4. ImplementaÃ§Ãµes de Transformadores

```JAVA
// Transformador de criptografia
public class EncryptTransformer implements DataTransformer<String> {
    @Override
    public String transform(String input, String... params) {
        // ImplementaÃ§Ã£o da criptografia
        return encrypt(input, params[0]); // params[0] = chave de criptografia
    }

    private String encrypt(String data, String key) {
        // LÃ³gica de criptografia
        return /* dados criptografados */;
    }
}

// Transformador de formataÃ§Ã£o de data
public class DateFormatTransformer implements DataTransformer<Date> {
    @Override
    public Date transform(Date input, String... params) {
        String pattern = params[0]; // formato da data
        // ImplementaÃ§Ã£o da formataÃ§Ã£o
        return /* data formatada */;
    }
}
```

### 5. Exemplo de Uso

```JAVA
@DataProcessor(
    value = "userProcessor",
    version = "1.0",
    mode = ProcessingMode.ASYNC
)
public class UserData {
    @Validate(
        pattern = "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,6}$",
        message = "Email invÃ¡lido"
    )
    private String email;
    
    @Transform(transformer = EncryptTransformer.class)
    @Validate(required = true, minLength = 8)
    private String password;
    
    @Transform(
        transformer = DateFormatTransformer.class,
        params = "yyyy-MM-dd"
    )
    private Date birthDate;
    
    @Persist(strategy = "JDBC", async = true)
    private UserProfile profile;

    // Getters e Setters
}

// Uso do processador
public class UserService {
    private final DataProcessorEngine processor;

    public void registerUser(UserData userData) {
        ProcessingResult<UserData> result = processor.process(userData);
        
        if (result.isValid()) {
            // UsuÃ¡rio processado com sucesso
            UserData processedData = result.getProcessedData();
            // Continuar com o fluxo
        } else {
            // Tratar erros de validaÃ§Ã£o
            List<String> errors = result.getErrors();
            // Tratamento de erros
        }
    }
}
```

## Desafios de ImplementaÃ§Ã£o

### 1. ValidaÃ§Ã£o AssÃ­ncrona

Implementar suporte a validaÃ§Ãµes assÃ­ncronas para campos que requerem verificaÃ§Ãµes externas.

```JAVA
@Validate(async = true, validator = EmailExistsValidator.class)
private String email;
```

### 2. Pipeline CustomizÃ¡vel

Criar um sistema de pipeline onde a ordem de processamento pode ser configurada.

```JAVA
@DataProcessor(
    pipeline = {
        @Stage(type = VALIDATION, order = 1),
        @Stage(type = TRANSFORMATION, order = 2),
        @Stage(type = PERSISTENCE, order = 3)
    }
)
```

### 3. TransformaÃ§Ãµes Compostas

Permitir mÃºltiplas transformaÃ§Ãµes em sequÃªncia para um mesmo campo.

```JAVA
@Transform({
    @SingleTransform(transformer = TrimTransformer.class),
    @SingleTransform(transformer = LowerCaseTransformer.class),
    @SingleTransform(transformer = EncryptTransformer.class)
})
private String data;
```

## PrÃ³ximos Passos

1. OtimizaÃ§Ãµes

* Implementar cache de reflexÃ£o

* Adicionar pool de threads para processamento assÃ­ncrono

* Otimizar validaÃ§Ãµes em lote

2. ExtensÃµes

* Suporte a expressÃµes regulares complexas

* ValidaÃ§Ãµes customizadas via scripts

* Plugins para novos transformadores

3. Monitoramento

* MÃ©tricas de processamento

* Logging detalhado

* Rastreamento de transformaÃ§Ãµes

Tip:

Dica: Comece com um conjunto pequeno de validadores e transformadores, e expanda gradualmente conforme as necessidades do projeto.



# Calculadora Funcional

## VisÃ£o Geral

A Calculadora Funcional Ã© um projeto avanÃ§ado que demonstra os princÃ­pios da programaÃ§Ã£o funcional em Java, utilizando expressÃµes lambda, funÃ§Ãµes de ordem superior e composiÃ§Ã£o de funÃ§Ãµes.

## Objetivos

* Implementar operaÃ§Ãµes matemÃ¡ticas usando programaÃ§Ã£o funcional

* Demonstrar o uso de expressÃµes lambda e referÃªncias de mÃ©todo

* Criar um sistema de composiÃ§Ã£o de operaÃ§Ãµes

* Implementar histÃ³rico de operaÃ§Ãµes usando streams

## ImplementaÃ§Ã£o

### Estrutura Base

```JAVA
@FunctionalInterface
public interface Operation<T> {
    T apply(T a, T b);
}

public class FunctionalCalculator {
    private final List<String> history = new ArrayList<>();
    
    @Operation("ADD")
    public Function<Double, Double> add(Double a) {
        return b -> {
            double result = a + b;
            logOperation("ADD", a, b, result);
            return result;
        };
    }
    
    @Operation("MULTIPLY")
    public Function<Double, Double> multiply(Double a) {
        return b -> {
            double result = a * b;
            logOperation("MULTIPLY", a, b, result);
            return result;
        };
    }
    
    private void logOperation(String op, Double a, Double b, Double result) {
        history.add(String.format("%s: %f %s %f = %f", 
            op, a, op.toLowerCase(), b, result));
    }
    
    public List<String> getHistory() {
        return Collections.unmodifiableList(history);
    }
}
```

### ComposiÃ§Ã£o de OperaÃ§Ãµes

```JAVA
public class OperationComposer {
    @Operation("COMPOSE")
    public <T> Function<T, T> compose(
        @OperationParam Function<T, T>... functions
    ) {
        return Arrays.stream(functions)
                    .reduce(Function.identity(), Function::andThen);
    }
}
```

## Exemplos de Uso

### OperaÃ§Ãµes BÃ¡sicas

```JAVA
FunctionalCalculator calc = new FunctionalCalculator();

// OperaÃ§Ã£o simples
double result = calc.add(5.0).apply(3.0);  // 8.0

// ComposiÃ§Ã£o de operaÃ§Ãµes
Function<Double, Double> operation = calc.compose(
    calc.add(5.0),
    calc.multiply(2.0)
);
double composedResult = operation.apply(3.0);  // 16.0
```

### HistÃ³rico de OperaÃ§Ãµes

```JAVA
calc.getHistory().forEach(System.out::println);
// SaÃ­da:
// ADD: 5.000000 add 3.000000 = 8.000000
// MULTIPLY: 8.000000 multiply 2.000000 = 16.000000
```

## ExercÃ­cios Propostos

1. Implementar operaÃ§Ãµes adicionais:

* SubtraÃ§Ã£o

* DivisÃ£o

* PotenciaÃ§Ã£o

* Raiz quadrada

2. Adicionar validaÃ§Ãµes:

* DivisÃ£o por zero

* NÃºmeros negativos em raiz quadrada

* Overflow/Underflow

3. Implementar operaÃ§Ãµes com diferentes tipos:

* Inteiros

* NÃºmeros complexos

* Vetores

## Desafios AvanÃ§ados

### 1. Sistema de Plugins

Criar um sistema que permite adicionar novas operaÃ§Ãµes dinamicamente:

```JAVA
public interface OperationPlugin {
    String getName();
    Function<Double, Double> getOperation(Double input);
}
```

### 2. ExpressÃµes MatemÃ¡ticas

Implementar um parser de expressÃµes matemÃ¡ticas:

```JAVA
public class ExpressionParser {
    public Function<Double, Double> parse(String expression) {
        // ImplementaÃ§Ã£o do parser
    }
}
```

### 3. OperaÃ§Ãµes AssÃ­ncronas

Adicionar suporte para cÃ¡lculos assÃ­ncronos:

```JAVA
public class AsyncCalculator {
    public CompletableFuture<Double> calculateAsync(
        Function<Double, Double> operation,
        Double input
    ) {
        return CompletableFuture.supplyAsync(
            () -> operation.apply(input)
        );
    }
}
```

## Boas PrÃ¡ticas

1. Imutabilidade

* Use tipos imutÃ¡veis

* Evite estado mutÃ¡vel

* Retorne novas instÃ¢ncias

2. ComposiÃ§Ã£o

* Prefira composiÃ§Ã£o sobre heranÃ§a

* Use funÃ§Ãµes pequenas e focadas

* Combine funÃ§Ãµes para operaÃ§Ãµes complexas

3. Tratamento de Erros

* Use Optional para resultados opcionais

* Implemente tratamento de exceÃ§Ãµes funcional

* Mantenha a transparÃªncia referencial

## Recursos Adicionais

* [DocumentaÃ§Ã£o Java Stream API](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)

* [Tutorial sobre ProgramaÃ§Ã£o Funcional](null)

* [PadrÃµes Funcionais](null)

## PrÃ³ximos Passos

ApÃ³s completar este projeto, vocÃª estarÃ¡ preparado para:

* Desenvolver sistemas mais complexos usando programaÃ§Ã£o funcional

* Implementar operaÃ§Ãµes assÃ­ncronas e paralelas

* Criar DSLs (Domain Specific Languages) funcionais



# Framework de InjeÃ§Ã£o de DependÃªncias Customizado

## VisÃ£o Geral

Neste projeto, vamos desenvolver um mini-framework de injeÃ§Ã£o de dependÃªncias usando reflexÃ£o e anotaÃ§Ãµes em Java. O framework oferecerÃ¡ funcionalidades bÃ¡sicas de DI (Dependency Injection) e gerenciamento de ciclo de vida de componentes.

## Principais CaracterÃ­sticas

* InjeÃ§Ã£o automÃ¡tica de dependÃªncias

* Gerenciamento de escopo (singleton/prototype)

* ConfiguraÃ§Ã£o via anotaÃ§Ãµes

* InicializaÃ§Ã£o e destruiÃ§Ã£o de componentes

* Suporte a plugins

## AnotaÃ§Ãµes do Framework

### @Component

```JAVA
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Component {
    String value() default "";
    String scope() default "singleton";
}
```

### @Inject

```JAVA
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.CONSTRUCTOR})
public @interface Inject {
}
```

### @Initialize

```JAVA
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Initialize {
    int order() default 0;
}
```

## Container de DependÃªncias

### ImplementaÃ§Ã£o BÃ¡sica

```JAVA
public class DIContainer {
    private Map<Class<?>, Object> singletons = new HashMap<>();
    private Map<Class<?>, Class<?>> bindings = new HashMap<>();

    public <T> void bind(Class<T> interfaceClass, Class<? extends T> implementationClass) {
        bindings.put(interfaceClass, implementationClass);
    }

    public <T> T getInstance(Class<T> type) {
        // Verifica se Ã© singleton
        if (singletons.containsKey(type)) {
            return (T) singletons.get(type);
        }

        // Cria nova instÃ¢ncia
        return createInstance(type);
    }

    private <T> T createInstance(Class<T> type) {
        try {
            Constructor<?> constructor = type.getDeclaredConstructor();
            T instance = (T) constructor.newInstance();
            injectDependencies(instance);
            return instance;
        } catch (Exception e) {
            throw new RuntimeException("Erro ao criar instÃ¢ncia", e);
        }
    }

    private void injectDependencies(Object instance) {
        Class<?> type = instance.getClass();
        for (Field field : type.getDeclaredFields()) {
            if (field.isAnnotationPresent(Inject.class)) {
                field.setAccessible(true);
                Object dependency = getInstance(field.getType());
                try {
                    field.set(instance, dependency);
                } catch (Exception e) {
                    throw new RuntimeException("Erro ao injetar dependÃªncia", e);
                }
            }
        }
    }
}
```

## Exemplo de Uso

### DefiniÃ§Ã£o de Componentes

```JAVA
@Component
public class UserService {
    @Inject
    private UserRepository userRepository;
    
    @Initialize
    public void setup() {
        System.out.println("Inicializando UserService");
    }
    
    public User findUser(Long id) {
        return userRepository.findById(id);
    }
}

@Component(scope = "prototype")
public class UserRepository {
    private DatabaseConnection connection;
    
    @Inject
    public UserRepository(DatabaseConnection connection) {
        this.connection = connection;
    }
    
    public User findById(Long id) {
        // ImplementaÃ§Ã£o
        return null;
    }
}
```

### ConfiguraÃ§Ã£o e Uso

```JAVA
public class Application {
    public static void main(String[] args) {
        DIContainer container = new DIContainer();
        
        // ConfiguraÃ§Ã£o
        container.bind(UserRepository.class, UserRepositoryImpl.class);
        
        // Uso
        UserService userService = container.getInstance(UserService.class);
        User user = userService.findUser(1L);
    }
}
```

## Recursos AvanÃ§ados

### Plugin System

```JAVA
@Plugin
public interface UserPlugin {
    void onUserCreated(User user);
}

public class PluginManager {
    private List<UserPlugin> plugins = new ArrayList<>();
    
    public void registerPlugin(UserPlugin plugin) {
        plugins.add(plugin);
    }
    
    public void notifyUserCreated(User user) {
        plugins.forEach(plugin -> plugin.onUserCreated(user));
    }
}
```

### Aspect-Like Features

```JAVA
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Transactional {
}

public class TransactionInterceptor {
    public Object intercept(Method method, Object[] args) {
        beginTransaction();
        try {
            Object result = method.invoke(args);
            commitTransaction();
            return result;
        } catch (Exception e) {
            rollbackTransaction();
            throw e;
        }
    }
}
```

## ConsideraÃ§Ãµes de Design

### PadrÃµes Utilizados

* Singleton para gerenciamento de instÃ¢ncias

* Factory Method para criaÃ§Ã£o de objetos

* Observer para sistema de plugins

* Proxy para interceptaÃ§Ã£o de mÃ©todos

### Boas PrÃ¡ticas

* Lazy loading de dependÃªncias

* Cache de reflexÃ£o para performance

* DetecÃ§Ã£o de ciclos de dependÃªncia

* Logging e tratamento de erros

## PrÃ³ximos Passos

1. Implementar suporte a profiles

2. Adicionar injeÃ§Ã£o por construtor

3. Desenvolver sistema de eventos

4. Criar mecanismo de configuraÃ§Ã£o externa

5. Implementar lazy injection



# Annotation Processor

## VisÃ£o Geral

O Annotation Processor Ã© um mecanismo poderoso do Java que permite processar anotaÃ§Ãµes em tempo de compilaÃ§Ã£o para gerar cÃ³digo, validar restriÃ§Ãµes e realizar outras tarefas de metaprogramaÃ§Ã£o.

## Fundamentos

### O que Ã© um Annotation Processor?

Um processador de anotaÃ§Ãµes Ã© uma ferramenta que analisa e processa anotaÃ§Ãµes Java durante a compilaÃ§Ã£o. Ele pode:

* Gerar novos arquivos fonte

* Validar uso de anotaÃ§Ãµes

* Produzir mensagens de erro/aviso

* Modificar o processo de compilaÃ§Ã£o

### Estrutura BÃ¡sica

```JAVA
@SupportedAnnotationTypes("com.example.annotations.*")
@SupportedSourceVersion(SourceVersion.RELEASE_17)
public class CustomProcessor extends AbstractProcessor {
    @Override
    public boolean process(
        Set<? extends TypeElement> annotations,
        RoundEnvironment roundEnv
    ) {
        // LÃ³gica de processamento
        return true;
    }
}
```

## ImplementaÃ§Ã£o

### ConfiguraÃ§Ã£o do Projeto

1. Criar arquivo de serviÃ§o:
`META-INF/services/javax.annotation.processing.Processor`

2. Adicionar dependÃªncias necessÃ¡rias

3. Configurar plugin de compilaÃ§Ã£o

### Processamento de Elementos

```JAVA
@Override
public boolean process(
    Set<? extends TypeElement> annotations,
    RoundEnvironment roundEnv
) {
    for (TypeElement annotation : annotations) {
        Set<? extends Element> elements = 
            roundEnv.getElementsAnnotatedWith(annotation);
        
        for (Element element : elements) {
            // Processamento especÃ­fico
            processElement(element);
        }
    }
    return true;
}
```

### GeraÃ§Ã£o de CÃ³digo

```JAVA
private void generateCode(Element element) {
    JavaFileObject file = processingEnv.getFiler()
        .createSourceFile("GeneratedClass");
    
    try (PrintWriter out = new PrintWriter(file.openWriter())) {
        out.println("package com.example.generated;");
        out.println("public class GeneratedClass {");
        // GeraÃ§Ã£o do cÃ³digo
        out.println("}");
    }
}
```

## Casos de Uso

### Builder Generator

```JAVA
@Builder
public class User {
    private String name;
    private String email;
    private int age;
}

// Gera:
public class UserBuilder {
    private User user = new User();
    
    public UserBuilder name(String name) {
        user.setName(name);
        return this;
    }
    // ... outros mÃ©todos
}
```

### DTO Mapper

```JAVA
@Mapper
public class UserEntity {
    private Long id;
    private String username;
    
    // Gera automaticamente:
    // - UserDTO
    // - UserMapper
}
```

### Validador de AnotaÃ§Ãµes

```JAVA
@ValidateAnnotation
public @interface Route {
    String path();
    String method();
}

// Valida em tempo de compilaÃ§Ã£o:
// - Formato do path
// - MÃ©todo HTTP vÃ¡lido
```

## Boas PrÃ¡ticas

### Desempenho

* Cache de elementos processados

* Minimizar operaÃ§Ãµes I/O

* Processamento incremental

### Mensagens de Erro

```JAVA
private void reportError(Element element, String message) {
    processingEnv.getMessager().printMessage(
        Diagnostic.Kind.ERROR,
        message,
        element
    );
}
```

### Testes

```JAVA
@Test
public void testProcessor() {
    Compilation compilation = 
        javac()
            .withProcessors(new CustomProcessor())
            .compile(JavaFileObjects.forSourceString(
                "Test",
                "..."
            ));
    
    assertThat(compilation).succeeded();
    // Verificar saÃ­da gerada
}
```

## Ferramentas e Bibliotecas

### UtilitÃ¡rias

* JavaPoet: GeraÃ§Ã£o de cÃ³digo

* Auto Service: Registro de processadores

* Compile Testing: Testes de compilaÃ§Ã£o

### IntegraÃ§Ã£o IDE

* Suporte a processamento incremental

* Debugging de processadores

* VisualizaÃ§Ã£o de cÃ³digo gerado

## Exemplos AvanÃ§ados

### Gerador de API REST

```JAVA
@RestController
@RequestMapping("/api")
public class UserController {
    // Gera:
    // - Documentation
    // - Client SDK
    // - Test Cases
}
```

### Gerador de DocumentaÃ§Ã£o

```JAVA
@ApiDoc(
    description = "Gerencia usuÃ¡rios",
    version = "1.0"
)
public class UserService {
    // Gera:
    // - Markdown
    // - HTML
    // - OpenAPI spec
}
```

## Recursos Adicionais

### Links Ãšteis

* [DocumentaÃ§Ã£o Oracle](https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html)

* [JavaPoet GitHub](https://github.com/square/javapoet)

* [Annotation Processing Tool](https://docs.oracle.com/javase/8/docs/technotes/tools/windows/apt.html)

### Projetos de Exemplo

* [Lombok](https://github.com/projectlombok/lombok)

* [Dagger](https://github.com/google/dagger)

* [MapStruct](https://github.com/mapstruct/mapstruct)



# Generic Container

![Generic Container](generic-container-banner.png)

## VisÃ£o Geral

Um container genÃ©rico Ã© uma estrutura de dados flexÃ­vel que pode armazenar e gerenciar diferentes tipos de objetos de forma type-safe.

## Estrutura Base

### Container GenÃ©rico BÃ¡sico

```JAVA
public class Container<T> {
    private final List<T> elements;
    private final Map<String, T> namedElements;
    
    public Container() {
        this.elements = new ArrayList<>();
        this.namedElements = new HashMap<>();
    }
    
    public void add(T element) {
        elements.add(element);
    }
    
    public void addNamed(String name, T element) {
        namedElements.put(name, element);
    }
    
    public Optional<T> get(int index) {
        return index >= 0 && index < elements.size() 
            ? Optional.of(elements.get(index))
            : Optional.empty();
    }
    
    public Optional<T> getNamed(String name) {
        return Optional.ofNullable(namedElements.get(name));
    }
}
```

## Funcionalidades AvanÃ§adas

### Container com ValidaÃ§Ã£o

```JAVA
public class ValidatedContainer<T> extends Container<T> {
    private final Predicate<T> validator;
    
    public ValidatedContainer(Predicate<T> validator) {
        super();
        this.validator = validator;
    }
    
    @Override
    public void add(T element) {
        if (validator.test(element)) {
            super.add(element);
        } else {
            throw new IllegalArgumentException("Elemento invÃ¡lido");
        }
    }
}
```

### Container com TransformaÃ§Ã£o

```JAVA
public class TransformingContainer<T, R> {
    private final Container<T> source;
    private final Function<T, R> transformer;
    
    public TransformingContainer(Container<T> source, Function<T, R> transformer) {
        this.source = source;
        this.transformer = transformer;
    }
    
    public Optional<R> getTransformed(int index) {
        return source.get(index).map(transformer);
    }
}
```

## Casos de Uso

### Gerenciamento de Dados

```JAVA
Container<User> userContainer = new Container<>();
userContainer.add(new User("Alice"));
userContainer.addNamed("admin", new User("Admin"));

ValidatedContainer<Email> emailContainer = 
    new ValidatedContainer<>(Email::isValid);
emailContainer.add(new Email("user@example.com"));
```

### Processamento de Dados

```JAVA
Container<String> stringContainer = new Container<>();
stringContainer.add("123");
stringContainer.add("456");

TransformingContainer<String, Integer> numberContainer =
    new TransformingContainer<>(stringContainer, Integer::parseInt);

Optional<Integer> number = numberContainer.getTransformed(0); // 123
```

## Boas PrÃ¡ticas

1. Type Safety

* Use bounds quando necessÃ¡rio

* Evite type erasure quando possÃ­vel

* Valide tipos em runtime quando apropriado

2. Performance

* Implemente lazy loading

* Use estruturas de dados apropriadas

* Considere cache para operaÃ§Ãµes custosas

3. Thread Safety

```JAVA
public class ThreadSafeContainer<T> {
    private final Container<T> container;
    private final Lock lock;
    
    public ThreadSafeContainer() {
        this.container = new Container<>();
        this.lock = new ReentrantLock();
    }
    
    public void add(T element) {
        lock.lock();
        try {
            container.add(element);
        } finally {
            lock.unlock();
        }
    }
}
```

## ExercÃ­cios Propostos

1. Implemente um container com suporte a eventos (Observer pattern)

2. Crie um container com polÃ­tica de expiraÃ§Ã£o de elementos

3. Desenvolva um container com suporte a operaÃ§Ãµes em batch

4. Adicione funcionalidade de serializaÃ§Ã£o/deserializaÃ§Ã£o

## PrÃ³ximos Passos

* Explorar integraÃ§Ã£o com Streams API

* Implementar padrÃµes de design adicionais

* Adicionar suporte a persistÃªncia

* Desenvolver visualizaÃ§Ãµes de dados

[Annotation Processor](annotation-processor.html)



# Reflection Explorer

## VisÃ£o Geral do Projeto

O Reflection Explorer Ã© uma ferramenta avanÃ§ada para anÃ¡lise e manipulaÃ§Ã£o de classes Java em runtime, permitindo:

* InspeÃ§Ã£o detalhada de classes

* ModificaÃ§Ã£o dinÃ¢mica de objetos

* GeraÃ§Ã£o de proxies

* AnÃ¡lise de dependÃªncias

* VisualizaÃ§Ã£o de hierarquias

## Arquitetura

```MERMAID
classDiagram
    class ReflectionExplorer {
        -ClassAnalyzer analyzer
        -ObjectModifier modifier
        -ProxyGenerator proxyGen
        +analyze(Class) ClassInfo
        +modify(Object, Enhancement) Object
        +createProxy(Class, Handler) Object
    }
    
    class ClassAnalyzer {
        -methodCache: Map
        -fieldCache: Map
        +getMethods(Class) Method[]
        +getFields(Class) Field[]
        +getAnnotations(Class) Annotation[]
    }
    
    class ObjectModifier {
        +enhance(Object) Object
        +inject(Object, Object) void
        +intercept(Object, Method) Object
    }
    
    class ProxyGenerator {
        +createProxy(Class) Object
        +addHandler(Object, Handler) void
    }
    
    ReflectionExplorer --> ClassAnalyzer
    ReflectionExplorer --> ObjectModifier
    ReflectionExplorer --> ProxyGenerator
```

## ImplementaÃ§Ã£o Core

### Analisador de Classes

```JAVA
public class ClassAnalyzer {
    private final Map<Class<?>, Method[]> methodCache = new ConcurrentHashMap<>();
    private final Map<Class<?>, Field[]> fieldCache = new ConcurrentHashMap<>();
    
    @Inspect
    public ClassInfo analyze(Class<?> target) {
        return ClassInfo.builder()
            .name(target.getName())
            .methods(getMethods(target))
            .fields(getFields(target))
            .annotations(getAnnotations(target))
            .superclass(target.getSuperclass())
            .interfaces(target.getInterfaces())
            .modifiers(target.getModifiers())
            .build();
    }
    
    private Method[] getMethods(Class<?> clazz) {
        return methodCache.computeIfAbsent(clazz, Class::getDeclaredMethods);
    }
    
    private Field[] getFields(Class<?> clazz) {
        return fieldCache.computeIfAbsent(clazz, Class::getDeclaredFields);
    }
}
```

### Modificador de Objetos

```JAVA
public class ObjectModifier {
    @Modify
    public Object enhance(
        @Target Object instance,
        @Enhancement Enhancement enhancement
    ) {
        Class<?> clazz = instance.getClass();
        
        // Aplicar modificaÃ§Ãµes
        for (Field field : clazz.getDeclaredFields()) {
            if (enhancement.shouldModify(field)) {
                field.setAccessible(true);
                field.set(instance, enhancement.getNewValue(field));
            }
        }
        
        return instance;
    }
    
    @Intercept
    public Object interceptMethod(
        Object instance,
        Method method,
        Object[] args,
        MethodHandler handler
    ) throws Exception {
        // PrÃ©-processamento
        handler.beforeInvocation(method, args);
        
        // InvocaÃ§Ã£o do mÃ©todo
        Object result = method.invoke(instance, args);
        
        // PÃ³s-processamento
        return handler.afterInvocation(method, result);
    }
}
```

### Gerador de Proxy

```JAVA
public class ProxyGenerator {
    public <T> T createProxy(
        Class<T> interfaceType,
        InvocationHandler handler
    ) {
        return (T) Proxy.newProxyInstance(
            interfaceType.getClassLoader(),
            new Class<?>[] { interfaceType },
            handler
        );
    }
    
    public class LoggingHandler implements InvocationHandler {
        private final Object target;
        
        public LoggingHandler(Object target) {
            this.target = target;
        }
        
        @Override
        public Object invoke(
            Object proxy,
            Method method,
            Object[] args
        ) throws Throwable {
            System.out.println("Before: " + method.getName());
            Object result = method.invoke(target, args);
            System.out.println("After: " + method.getName());
            return result;
        }
    }
}
```

## Recursos AvanÃ§ados

### Visualizador de Hierarquia

```JAVA
public class HierarchyVisualizer {
    public String generateDotGraph(Class<?> rootClass) {
        StringBuilder dot = new StringBuilder();
        dot.append("digraph Hierarchy {\n");
        
        // Adiciona nÃ³s
        addClassNode(dot, rootClass);
        
        // Adiciona relacionamentos
        addRelationships(dot, rootClass);
        
        dot.append("}");
        return dot.toString();
    }
    
    private void addClassNode(StringBuilder dot, Class<?> clazz) {
        dot.append(String.format(
            "  %s [label=\"%s\"];\n",
            clazz.getSimpleName(),
            clazz.getName()
        ));
    }
}
```

### Cache Inteligente

```JAVA
public class ReflectionCache {
    private static final Map<Class<?>, ClassInfo> CLASS_INFO_CACHE = 
        new ConcurrentHashMap<>();
    
    public static ClassInfo getClassInfo(Class<?> clazz) {
        return CLASS_INFO_CACHE.computeIfAbsent(
            clazz,
            ReflectionCache::analyzeClass
        );
    }
    
    private static ClassInfo analyzeClass(Class<?> clazz) {
        // AnÃ¡lise detalhada da classe
        return new ClassAnalyzer().analyze(clazz);
    }
}
```

## Exemplos de Uso

### AnÃ¡lise de DependÃªncias

```JAVA
public class DependencyAnalyzer {
    public Set<Class<?>> findDependencies(Class<?> targetClass) {
        Set<Class<?>> dependencies = new HashSet<>();
        
        // Analisa campos
        for (Field field : targetClass.getDeclaredFields()) {
            dependencies.add(field.getType());
        }
        
        // Analisa mÃ©todos
        for (Method method : targetClass.getDeclaredMethods()) {
            dependencies.addAll(Arrays.asList(method.getParameterTypes()));
            dependencies.add(method.getReturnType());
        }
        
        return dependencies;
    }
}
```

### InjeÃ§Ã£o DinÃ¢mica

```JAVA
public class DependencyInjector {
    public void inject(Object instance) {
        Class<?> clazz = instance.getClass();
        
        for (Field field : clazz.getDeclaredFields()) {
            if (field.isAnnotationPresent(Inject.class)) {
                field.setAccessible(true);
                field.set(instance, createDependency(field.getType()));
            }
        }
    }
}
```

## Testes

### Testes UnitÃ¡rios

```JAVA
@Test
public void testClassAnalysis() {
    ClassAnalyzer analyzer = new ClassAnalyzer();
    ClassInfo info = analyzer.analyze(TestClass.class);
    
    assertNotNull(info);
    assertEquals("TestClass", info.getName());
    assertTrue(info.getMethods().length > 0);
}

@Test
public void testObjectModification() {
    ObjectModifier modifier = new ObjectModifier();
    TestClass instance = new TestClass();
    
    Enhancement enhancement = new Enhancement("value", "newValue");
    Object modified = modifier.enhance(instance, enhancement);
    
    assertEquals("newValue", ((TestClass)modified).getValue());
}
```

## ConsideraÃ§Ãµes de Performance

1. Caching

* Cache de reflection metadata

* ReutilizaÃ§Ã£o de instÃ¢ncias

* Lazy loading de informaÃ§Ãµes

2. OtimizaÃ§Ãµes

* Batch processing

* Minimizar reflection em loops

* Usar streams para processamento paralelo

3. MemÃ³ria

* Limpeza periÃ³dica de cache

* Weak references para objetos

* Pooling de instÃ¢ncias comuns

## PrÃ³ximos Passos

1. Implementar visualizaÃ§Ã£o grÃ¡fica

2. Adicionar suporte a bytecode manipulation

3. Criar sistema de plugins

4. Integrar com IDEs populares

## Recursos Adicionais

* [Java Reflection API Documentation](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html)

* [ASM Library](https://asm.ow2.io/)

* [ByteBuddy](https://bytebuddy.net/)

[Annotation Processor](annotation-processor.html)



# Recursos de Aprendizado Java

## VisÃ£o Geral

Este guia compila os melhores recursos para aprofundar seu conhecimento em Java.

## Categorias Principais

```
RECURSOS JAVA
â”œâ”€â”€ DocumentaÃ§Ã£o Oficial
â”œâ”€â”€ Livros Recomendados
â”œâ”€â”€ Cursos Online
â”œâ”€â”€ Comunidade
â”œâ”€â”€ Ferramentas
â”œâ”€â”€ Cheat Sheets
â””â”€â”€ GlossÃ¡rio
```

## Como Usar Este Guia

1. Comece pela documentaÃ§Ã£o oficial para fundamentos sÃ³lidos

2. Escolha livros ou cursos baseados em seu nÃ­vel

3. Participe da comunidade para networking

4. Utilize ferramentas para aumentar produtividade

5. Consulte cheat sheets para referÃªncia rÃ¡pida

6. Use o glossÃ¡rio para termos tÃ©cnicos

## Mantenha-se Atualizado

* Siga blogs tÃ©cnicos

* Participe de conferÃªncias

* Acompanhe releases do Java

* Pratique regularmente



# DocumentaÃ§Ã£o Oficial

## Oracle Java SE Documentation

* [Java SE Documentation](https://docs.oracle.com/en/java/javase/index.html)

* [Java Language Specification](https://docs.oracle.com/javase/specs/jls/se17/html/index.html)

* [Java Virtual Machine Specification](https://docs.oracle.com/javase/specs/jvms/se17/html/index.html)

* [JavaDoc API Documentation](https://docs.oracle.com/en/java/javase/17/docs/api/index.html)

## Tutoriais Oracle

* The Java Tutorials

* Java EE Documentation

* Security Documentation

* JVM Tuning Guide

## OpenJDK Documentation

* Project Documentation

* Enhancement Proposals

* Release Notes

* Migration Guides

## EspecificaÃ§Ãµes

* Java Language

* Java Memory Model

* Java Native Interface

* Java Debug Interface



# Livros Recomendados

## Iniciante

1. Head First Java

* Autores: Kathy Sierra & Bert Bates

* Foco: Fundamentos de forma didÃ¡tica

2. Core Java Volume I

* Autor: Cay S. Horstmann

* Foco: Fundamentos aprofundados

## IntermediÃ¡rio

1. Effective Java

* Autor: Joshua Bloch

* Foco: Boas prÃ¡ticas e padrÃµes

2. Clean Code

* Autor: Robert C. Martin

* Foco: Qualidade de cÃ³digo

## AvanÃ§ado

1. Java Concurrency in Practice

* Autor: Brian Goetz

* Foco: ProgramaÃ§Ã£o concorrente

2. Java Performance

* Autor: Scott Oaks

* Foco: OtimizaÃ§Ã£o e performance

## Especializado

1. Spring in Action

* Autor: Craig Walls

* Foco: Framework Spring

2. Microservices Patterns

* Autor: Chris Richardson

* Foco: Arquitetura moderna



# Cursos Online

## Plataformas Gratuitas

1. Coursera

* Java Programming Specialization

* Object Oriented Java Programming

* Android App Development

2. edX

* Introduction to Java Programming

* Object-Oriented Programming

* Data Structures and Algorithms

## Plataformas Pagas

1. Udemy

* Complete Java Masterclass

* Java Spring Boot

* Microservices with Spring Boot

2. PluralSight

* Java Fundamentals

* Spring Framework Path

* Enterprise Architecture

## Bootcamps

1. Coding Dojo

* Java Stack

* Spring Boot

* Full Stack Development

2. General Assembly

* Java Development

* Enterprise Solutions

* Web Development

## Recursos Interativos

1. CodeCademy

* Learn Java

* Build Basic Java Apps

* Practice Exercises

2. HackerRank

* Java Practice

* Problem Solving

* Interview Preparation



# Comunidade Java

## FÃ³runs e Q&A

1. Stack Overflow

* Tags: java, spring, hibernate

* Como participar efetivamente

* Guidelines para perguntas

2. Reddit

* r/java

* r/learnjava

* r/javahelp

## Grupos e Meetups

1. Meetup.com

* Java User Groups (JUGs)

* Coding Dojos

* Tech Talks

2. Discord

* Java Community

* Spring Developers

* Android Dev

## ConferÃªncias

1. Principais Eventos

* JavaOne

* Devoxx

* JFokus

* QCon

2. Eventos Brasileiros

* TDC

* QCon SP

* DevOpsDays

## ContribuiÃ§Ã£o

1. Open Source

* Como comeÃ§ar

* Projetos para iniciantes

* Boas prÃ¡ticas

2. Mentoria

* Programas disponÃ­veis

* Como encontrar mentor

* Como ser mentor



# Ferramentas Java

## IDEs

1. IntelliJ IDEA

* Community Edition

* Ultimate Edition

* Plugins essenciais

2. Eclipse

* InstalaÃ§Ã£o

* ConfiguraÃ§Ã£o

* ExtensÃµes populares

3. VS Code

* ExtensÃµes Java

* ConfiguraÃ§Ã£o

* Debugging

## Build Tools

1. Maven

* ConfiguraÃ§Ã£o bÃ¡sica

* Gerenciamento de dependÃªncias

* Plugins Ãºteis

2. Gradle

* Setup inicial

* Scripts bÃ¡sicos

* Tarefas customizadas

## Testing Tools

1. JUnit

* JUnit 5

* Assertions

* Test Lifecycle

2. Mockito

* Mocks

* Stubs

* VerificaÃ§Ãµes

## Profiling

1. JProfiler

* AnÃ¡lise de memÃ³ria

* CPU profiling

* Threads

2. VisualVM

* Monitoramento

* Heap dump

* Thread dump



# Cheat Sheets

## Sintaxe BÃ¡sica

```JAVA
// DeclaraÃ§Ãµes
int numero = 10;
String texto = "Hello";
final double PI = 3.14;

// Controle de fluxo
if (condicao) {
    // cÃ³digo
} else {
    // cÃ³digo
}

for (int i = 0; i < 10; i++) {
    // cÃ³digo
}
```

## Collections Framework

```JAVA
// List
List<String> lista = new ArrayList<>();
lista.add("item");

// Map
Map<String, Integer> mapa = new HashMap<>();
mapa.put("chave", 1);

// Set
Set<Integer> conjunto = new HashSet<>();
conjunto.add(1);
```

## Lambda Expressions

```JAVA
// BÃ¡sico
Runnable r = () -> System.out.println("Hello");

// Com parÃ¢metros
Consumer<String> c = (s) -> System.out.println(s);

// Com mÃºltiplas linhas
Comparator<String> comp = (s1, s2) -> {
    if (s1 == null) return -1;
    if (s2 == null) return 1;
    return s1.compareTo(s2);
};
```

## Stream API

```JAVA
// OperaÃ§Ãµes comuns
list.stream()
    .filter(x -> x > 0)
    .map(x -> x * 2)
    .collect(Collectors.toList());

// ReduÃ§Ã£o
int sum = numbers.stream()
    .reduce(0, Integer::sum);
```

## Optional

```JAVA
// CriaÃ§Ã£o
Optional<String> opt = Optional.of("value");
Optional<String> empty = Optional.empty();

// Uso
String value = opt.orElse("default");
opt.ifPresent(System.out::println);
```

## Files e I/O

```JAVA
// Leitura
List<String> lines = Files.readAllLines(Path.of("file.txt"));

// Escrita
Files.write(Path.of("output.txt"), content.getBytes());

// Try-with-resources
try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"))) {
    // cÃ³digo
}
```



# GlossÃ¡rio Java

## A

* Abstract Class: Classe que nÃ£o pode ser instanciada e pode conter mÃ©todos abstratos

* Annotation: Metadados que podem ser adicionados ao cÃ³digo Java

* API: Application Programming Interface

## B

* Bytecode: CÃ³digo intermediÃ¡rio gerado pela compilaÃ§Ã£o Java

* Bean: Objeto Java que segue convenÃ§Ãµes especÃ­ficas

## C

* Class: Modelo para criar objetos

* Classpath: Caminho onde o Java procura por classes

* Collection: Interface para grupo de objetos

## D

* DAO: Data Access Object

* Dependency Injection: PadrÃ£o de design para inversÃ£o de controle

* DTOs: Data Transfer Objects

## E

* Encapsulation: PrincÃ­pio de OOP para esconder implementaÃ§Ãµes

* Exception: Evento que ocorre durante a execuÃ§Ã£o

## F

* Framework: Estrutura de suporte predefinida

* Final: Modificador para constantes e mÃ©todos nÃ£o sobrescritÃ­veis

## G

* Garbage Collection: Gerenciamento automÃ¡tico de memÃ³ria

* Generic: Tipo parametrizado

## H

* Heap: Ãrea de memÃ³ria para objetos

* HTTP: Hypertext Transfer Protocol

## I

* Interface: Contrato para implementaÃ§Ã£o de mÃ©todos

* Iterator: PadrÃ£o para percorrer coleÃ§Ãµes

## J

* JAR: Java Archive

* JVM: Java Virtual Machine

* JRE: Java Runtime Environment

* JDK: Java Development Kit

## L

* Lambda: FunÃ§Ã£o anÃ´nima

* LINQ: Language Integrated Query

## M

* Maven: Ferramenta de build

* Middleware: Software intermediÃ¡rio

* MVC: Model-View-Controller

## O

* OOP: Object-Oriented Programming

* ORM: Object-Relational Mapping

## P

* Package: Namespace para organizar classes

* POJO: Plain Old Java Object

## R

* Reflection: API para examinar/modificar cÃ³digo em runtime

* REST: Representational State Transfer

## S

* Serialization: ConversÃ£o de objeto em bytes

* Spring: Framework Java popular

* Stream: SequÃªncia de elementos

## T

* Thread: Unidade de execuÃ§Ã£o

* Transaction: Unidade atÃ´mica de trabalho

## V

* Varargs: NÃºmero variÃ¡vel de argumentos

* Virtual Method: MÃ©todo que pode ser sobrescrito




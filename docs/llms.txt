# NetRunner: Java Mastery Guide

## Inicializando Sistema...

```
 _   _      _   ____                            
| \ | | ___| |_|  _ \ _   _ _ __  _ __   ___ _ __ 
|  \| |/ _ \ __| |_) | | | | '_ \| '_ \ / _ \ '__|
| |\  |  __/ |_|  _ <| |_| | | | | | | |  __/ |   
|_| \_|\___|\__|_| \_\\__,_|_| |_|_| |_|\___|_|   
                                                  
>> Java Mastery Guide v1.0
>> Inicializando interface neural...
>> Estabelecendo conexão com a Matrix...
>> Sistema pronto para upload de conhecimento...
```

## Sobre este Guia

Bem-vindo, runner. Você acaba de acessar a interface neural mais avançada para dominar a linguagem Java. Este não é apenas mais um tutorial - é sua porta de entrada para o submundo do desenvolvimento de software.

### O que você vai encontrar aqui

* 🔧 Fundamentos Sólidos: Do básico ao avançado, construa uma base inquebrável

* 🌐 Projetos Práticos: Aplique seus conhecimentos em missões do mundo real

* 🚀 Tecnologias Modernas: Frameworks, cloud, segurança e muito mais

* 💡 Padrões e Boas Práticas: Aprenda a construir código resiliente e escalável

## Pré-requisitos

* Computador com acesso à internet

* Vontade de aprender e experimentar

* Disposição para desafios práticos

* Mente aberta para novos conceitos

## Como Usar este Guia

1. Siga a Sequência: Os módulos foram organizados em ordem progressiva de complexidade

2. Pratique: Complete as missões práticas em cada seção

3. Experimente: Modifique os exemplos e crie suas próprias variações

4. Conecte-se: Participe da comunidade e compartilhe seu progresso

## Roadmap de Aprendizado

```MERMAID
graph TD
    A[Inicialização] --> B[Protocolos Básicos]
    B --> C[Matriz de Controle]
    C --> D[Interface Neural/OOP]
    D --> E[Sistemas Avançados]
    E --> F[Especialização]
```

## Quick Start

```JAVA
public class NetRunner {
    public static void main(String[] args) {
        System.out.println("Iniciando jornada no NetRunner...");
        System.out.println("Preparando ambiente de desenvolvimento...");
        System.out.println("Sistema pronto para começar!");
    }
}
```

## Próximos Passos

1. Comece pela seção [Sobre o Projeto](about.html)

2. Configure seu [Ambiente de Desenvolvimento](development-environment.html)

3. Inicie sua jornada com [Java Básico](java-basics.html)

## Status do Projeto

* Versão: 1.0

* Status: Ativo

* Java: 17+

Tip:

"O código é apenas o começo. O verdadeiro poder está em como você o utiliza." - NetRunner's Manifesto

[Começar Agora](getting-started.html)



# Iniciando no NetRunner

```
>> Inicializando sequência de boot...
>> Carregando módulos básicos...
>> Preparando ambiente de desenvolvimento...
>> Sistema pronto para upload inicial...
```

## Pré-requisitos do Sistema

### Hardware Recomendado

* Processador: Dual Core ou superior

* Memória RAM: 8GB mínimo (16GB recomendado)

* Armazenamento: 10GB de espaço livre

* Conexão com Internet estável

### Software Base

* Sistema Operacional: Windows 10/11, macOS, Linux

* Java Development Kit (JDK) 17 ou superior

* IDE compatível (recomendamos IntelliJ IDEA)

* Git para controle de versão

## Checklist de Inicialização

```
CHECKLIST
├── [1] Configuração do Ambiente
├── [2] Instalação das Ferramentas
├── [3] Verificação do Sistema
└── [4] Teste de Conexão
```

## Sequência de Boot

### 1. Preparação Inicial

Antes de mergulhar no código, certifique-se de:

* Ler o [Sobre o Projeto](about.html)

* Verificar os [Pré-requisitos](prerequisites.html)

* Entender o [Caminho de Aprendizado](learning-path.html)

### 2. Setup do Ambiente

Configure seu ambiente de desenvolvimento:

* [Configuração do Sistema Operacional](os-setup.html)

* [Visão Geral das Ferramentas](tools-overview.html)

### 3. Primeiros Passos

```JAVA
public class FirstConnection {
    public static void main(String[] args) {
        System.out.println("Conexão estabelecida com NetRunner...");
        System.out.println("Iniciando upload de conhecimento...");
        System.out.println("Bem-vindo à Matrix, runner!");
    }
}
```

## Roadmap Inicial

```MERMAID
graph TD
    A[Início] --> B[Setup Ambiente]
    B --> C[Fundamentos Java]
    C --> D[Primeiros Projetos]
    D --> E[Evolução Contínua]
```

## Navegação do Sistema

### Estrutura do Curso

* Módulos progressivos

* Projetos práticos em cada seção

* Exercícios de fixação

* Desafios de código

### Como Progredir

1. Complete cada módulo sequencialmente

2. Execute todos os exemplos de código

3. Faça os exercícios propostos

4. Construa os projetos sugeridos

## Suporte e Recursos

### Canais de Ajuda

* Documentação oficial

* Fórum da comunidade

* Repositório de exemplos

* Canal de dúvidas

## Próximos Passos

Escolha seu caminho:

1. [Configurar Ambiente de Desenvolvimento](development-environment.html)

2. [Instalar JDK](jdk-installation.html)

3. [Configurar IDE](ide-setup.html)

## Dicas de Sobrevivência

Tip:

"Na Matrix do código, a prática constante é sua melhor arma."

* Mantenha um ritmo consistente de estudos

* Pratique diariamente

* Não pule etapas fundamentais

* Construa seu próprio código

* Participe da comunidade

## Checkpoint

Antes de prosseguir, certifique-se de:

* [ ] Ter lido a introdução completa

* [ ] Entender a estrutura do curso

* [ ] Verificar os requisitos do sistema

* [ ] Estar pronto para começar a configuração

[Começar Configuração do Ambiente](development-environment.html)

Tip:

"Todo runner começa com um primeiro comando. Faça o seu contar."



# Sobre o Projeto NetRunner

```
>> Inicializando módulo de apresentação...
>> Carregando manifesto do projeto...
>> Estabelecendo parâmetros base...
```

## Manifesto NetRunner

No cenário atual do desenvolvimento de software, dominar Java não é apenas uma habilidade - é uma necessidade. O NetRunner foi concebido como uma interface neural direta para seu aprendizado, mesclando conceitos técnicos sólidos com uma experiência imersiva única.

## Arquitetura do Conhecimento

### Core Components

1. Fundamentos Sólidos

* Sintaxe e estruturas básicas

* Paradigmas de programação

* Gestão de memória e recursos

* Debugging e resolução de problemas

2. Desenvolvimento Prático

* Projetos hands-on

* Casos de uso reais

* Implementações guiadas

* Desafios progressivos

3. Evolução Técnica

* Padrões de projeto

* Boas práticas

* Otimização de código

* Segurança e performance

## Metodologia de Ensino

### Abordagem Neural

```
INPUT → PROCESSAMENTO → OUTPUT
   ↑          ↑            ↑
Teoria    Prática     Resultado
```

* Teoria Focada: Apenas o essencial, sem fluff

* Prática Intensiva: Aprenda fazendo

* Feedback Loop: Teste, erre, aprenda, repita

### Ciclo de Aprendizado

```MERMAID
graph LR
    A[Conceito] --> B[Exemplo]
    B --> C[Prática]
    C --> D[Desafio]
    D --> E[Review]
    E --> A
```

## Objetivos do Projeto

### Metas Principais

1. Capacitação Técnica

* Domínio completo da sintaxe Java

* Compreensão profunda de OOP

* Habilidades de debugging avançadas

* Práticas de código limpo

2. Desenvolvimento Profissional

* Preparação para mercado

* Portfolio builder

* Resolução de problemas reais

* Mindset de desenvolvedor

3. Evolução Contínua

* Updates regulares

* Novos desafios

* Expansão de conteúdo

* Integração com tecnologias emergentes

## Stack Tecnológico

### Core Technologies

```
JAVA STACK
├── Core Java 17+
├── Build Tools
│   ├── Maven
│   └── Gradle
├── Testing
│   ├── JUnit
│   └── Mockito
└── Frameworks
    ├── Spring
    └── Hibernate
```

## Compromisso com Qualidade

### Padrões de Excelência

* Código Documentado: Exemplos claros e bem comentados

* Melhores Práticas: Seguindo padrões da indústria

* Atualizações Regulares: Conteúdo sempre atual

* Suporte Ativo: Comunidade engajada

## Próximos Passos

Agora que você compreende a essência do NetRunner, é hora de configurar seu ambiente de desenvolvimento e começar sua jornada.

[Configurar Ambiente de Desenvolvimento](development-environment.html)

Tip:

"A matrix tem seus padrões. Uma vez que você os entende, o código se torna sua segunda natureza."



# Pré-requisitos do NetRunner

```
>> Escaneando requisitos do sistema...
>> Verificando compatibilidade...
>> Analisando perfil do usuário...
>> Relatório de requisitos gerado...
```

## Requisitos Técnicos

### Hardware Mínimo

| Componente |Requisito Mínimo |Recomendado |
---------------------------------------------
| Processador |Dual Core 2GHz |Quad Core 3GHz+ |
| Memória RAM |8GB |16GB+ |
| Armazenamento |10GB livre |20GB+ livre |
| Internet |5Mbps |15Mbps+ |

### Software Base

```
REQUISITOS DE SOFTWARE
├── Sistema Operacional
│   ├── Windows 10/11
│   ├── macOS Catalina+
│   └── Linux (kernel 5.0+)
├── Navegador Moderno
│   ├── Chrome 90+
│   ├── Firefox 88+
│   └── Edge 90+
└── Ferramentas Base
    ├── Git 2.30+
    └── Terminal
```

## Conhecimentos Prévios

### Fundamentais

* Lógica de programação básica

* Conceitos de algoritmos

* Familiaridade com terminal/linha de comando

* Noções de versionamento

### Recomendados

* Experiência com qualquer linguagem de programação

* Conhecimento básico de redes

* Inglês técnico para leitura

## Verificação de Requisitos

### Checklist Técnico

* [ ] Hardware compatível

* [ ] SO atualizado

* [ ] Espaço em disco suficiente

* [ ] Conexão estável com internet

### Checklist de Conhecimento

* [ ] Entendimento de lógica de programação

* [ ] Familiaridade com terminal

* [ ] Noções de Git

* [ ] Capacidade de leitura técnica

## Auto-Avaliação

Execute este diagnóstico básico:

```JAVA
public class SkillCheck {
    public static void main(String[] args) {
        // Se você entende este código básico
        // você está no caminho certo
        for (int i = 1; i <= 5; i++) {
            System.out.println("Teste de lógica #" + i);
        }
    }
}
```

## Preparação Inicial

### 1. Verificação de Sistema

```BASH
# Execute estes comandos no terminal
java -version
git --version
```

### 2. Estudo Preliminar

* Revisar conceitos básicos de programação

* Familiarizar-se com terminal

* Praticar Git básico

## Recursos de Nivelamento

### Material de Estudo

* [Lógica de Programação Básica](learning-path.html)

* [Introdução a Terminais](terminal-essentials.html)

* [Git Fundamentals](git-basics.html)

### Exercícios Preparatórios

1. Criar algoritmos simples

2. Praticar comandos de terminal

3. Fazer operações básicas com Git

## Próximos Passos

Se você atende aos requisitos:

1. [Começar Setup do Ambiente](development-environment.html)

2. [Instalar Ferramentas](tools-overview.html)

3. [Iniciar Jornada](learning-path.html)

Se precisar de reforço:

1. Revisar material de nivelamento

2. Praticar exercícios básicos

3. Retornar quando preparado

## Suporte

### Canais de Ajuda

* Fórum da comunidade

* Documentação oficial

* Tutoriais de nivelamento

* Mentoria da comunidade

[Configurar Ambiente de Desenvolvimento](development-environment.html)

Tip:

"Prepare seu terminal. A Matrix espera apenas aqueles que estão verdadeiramente prontos."



# Caminho de Aprendizado

```
>> Inicializando mapa neural...
>> Carregando rotas de conhecimento...
>> Calculando trajetória ótima...
>> Caminho de desenvolvimento estabelecido...
```

## Roadmap de Evolução

```MERMAID
graph TD
    A[Inicialização] --> B[Java Básico]
    B --> C[POO & Estruturas]
    C --> D[Recursos Avançados]
    D --> E[Frameworks & Tools]
    E --> F[Especialização]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#00ff00
    style F fill:#1a1a1a,stroke:#00ff00
```

## Níveis de Progressão

### Nível 1: Inicialização

```
FASE INICIAL
├── Setup do Ambiente
├── Sintaxe Básica
├── Variáveis e Tipos
├── Operadores
└── Strings
```

### Nível 2: Controle de Fluxo

```
CONTROLE
├── Condicionais
├── Loops
├── Switch
└── Pattern Matching
```

### Nível 3: Estruturas de Dados

```
ESTRUTURAS
├── Arrays
├── Collections
├── Lists & Sets
└── Maps & Queues
```

### Nível 4: POO Fundamental

```
ORIENTAÇÃO A OBJETOS
├── Classes e Objetos
├── Encapsulamento
├── Herança
└── Polimorfismo
```

### Nível 5: Recursos Avançados

```
AVANÇADO
├── Generics
├── Lambda
├── Streams
└── Optional
```

## Metodologia de Progresso

### Ciclo de Aprendizado

```MERMAID
graph LR
    A[Teoria] --> B[Exemplo]
    B --> C[Prática]
    C --> D[Projeto]
    D --> E[Review]
    E --> A
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#00ff00
```

## Sistema de Missões

### Projetos por Nível

1. Básico

* Calculadora

* Conversor de Temperatura

* Manipulador de Strings

2. Intermediário

* Sistema Bancário

* Gerenciador de Tarefas

* Processador de Dados

3. Avançado

* API REST

* Microserviço

* Sistema Distribuído

## Métricas de Progresso

### Indicadores de Evolução

* Projetos completados

* Exercícios resolvidos

* Conceitos dominados

* Código revisado

### Sistema de Conquistas

```
CONQUISTAS
├── Iniciante [▓▓▓▓▓░░░░░]
├── Desenvolvedor [▓▓▓░░░░░░░]
└── Especialista [▓░░░░░░░░░]
```

## Recursos de Suporte

### Material Complementar

* Documentação oficial

* Artigos técnicos

* Vídeos tutoriais

* Exercícios práticos

### Ferramentas de Desenvolvimento

* IDEs recomendadas

* Plugins essenciais

* Frameworks populares

* Bibliotecas úteis

## Próximas Etapas

### Caminhos de Especialização

1. Backend Development

2. Cloud Computing

3. Microservices

4. Data Engineering

## Dicas de Progresso

### Boas Práticas

* Code todos os dias

* Revise conceitos regularmente

* Participe da comunidade

* Construa projetos pessoais

### Armadilhas Comuns

* Pular fundamentos

* Não praticar código

* Ignorar boas práticas

* Evitar desafios

[Começar Jornada](java-basics.html)

Tip:

"O caminho do conhecimento é como a Matrix - infinito em possibilidades, limitado apenas pela sua dedicação."



# Ambiente de Desenvolvimento

```
>> Iniciando configuração do ambiente...
>> Verificando dependências do sistema...
>> Preparando ferramentas de desenvolvimento...
>> Ambiente base estabelecido...
```

## Visão Geral

```MERMAID
graph TD
    A[Sistema Operacional] --> B[JDK]
    B --> C[IDE]
    C --> D[Ferramentas Auxiliares]
    D --> E[Ambiente Completo]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#00ff00
```

## Stack de Desenvolvimento

### Componentes Essenciais

```
AMBIENTE BASE
├── JDK 17+
├── IDE
│   ├── IntelliJ IDEA
│   ├── Eclipse
│   └── VS Code
├── Git
└── Terminal
```

### Ferramentas Auxiliares

```
TOOLS
├── Maven/Gradle
├── Docker
├── Postman
└── DBeaver
```

## Configuração por Sistema Operacional

### Windows

```POWERSHELL
# Verificar versão do Java
java -version

# Verificar versão do Git
git --version

# Verificar variáveis de ambiente
echo %JAVA_HOME%
echo %PATH%
```

### macOS/Linux

```BASH
# Verificar versão do Java
java -version

# Verificar versão do Git
git --version

# Verificar variáveis de ambiente
echo $JAVA_HOME
echo $PATH
```

## IDEs Recomendadas

### IntelliJ IDEA

* Community Edition * Gratuita * Recursos essenciais * Plugins básicos

* Ultimate Edition * Recursos avançados * Suporte a frameworks * Ferramentas profissionais

### VS Code

* Leve e rápido

* Extensível

* Multiplataforma

* Gratuito

### Eclipse

* IDE tradicional

* Grande comunidade

* Plugins diversos

* Gratuito

## Plugins Essenciais

### Para Produtividade

```
PLUGINS
├── Code Completion
├── Git Integration
├── Code Analysis
└── Theme Tools
```

### Para Qualidade

```
QUALITY
├── SonarLint
├── CheckStyle
├── PMD
└── SpotBugs
```

## Configurações Recomendadas

### Editor Settings

```JSON
{
    "editor.formatOnSave": true,
    "java.format.enabled": true,
    "java.completion.enabled": true,
    "java.debug.settings.hotCodeReplace": "auto"
}
```

### Git Config

```BASH
git config --global user.name "Seu Nome"
git config --global user.email "seu@email.com"
git config --global core.editor "code --wait"
```

## Verificação do Ambiente

### Checklist de Instalação

* [ ] JDK instalado e configurado

* [ ] IDE instalada e configurada

* [ ] Git instalado e configurado

* [ ] Terminal configurado

* [ ] Plugins essenciais instalados

### Teste do Ambiente

```JAVA
public class EnvironmentTest {
    public static void main(String[] args) {
        System.out.println("Java Version: " + 
            System.getProperty("java.version"));
        System.out.println("Java Home: " + 
            System.getProperty("java.home"));
        System.out.println("OS: " + 
            System.getProperty("os.name"));
    }
}
```

## Próximos Passos

1. [Configurar Sistema Operacional](os-setup.html)

2. [Explorar Ferramentas](tools-overview.html)

3. [Começar a Programar](java-basics.html)

## Troubleshooting

### Problemas Comuns

1. Java não encontrado

* Verificar instalação

* Conferir PATH

* Reinstalar se necessário

2. IDE não reconhece JDK

* Verificar configurações

* Reconfigurar JAVA_HOME

* Reinstalar JDK

3. Git não configurado

* Executar configurações básicas

* Verificar credenciais

* Testar conexão com repositório

[Configurar Sistema Operacional](os-setup.html)

Tip:

"Um ambiente bem configurado é como ter acesso direto à Matrix - tudo flui naturalmente."



# Configuração do Sistema Operacional

```
>> Iniciando diagnóstico do sistema...
>> Verificando compatibilidade...
>> Ajustando configurações base...
>> Sistema preparado para desenvolvimento...
```

## Requisitos por Sistema

### Windows

```
WINDOWS SETUP
├── Windows 10/11
├── PowerShell 5.1+
├── Windows Terminal
└── WSL2 (recomendado)
```

### macOS

```
MACOS SETUP
├── Catalina (10.15)+
├── Terminal/iTerm2
├── Homebrew
└── Command Line Tools
```

### Linux

```
LINUX SETUP
├── Kernel 5.0+
├── Terminal
├── Package Manager
└── Build Tools
```

## Configuração do Windows

### 1. Habilitar WSL2

```POWERSHELL
# Habilitar WSL
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart

# Habilitar Virtualização
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart

# Definir WSL2 como padrão
wsl --set-default-version 2
```

### 2. Windows Terminal

```
TERMINAL FEATURES
├── Multi-tabs
├── Temas personalizados
├── Split panes
└── Integração WSL
```

### 3. Variáveis de Ambiente

```POWERSHELL
# Adicionar ao Path
[Environment]::SetEnvironmentVariable(
    "Path",
    [Environment]::GetEnvironmentVariable("Path", "Machine") + ";C:\your\path",
    "Machine"
)
```

## Configuração do macOS

### 1. Homebrew

```BASH
# Instalar Homebrew
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Verificar instalação
brew doctor
```

### 2. Command Line Tools

```BASH
# Instalar Command Line Tools
xcode-select --install

# Verificar instalação
xcode-select -p
```

### 3. Terminal Enhancement

```BASH
# Instalar iTerm2
brew install --cask iterm2

# Instalar Oh My Zsh
sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
```

## Configuração do Linux

### 1. Pacotes Essenciais

```BASH
# Ubuntu/Debian
sudo apt update
sudo apt install build-essential curl wget git

# Fedora
sudo dnf groupinstall "Development Tools"
sudo dnf install curl wget git
```

### 2. Terminal Setup

```BASH
# Instalar e configurar ZSH
sudo apt install zsh
chsh -s $(which zsh)

# Instalar Oh My Zsh
sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
```

## Configurações Comuns

### 1. Git Global

```BASH
# Configuração básica
git config --global user.name "Seu Nome"
git config --global user.email "seu@email.com"

# Editor padrão
git config --global core.editor "code --wait"
```

### 2. SSH Keys

```BASH
# Gerar nova chave SSH
ssh-keygen -t ed25519 -C "seu@email.com"

# Iniciar ssh-agent
eval "$(ssh-agent -s)"

# Adicionar chave
ssh-add ~/.ssh/id_ed25519
```

## Personalização

### Terminal Theme

```JSON
{
    "colorScheme": "Cyberpunk",
    "fontFace": "Cascadia Code",
    "fontSize": 12,
    "useAcrylic": true,
    "acrylicOpacity": 0.8
}
```

### Aliases Úteis

```BASH
# Git aliases
alias gs='git status'
alias ga='git add'
alias gc='git commit'
alias gp='git push'

# Navigation
alias ll='ls -la'
alias ..='cd ..'
alias ...='cd ../..'
```

## Ambientes de Desenvolvimento Isolados

### SDKMAN! com Docker

```
FROM ubuntu:22.04

# Instalar dependências
RUN apt-get update && apt-get install -y \
    curl \
    zip \
    unzip

# Instalar SDKMAN!
RUN curl -s "https://get.sdkman.io" | bash
ENV SDKMAN_DIR="/root/.sdkman"

# Configurar ambiente
COPY .sdkmanrc /app/.sdkmanrc
WORKDIR /app

# Instalar SDKs
RUN bash -c "source $SDKMAN_DIR/bin/sdkman-init.sh && \
    sdk env install"
```

### Gerenciamento de Versões por Projeto

```
PROJECT STRUCTURE
├── .sdkmanrc        # Versões do projeto
├── .java-version    # Alternativa para Java
└── docker-compose.yml
```

### Exemplo de docker-compose.yml

```YAML
version: '3.8'
services:
  java-dev:
    build: .
    volumes:
      - .:/app
    environment:
      - SDKMAN_DIR=/root/.sdkman
```

### Scripts de Automação

```BASH
#!/bin/bash
# setup-dev.sh

# Verificar SDKMAN!
if ! command -v sdk &> /dev/null; then
    echo "Instalando SDKMAN!..."
    curl -s "https://get.sdkman.io" | bash
fi

# Carregar SDKMAN!
source "$HOME/.sdkman/bin/sdkman-init.sh"

# Instalar versões do projeto
if [ -f .sdkmanrc ]; then
    echo "Configurando ambiente do projeto..."
    sdk env install
fi
```

### Integração com IDEs

```
IDE INTEGRATION
├── IntelliJ IDEA
│   └── Project SDK
├── Eclipse
│   └── Installed JREs
└── VS Code
    └── Java Runtime
```

### Verificação de Ambiente

```BASH
# Verificar todas as versões instaladas
sdk current

# Listar candidatos instalados
sdk list

# Verificar ambiente do projeto
sdk env
```

## Verificação

### Checklist Final

* [ ] Sistema atualizado

* [ ] Terminal configurado

* [ ] Git instalado

* [ ] SSH configurado

* [ ] Aliases definidos

### Teste de Ambiente

```BASH
# Verificar versões
java -version
git --version
node --version

# Testar SSH
ssh -T git@github.com
```

## Troubleshooting

### Problemas Comuns

1. WSL não inicia

* Verificar virtualização no BIOS

* Reinstalar WSL

* Atualizar Windows

2. Homebrew falha

* Verificar permissões

* Atualizar macOS

* Reinstalar Xcode CLI

3. Linux packages quebrados

* Limpar cache

* Atualizar repositórios

* Verificar dependências

[Explorar Ferramentas](tools-overview.html)

Tip:

"Configure seu sistema como um verdadeiro netrunner - cada detalhe importa na Matrix."



# Visão Geral das Ferramentas

```
NETRUNNER TOOLKIT
├── Development
│   ├── JDK
│   ├── IDE
│   └── Build Tools
├── Version Control
│   ├── Git
│   └── GitHub/GitLab
├── Containers
│   ├── Docker
│   └── Kubernetes
└── Cloud Tools
    ├── AWS CLI
    ├── Azure CLI
    └── GCloud SDK
```

## Ferramentas Essenciais

### JDK (Java Development Kit)

```
JDK DISTRIBUTIONS
├── Oracle JDK
├── OpenJDK
├── Amazon Corretto
├── Eclipse Temurin
└── GraalVM
```

#### Gerenciadores de Versão

* SDKMAN! - Gerenciamento de SDKs

* Jabba - Alternativa multiplataforma

* jEnv - Específico para Unix

### IDEs (Integrated Development Environment)

```
IDE OPTIONS
├── IntelliJ IDEA
│   ├── Community Edition
│   └── Ultimate Edition
├── Eclipse
│   └── Enterprise Edition
├── VS Code
│   └── Java Extensions
└── NetBeans
```

#### Recursos Principais

* Debugging avançado

* Integração com ferramentas

* Refatoração inteligente

* Suporte a frameworks

### Build Tools

```
BUILD SYSTEMS
├── Maven
│   ├── Dependency Management
│   └── Lifecycle Management
├── Gradle
│   ├── Groovy DSL
│   └── Kotlin DSL
└── Ant (Legacy)
```

## Ferramentas de Controle de Versão

### Git

```
GIT ESSENTIALS
├── Controle de versão
├── Branching
├── Merging
└── Colaboração
```

### Interfaces Git

```
GIT GUI TOOLS
├── GitKraken
├── SourceTree
├── GitHub Desktop
└── IDE Integration
```

## Ferramentas de Container

### Docker

```
DOCKER STACK
├── Docker Engine
├── Docker Compose
├── Docker Hub
└── Docker Desktop
```

### Container Registry

```
REGISTRY OPTIONS
├── Docker Hub
├── GitHub Packages
├── AWS ECR
└── Azure Container Registry
```

## Ferramentas Cloud

### CLI Tools

```
CLOUD TOOLS
├── AWS CLI
├── Azure CLI
├── Google Cloud SDK
└── Heroku CLI
```

### Cloud IDEs

```
CLOUD DEVELOPMENT
├── GitHub Codespaces
├── GitPod
├── Cloud9
└── Eclipse Che
```

## Ferramentas de Produtividade

### Terminal

```
TERMINAL SETUP
├── Windows Terminal
├── iTerm2 (macOS)
├── Terminator (Linux)
└── Shell
    ├── Bash
    ├── Zsh
    └── Fish
```

### Extensões Recomendadas

#### VS Code

```
VS CODE EXTENSIONS
├── Java Extension Pack
├── Spring Boot Tools
├── Debugger for Java
└── Test Runner
```

#### IntelliJ IDEA

```
INTELLIJ PLUGINS
├── Lombok
├── SonarLint
├── GitToolBox
└── Rainbow Brackets
```

## Ferramentas de Teste

### Testing Framework

```
TEST TOOLS
├── JUnit
├── TestNG
├── Mockito
└── AssertJ
```

### Análise de Código

```
CODE QUALITY
├── SonarQube
├── CheckStyle
├── PMD
└── SpotBugs
```

## Ferramentas de Documentação

### Documentation

```
DOCUMENTATION
├── JavaDoc
├── Swagger/OpenAPI
├── AsciiDoc
└── Markdown
```

## Setup Inicial

### Checklist de Instalação

* [ ] JDK via SDKMAN!

* [ ] IDE principal

* [ ] Git

* [ ] Docker

* [ ] Cloud CLI necessária

* [ ] Terminal configurado

### Configuração Recomendada

```BASH
# Instalar JDK
sdk install java

# Configurar Git
git config --global user.name "Seu Nome"
git config --global user.email "seu@email.com"

# Verificar Docker
docker --version
```

## Manutenção

### Atualizações Regulares

```
UPDATE ROUTINE
├── JDK patches
├── IDE updates
├── Docker images
└── Dependencies
```

### Backup de Configurações

```
BACKUP ESSENTIALS
├── IDE settings
├── Git config
├── Docker config
└── Terminal preferences
```

## Troubleshooting

### Problemas Comuns

1. Conflitos de Versão Java

* Usar SDKMAN! para gerenciar versões

* Verificar JAVA_HOME

* Limpar caches

2. Problemas IDE

* Limpar caches

* Atualizar índices

* Reinstalar plugins

3. Issues Docker

* Verificar serviço

* Limpar volumes

* Reset configurações

[Começar Instalação JDK](jdk-installation.html)

Tip:

"Um netrunner é tão bom quanto suas ferramentas. Escolha-as sabiamente."



# Setup do Ambiente de Desenvolvimento

```
SYSTEM INITIALIZATION
├── JDK Setup
├── IDE Config
├── Git Setup
├── Docker Init
├── Cloud Tools
└── Terminal Setup
```

## Visão Geral

### Requisitos Mínimos

```
MINIMUM SPECS
├── CPU: 2+ cores
├── RAM: 8GB+
├── Storage: 10GB+
└── Internet: 10Mbps+
```

### Componentes Principais

* Java Development Kit (JDK)

* Ambiente de Desenvolvimento Integrado (IDE)

* Sistema de Controle de Versão

* Ferramentas de Containerização

* CLIs de Cloud

* Terminal Configurado

## Ordem de Instalação

### Sequência Recomendada

1. [Instalação do JDK](jdk-installation.html)

2. [Configuração da IDE](ide-setup.html)

3. [Básico do Git](git-basics.html)

4. [Essenciais do Terminal](terminal-essentials.html)

5. [Básico do Docker](docker-basics.html)

6. [Setup Cloud](cloud-setup.html)

## Verificação de Ambiente

### Checklist de Validação

```BASH
# Verificar Java
java --version

# Verificar Git
git --version

# Verificar Docker
docker --version

# Verificar Cloud CLI
aws --version  # ou
az --version   # ou
gcloud --version
```

## Próximos Passos

### Configuração Avançada

* Personalização da IDE

* Configuração do Git

* Setup de Containers

* Integração Cloud

[Iniciar Instalação do JDK](jdk-installation.html)

Tip:

"A preparação adequada é metade da batalha. Configure seu ambiente com precisão."



# Instalação do JDK

```
JDK INSTALLATION
├── SDKMAN! Setup
├── JDK Selection
├── Environment Config
└── Validation
```

## SDKMAN!

### Instalação do SDKMAN!

```BASH
# Download e instalação
curl -s "https://get.sdkman.io" | bash

# Recarregar shell
source "$HOME/.sdkman/bin/sdkman-init.sh"

# Verificar instalação
sdk version
```

### Comandos Básicos

```
SDKMAN COMMANDS
├── sdk list java     # Listar versões
├── sdk install java  # Instalar JDK
├── sdk use java     # Usar versão
└── sdk default java # Definir padrão
```

## Instalação do JDK

### Escolha da Distribuição

```
JDK OPTIONS
├── Oracle JDK
│   └── Licença comercial
├── OpenJDK
│   └── Open source
├── Amazon Corretto
│   └── AWS optimized
├── Eclipse Temurin
│   └── AdoptOpenJDK successor
└── GraalVM
    └── Native compilation
```

### Instalação via SDKMAN!

```BASH
# Listar versões disponíveis
sdk list java

# Instalar JDK LTS
sdk install java 17.0.8-tem

# Definir como padrão
sdk default java 17.0.8-tem
```

## Configuração do Ambiente

### Variáveis de Ambiente

```BASH
# Verificar JAVA_HOME
echo $JAVA_HOME

# Verificar PATH
echo $PATH | grep java
```

### Configuração Manual (se necessário)

```BASH
# Para Bash/Zsh
echo "export JAVA_HOME=$HOME/.sdkman/candidates/java/current" >> ~/.bashrc
echo "export PATH=\$JAVA_HOME/bin:\$PATH" >> ~/.bashrc

# Para Fish
set -Ux JAVA_HOME $HOME/.sdkman/candidates/java/current
set -Ux PATH $JAVA_HOME/bin $PATH
```

## Verificação da Instalação

### Testes Básicos

```BASH
# Verificar versão Java
java --version

# Verificar compilador
javac --version

# Testar compilação
echo 'public class Test { public static void main(String[] args) { System.out.println("Hello, NetRunner!"); } }' > Test.java
javac Test.java
java Test
```

## Multi-versão

### Gerenciamento de Versões

```BASH
# Instalar múltiplas versões
sdk install java 11.0.20-tem
sdk install java 17.0.8-tem
sdk install java 21-tem

# Alternar entre versões
sdk use java 11.0.20-tem  # Temporário
sdk default java 17.0.8-tem  # Permanente
```

### Configuração por Projeto

```BASH
# Criar arquivo de configuração
echo "java=17.0.8-tem" > .sdkmanrc

# Ativar ambiente do projeto
sdk env
```

## Troubleshooting

### Problemas Comuns

1. SDKMAN! não instala

* Verificar curl instalado

* Verificar permissões

* Verificar conexão

2. JDK não encontrado

* Recarregar terminal

* Verificar PATH

* Verificar JAVA_HOME

3. Conflitos de versão

* Usar `sdk flush`

* Remover versão: `sdk rm java`

* Reinstalar SDKMAN!

## Próximos Passos

### Configuração IDE

* Configurar Project SDK

* Importar projetos

* Configurar build tools

[Configurar IDE](ide-setup.html)

Tip:

"A base de todo netrunner é um JDK bem configurado. Escolha suas armas com sabedoria."



# Configuração da IDE

```
IDE SETUP
├── IntelliJ IDEA
├── Eclipse
├── VS Code
└── NetBeans
```

## IntelliJ IDEA

### Instalação

```
INTELLIJ VARIANTS
├── Community Edition
│   └── Open Source
└── Ultimate Edition
    └── Trial/Licensed
```

```BASH
# Linux (snap)
sudo snap install intellij-idea-community --classic

# macOS (brew)
brew install --cask intellij-idea-ce

# Windows
winget install JetBrains.IntelliJ.IDEA.Community
```

### Plugins Essenciais

```
CORE PLUGINS
├── Java Development
├── Git Integration
├── Maven/Gradle
└── Docker
```

### Configuração Inicial

```
INITIAL SETUP
├── Project SDK
├── Code Style
├── File Templates
└── Live Templates
```

## Visual Studio Code

### Instalação

```BASH
# Linux
sudo snap install code --classic

# macOS
brew install --cask visual-studio-code

# Windows
winget install Microsoft.VisualStudioCode
```

### Extensões Java

```
EXTENSIONS
├── Extension Pack for Java
├── Spring Boot Extension Pack
├── Java Test Runner
└── Debugger for Java
```

### Configurações Recomendadas

```JSON
{
    "java.home": "/path/to/jdk",
    "java.format.settings.url": "eclipse-formatter.xml",
    "java.completion.importOrder": [
        "java",
        "javax",
        "com",
        "org"
    ]
}
```

## Eclipse

### Instalação

```
ECLIPSE PACKAGES
├── Eclipse IDE for Java
├── Eclipse IDE for Enterprise
└── Eclipse IDE for Web
```

```BASH
# Linux
sudo snap install eclipse --classic

# macOS
brew install --cask eclipse-java

# Windows
winget install Eclipse.Java
```

### Plugins Recomendados

```
ECLIPSE PLUGINS
├── EGit
├── Spring Tools
├── CodeMix
└── Darkest Dark Theme
```

## Configurações Avançadas

### Personalização

```
CUSTOMIZATION
├── Theme Setup
├── Keymap Config
├── Code Templates
└── Live Templates
```

### Integração Git

```
GIT SETUP
├── SSH Keys
├── GitHub Integration
├── GitLab Integration
└── Bitbucket Integration
```

### Debug & Profiling

```
DEBUG TOOLS
├── Remote Debug
├── Memory Analyzer
├── CPU Profiler
└── Thread Dump
```

## Produtividade

### Atalhos Essenciais

```
SHORTCUTS
├── Code Completion
│   ├── Ctrl+Space
│   └── Alt+Enter
├── Navigation
│   ├── Ctrl+Click
│   └── Alt+F7
├── Refactoring
│   ├── Shift+F6
│   └── Ctrl+Alt+M
└── Debug
    ├── F8
    └── F9
```

### Templates

```JAVA
// Live Template: psvm
public static void main(String[] args) {
    
}

// Live Template: sout
System.out.println();

// Live Template: fori
for (int i = 0; i < ; i++) {
    
}
```

## Troubleshooting

### Problemas Comuns

1. IDE não reconhece JDK

* Verificar JAVA_HOME

* Reconfigurar Project SDK

* Invalidar caches

2. Performance lenta

* Aumentar heap memory

* Desabilitar plugins

* Limpar índices

3. Problemas de indexação

* Invalidar caches

* Reconstruir índices

* Verificar exclusões

## Configuração do Projeto

### Estrutura Básica

```
PROJECT STRUCTURE
├── src/
│   ├── main/
│   │   ├── java/
│   │   └── resources/
│   └── test/
│       ├── java/
│       └── resources/
├── pom.xml
└── .gitignore
```

### Build Tools

```
BUILD CONFIG
├── Maven
│   └── pom.xml
└── Gradle
    └── build.gradle
```

## Próximos Passos

### Workflow Setup

* Configurar formatação de código

* Definir templates de projeto

* Configurar integração contínua

* Preparar ambiente de debug

[Configurar Git](git-basics.html)

Tip:

"Uma IDE bem configurada é como ter um deck cyberdeck personalizado - aumenta exponencialmente sua eficiência na Matrix."



# Git Básico

```
GIT FUNDAMENTALS
├── Setup Inicial
├── Operações Básicas
├── Branching
├── Remote Operations
└── Best Practices
```

## Instalação e Setup

### Instalação

```BASH
# Linux (Debian/Ubuntu)
sudo apt install git

# macOS
brew install git

# Windows
winget install Git.Git
```

### Configuração Inicial

```BASH
# Identidade
git config --global user.name "Seu Nome"
git config --global user.email "seu@email.com"

# Editor padrão
git config --global core.editor "code --wait"  # VS Code
# git config --global core.editor "vim"        # Vim
# git config --global core.editor "nano"       # Nano

# Configurar branch padrão
git config --global init.defaultBranch main
```

## Operações Básicas

### Ciclo de Vida

```
FILE STATUS
├── Untracked
├── Staged
├── Committed
└── Modified
```

### Comandos Essenciais

```BASH
# Iniciar repositório
git init

# Status do repositório
git status

# Adicionar arquivos
git add <arquivo>      # Arquivo específico
git add .              # Todos os arquivos

# Commit
git commit -m "mensagem"
git commit -am "mensagem"  # Add + Commit

# Histórico
git log
git log --oneline
git log --graph
```

## Branches

### Operações com Branches

```BASH
# Listar branches
git branch

# Criar branch
git branch feature/nova-funcionalidade

# Mudar de branch
git checkout feature/nova-funcionalidade
# ou
git switch feature/nova-funcionalidade

# Criar e mudar
git checkout -b feature/nova-funcionalidade
```

### Merge e Rebase

```BASH
# Merge
git checkout main
git merge feature/nova-funcionalidade

# Rebase
git checkout feature/nova-funcionalidade
git rebase main
```

## Operações Remotas

### Configuração Remota

```BASH
# Adicionar remote
git remote add origin https://github.com/user/repo.git

# Listar remotes
git remote -v

# Remover remote
git remote remove origin
```

### Sincronização

```BASH
# Push
git push origin main

# Pull
git pull origin main

# Fetch
git fetch origin

# Clone
git clone https://github.com/user/repo.git
```

## Gitflow

### Estrutura de Branches

```
BRANCH STRUCTURE
├── main
├── develop
├── feature/*
├── release/*
├── hotfix/*
└── bugfix/*
```

### Workflow Básico

```
WORKFLOW
├── Criar feature branch
├── Desenvolver
├── Commit changes
├── Push to remote
└── Create pull request
```

## Boas Práticas

### Commits

```
COMMIT PATTERNS
├── Conventional Commits
│   ├── feat: nova feature
│   ├── fix: correção
│   ├── docs: documentação
│   ├── style: formatação
│   ├── refactor: refatoração
│   ├── test: testes
│   └── chore: manutenção
└── Atomic Commits
```

### .gitignore

```BASH
# Java
*.class
*.jar
target/

# IDEs
.idea/
.vscode/
*.iml

# Logs
*.log
logs/

# OS
.DS_Store
Thumbs.db
```

## Git Avançado

### Stash

```BASH
# Salvar alterações
git stash

# Listar stashes
git stash list

# Aplicar stash
git stash apply
git stash pop

# Limpar stash
git stash clear
```

### Reset e Revert

```BASH
# Reset
git reset --soft HEAD~1   # Mantém alterações
git reset --hard HEAD~1   # Remove alterações

# Revert
git revert HEAD          # Reverte último commit
```

## Troubleshooting

### Problemas Comuns

1. Conflitos de Merge

```BASH
# Abortar merge
git merge --abort

# Resolver manualmente
# Editar arquivos
git add .
git commit
```

2. Branch Errada

```BASH
# Mover alterações
git stash
git checkout branch-correta
git stash pop
```

3. Commit Errado

```BASH
# Desfazer último commit
git reset --soft HEAD~1

# Alterar mensagem
git commit --amend
```

## Ferramentas Visuais

### GUI Clients

```
GUI OPTIONS
├── GitKraken
├── SourceTree
├── GitHub Desktop
└── Git GUI
```

## Próximos Passos

### Aprofundamento

* Explorar Git hooks

* Configurar CI/CD

* Aprender rebase interativo

* Estudar estratégias de branching

[Essenciais do Terminal](terminal-essentials.html)

Tip:

"No submundo digital, o controle de versão é sua linha do tempo pessoal - cada commit é um checkpoint que você pode revisitar."



# Essenciais do Terminal

```
TERMINAL MASTERY
├── Básico
├── Navegação
├── Manipulação
├── Processos
└── Customização
```

## Comandos Fundamentais

### Navegação

```BASH
# Listar arquivos
ls
ls -la

# Mudar diretório
cd path/to/dir
cd ..
cd ~

# Mostrar diretório atual
pwd
```

### Manipulação de Arquivos

```BASH
# Criar
touch arquivo.txt
mkdir pasta

# Copiar
cp origem destino
cp -r pasta1 pasta2

# Mover/Renomear
mv origem destino

# Remover
rm arquivo.txt
rm -r pasta
```

### Visualização

```BASH
# Ver conteúdo
cat arquivo.txt
less arquivo.txt
head arquivo.txt
tail arquivo.txt

# Buscar
grep "texto" arquivo.txt
find . -name "*.java"
```

## Permissões

### Gerenciamento

```BASH
# Visualizar
ls -l

# Modificar
chmod +x script.sh
chmod 755 arquivo

# Mudar proprietário
chown usuario:grupo arquivo
```

## Processos

### Gerenciamento

```BASH
# Listar processos
ps aux
top

# Background
comando &
bg
fg

# Terminar processo
kill PID
killall processo
```

## Redirecionamento

### Input/Output

```BASH
# Redirecionamento
comando > output.txt
comando >> output.txt
comando < input.txt

# Pipes
comando1 | comando2
```

## Ambiente

### Variáveis

```BASH
# Exibir
echo $PATH
env

# Definir
export JAVA_HOME=/path/to/java
```

## Customização

### Shell RC

```BASH
# .bashrc ou .zshrc
alias ll='ls -la'
alias gs='git status'

# Path
export PATH=$PATH:/novo/caminho
```

## Atalhos

### Keyboard Shortcuts

```
SHORTCUTS
├── Ctrl + C  (Cancelar)
├── Ctrl + L  (Limpar)
├── Ctrl + R  (Buscar histórico)
├── Ctrl + A  (Início da linha)
└── Ctrl + E  (Fim da linha)
```

## Scripts

### Shell Scripts

```BASH
#!/bin/bash

# Exemplo básico
echo "Iniciando script..."
for i in {1..5}; do
    echo "Iteração $i"
done
```

## Ferramentas Avançadas

### Power Tools

```
POWER TOOLS
├── tmux    (Terminal Multiplexer)
├── vim     (Editor)
├── htop    (Process Viewer)
└── fzf     (Fuzzy Finder)
```

## Troubleshooting

### Debug

```BASH
# Debug modo
set -x

# Verificar status
echo $?

# Ver logs
tail -f /var/log/syslog
```

## Próximos Passos

### Aprofundamento

* Shell scripting avançado

* Automação com cron

* Terminal multiplexing

* Customização avançada

[Básico do Docker](docker-basics.html)

Tip:

"O terminal é sua interface direta com a Matrix - domine-o, e você controlará o sistema."



# Docker Básico

```
DOCKER ESSENTIALS
├── Conceitos
├── Instalação
├── Comandos Básicos
├── Docker Compose
└── Best Practices
```

## Fundamentos

### Conceitos Básicos

```
DOCKER COMPONENTS
├── Images
├── Containers
├── Volumes
├── Networks
└── Registry
```

### Instalação

```BASH
# Linux (Ubuntu)
curl -fsSL https://get.docker.com | sh

# Windows/Mac
# Baixar Docker Desktop do site oficial
```

## Comandos Essenciais

### Gerenciamento de Containers

```BASH
# Executar container
docker run hello-world
docker run -d -p 8080:80 nginx

# Listar containers
docker ps
docker ps -a

# Operações
docker start container_id
docker stop container_id
docker restart container_id
docker rm container_id
```

### Imagens

```BASH
# Listar imagens
docker images

# Pull de imagem
docker pull ubuntu:latest

# Remover imagem
docker rmi imagem_id

# Build de imagem
docker build -t app:1.0 .
```

## Dockerfile

### Estrutura Básica

```
# Base image
FROM openjdk:17-jdk-slim

# Metadados
LABEL maintainer="netrunner@corp.net"

# Diretório de trabalho
WORKDIR /app

# Copiar arquivos
COPY target/*.jar app.jar

# Porta
EXPOSE 8080

# Comando de execução
CMD ["java", "-jar", "app.jar"]
```

## Docker Compose

### docker-compose.yml

```YAML
version: '3.8'
services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - DB_HOST=db
    depends_on:
      - db
  
  db:
    image: postgres:13
    environment:
      - POSTGRES_PASSWORD=secret
```

### Comandos Compose

```BASH
# Iniciar serviços
docker-compose up -d

# Parar serviços
docker-compose down

# Logs
docker-compose logs
```

## Redes

### Network Commands

```BASH
# Criar rede
docker network create mynet

# Listar redes
docker network ls

# Conectar container
docker network connect mynet container_id
```

## Volumes

### Volume Management

```BASH
# Criar volume
docker volume create mydata

# Listar volumes
docker volume ls

# Usar volume
docker run -v mydata:/data nginx
```

## Troubleshooting

### Problemas Comuns

```BASH
# Verificar logs
docker logs container_id

# Inspecionar container
docker inspect container_id

# Entrar no container
docker exec -it container_id bash
```

## Segurança

### Best Practices

```
SECURITY CHECKLIST
├── Usar imagens oficiais
├── Manter containers atualizados
├── Limitar recursos
├── Usar usuários não-root
└── Escanear vulnerabilidades
```

## Monitoramento

### Ferramentas

```
MONITORING TOOLS
├── Docker Stats
├── Prometheus
├── Grafana
└── cAdvisor
```

## Próximos Passos

### Aprofundamento

* Orquestração com Kubernetes

* CI/CD com Docker

* Docker Swarm

* Microserviços

[Setup Cloud](cloud-setup.html)

Tip:

"Containers são como cápsulas de dados na Matrix - isolados, portáteis e prontos para deployment."



# Setup Cloud

```
CLOUD SETUP
├── Providers
├── CLI Tools
├── Authentication
└── Basic Services
```

## Cloud Providers

### Principais Provedores

```
CLOUD OPTIONS
├── AWS
├── Azure
├── Google Cloud
└── Oracle Cloud
```

## CLI Setup

### AWS CLI

```BASH
# Instalar AWS CLI
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install

# Configurar
aws configure
```

### Azure CLI

```BASH
# Instalar Azure CLI
curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

# Login
az login
```

### Google Cloud SDK

```BASH
# Instalar Google Cloud SDK
curl https://sdk.cloud.google.com | bash

# Inicializar
gcloud init
```

## Autenticação

### Credenciais

```
AUTH METHODS
├── Access Keys
├── Service Accounts
├── IAM Roles
└── MFA
```

### Configuração

```BASH
# AWS Credentials
aws configure set aws_access_key_id YOUR_KEY
aws configure set aws_secret_access_key YOUR_SECRET

# GCloud Auth
gcloud auth login
gcloud config set project YOUR_PROJECT
```

## Serviços Básicos

### Storage

```
STORAGE SERVICES
├── AWS S3
├── Azure Blob
└── Google Cloud Storage
```

### Compute

```
COMPUTE SERVICES
├── EC2/VM
├── Container Services
└── Serverless
```

## Networking

### VPC Setup

```
NETWORK CONFIG
├── VPC/VNET
├── Subnets
├── Security Groups
└── Load Balancers
```

## Monitoramento

### Ferramentas Cloud

```
MONITORING
├── CloudWatch
├── Azure Monitor
└── Cloud Monitoring
```

## Segurança

### Best Practices

```
SECURITY CHECKLIST
├── MFA Ativado
├── Least Privilege
├── Encryption
└── Logging
```

## Cost Management

### Controle de Custos

```
COST CONTROL
├── Budgets
├── Alerts
├── Resource Tags
└── Cost Explorer
```

## Próximos Passos

### Aprofundamento

* Infrastructure as Code

* Cloud Native Development

* Serverless Architecture

* Multi-Cloud Strategy

[Começar com Java](java-basics.html)

Tip:

"A nuvem é a nova fronteira da Matrix - um território vasto de recursos virtualizados prontos para serem explorados."



# Fundamentos Java

```
JAVA BASICS
├── Estrutura
├── Sintaxe
├── Tipos
├── Operadores
└── Strings
```

## Estrutura de um Programa

### Anatomia Básica

```JAVA
// Arquivo: HelloMatrix.java
public class HelloMatrix {
    public static void main(String[] args) {
        System.out.println("Iniciando conexão com a Matrix...");
    }
}
```

### Componentes Principais

```
JAVA STRUCTURE
├── Package Declaration
├── Imports
├── Class Declaration
├── Fields
└── Methods
```

## Convenções de Código

### Nomenclatura

```
NAMING CONVENTIONS
├── Classes        (PascalCase)
├── Methods        (camelCase)
├── Variables      (camelCase)
├── Constants      (UPPER_SNAKE_CASE)
└── Packages       (lowercase)
```

## Compilação e Execução

### Processo

```
COMPILATION FLOW
Source (.java) → Bytecode (.class) → JVM → Execution
```

### Comandos

```BASH
# Compilar
javac HelloMatrix.java

# Executar
java HelloMatrix
```

## Estrutura de Arquivos

### Organização

```
PROJECT STRUCTURE
src/
├── com/
│   └── netrunner/
│       └── core/
│           └── HelloMatrix.java
└── resources/
    └── config.properties
```

## Comentários

### Tipos

```JAVA
// Comentário de linha única

/*
   Comentário de
   múltiplas linhas
*/

/**
 * Documentação JavaDoc
 * @author NetRunner
 * @version 1.0
 */
```

## Palavras-Chave

### Keywords Principais

```
KEYWORDS
├── Controle     (if, else, for, while)
├── Modificadores (public, private, static)
├── Tipos        (class, interface, enum)
└── Outros       (new, return, this, super)
```

## Ambiente de Desenvolvimento

### Ferramentas Essenciais

```
DEV ENVIRONMENT
├── JDK
├── IDE
├── Build Tools
└── Version Control
```

## Debug e Logs

### Técnicas Básicas

```JAVA
// Print debugging
System.out.println("Debug: " + variable);

// Logging básico
Logger logger = Logger.getLogger(HelloMatrix.class.getName());
logger.info("Iniciando aplicação...");
```

## Boas Práticas

### Princípios

```
BEST PRACTICES
├── Clean Code
├── DRY (Don't Repeat Yourself)
├── KISS (Keep It Simple)
└── SOLID Principles
```

## Próximos Passos

### Tópicos Seguintes

* Sintaxe detalhada

* Variáveis e tipos

* Operadores

* Strings e manipulação

* Projetos práticos

[Sintaxe Java](syntax.html)

Tip:

"Java é como o código base da Matrix - estruturado, robusto e onipresente."

## Subseções

* [Sintaxe](syntax.html)

* [Variáveis](variables.html)

* [Operadores](operators.html)

* [Strings](strings.html)

* [Projetos Básicos](basic-projects.html)



# Sintaxe Java

```
SYNTAX STRUCTURE
├── Declarações
├── Blocos
├── Expressões
└── Statements
```

## Estrutura Básica

### Classe

```JAVA
public class MatrixCode {
    // Membros da classe aqui
}
```

### Método

```JAVA
public void hackSystem() {
    // Código do método aqui
}
```

## Declarações

### Variáveis

```JAVA
// Declaração simples
tipo nome;

// Declaração com inicialização
tipo nome = valor;

// Exemplos
int contador = 0;
String mensagem = "Conexão estabelecida";
boolean sistemaBloqueado = false;
```

### Constantes

```JAVA
// Constante
final double PI = 3.14159;

// Constante estática
public static final String VERSION = "1.0.0";
```

## Blocos de Código

### Estrutura

```JAVA
{
    // Bloco de código
    // Pode conter múltiplas linhas
}
```

### Escopo

```JAVA
public void exemplo() {
    int x = 1; // Escopo do método
    {
        int y = 2; // Escopo do bloco
        // y é acessível aqui
    }
    // y não é acessível aqui
    // x é acessível em todo o método
}
```

## Statements

### Tipos

```JAVA
// Statement simples
System.out.println("Executando...");

// Statement composto
if (status == "online") {
    System.out.println("Conectado");
    iniciarOperacao();
}
```

## Expressões

### Componentes

```JAVA
// Expressões aritméticas
resultado = 10 + 5 * 2;

// Expressões lógicas
boolean acessoPermitido = nivel >= 5 && !bloqueado;

// Expressões de string
String nomeCompleto = nome + " " + sobrenome;
```

## Identificadores

### Regras

```
IDENTIFIER RULES
├── Começar com letra, $ ou _
├── Pode conter números
├── Case-sensitive
└── Sem palavras reservadas
```

### Exemplos

```JAVA
// Válidos
String usuarioNome;
int _contador;
double $taxa;

// Inválidos
int 123numero;     // Começa com número
String class;      // Palavra reservada
```

## Palavras Reservadas

### Keywords

```
RESERVED WORDS
├── Tipos      (boolean, byte, char...)
├── Controle   (if, else, for, while...)
├── Acesso     (public, private, protected...)
└── Outros     (new, return, this, super...)
```

## Separadores

### Caracteres Especiais

```
SEPARATORS
├── { }    Blocos
├── [ ]    Arrays
├── ( )    Parâmetros
├── ;      Fim de statement
├── ,      Separador
└── .      Acesso a membros
```

## Convenções

### Estilo de Código

```
CODE STYLE
├── Classes        PascalCase
├── Métodos        camelCase
├── Variáveis      camelCase
├── Constantes     UPPER_SNAKE_CASE
└── Pacotes        lowercase
```

## Exemplos Práticos

### Classe Completa

```JAVA
package com.netrunner.core;

public class SecuritySystem {
    private static final int MAX_ATTEMPTS = 3;
    private int attemptCount;
    
    public SecuritySystem() {
        this.attemptCount = 0;
    }
    
    public boolean authenticate(String code) {
        attemptCount++;
        if (attemptCount > MAX_ATTEMPTS) {
            lockSystem();
            return false;
        }
        return validateCode(code);
    }
    
    private void lockSystem() {
        System.out.println("Sistema bloqueado!");
    }
    
    private boolean validateCode(String code) {
        return code.equals("MATRIX_1999");
    }
}
```

## Próximos Passos

### Tópicos Relacionados

* [Variáveis](variables.html)

* [Operadores](operators.html)

* [Estruturas de Controle](control-flow.html)

[Variáveis](variables.html)

Tip:

"A sintaxe é o protocolo que mantém a Matrix funcionando. Domine-a, e você dominará o sistema."



# Variáveis em Java

```
VARIABLES
├── Tipos Primitivos
├── Tipos de Referência
├── Type Casting
└── Palavra-chave var
```

## Conceitos Básicos

### Definição

Uma variável é um local na memória que armazena dados. Em Java, toda variável tem:

* Nome (identificador)

* Tipo

* Valor

### Declaração

```JAVA
// Sintaxe básica
tipoDaVariavel nomeDaVariavel;

// Com inicialização
tipoDaVariavel nomeDaVariavel = valor;
```

## Categorias Principais

### Tipos Primitivos

```
PRIMITIVE TYPES
├── Números Inteiros (byte, short, int, long)
├── Números Decimais (float, double)
├── Caractere (char)
└── Booleano (boolean)
```

### Tipos de Referência

```
REFERENCE TYPES
├── Classes
├── Interfaces
├── Arrays
└── Enums
```

## Escopo

### Níveis

```
SCOPE LEVELS
├── Classe (campos)
├── Método (variáveis locais)
└── Bloco (variáveis de bloco)
```

### Exemplo

```JAVA
public class DataMatrix {
    private int nivelAcesso; // Escopo de classe
    
    public void processarDados() {
        int contador = 0; // Escopo de método
        
        for (int i = 0; i < 10; i++) { // i tem escopo de bloco
            // código aqui
        }
    }
}
```

## Modificadores

### Constantes

```JAVA
// Constante de classe
public static final int MAX_CONEXOES = 100;

// Constante local
final double PI = 3.14159;
```

### Variáveis Estáticas

```JAVA
public class Sistema {
    static int contadorGlobal; // Compartilhada por todas instâncias
    int contadorLocal; // Específica para cada instância
}
```

## Boas Práticas

### Nomenclatura

```JAVA
// Bom
int userId;
String firstName;
boolean isActive;

// Evitar
int a;
String x;
boolean flag;
```

### Inicialização

```JAVA
// Valores padrão
int numero; // 0
boolean status; // false
String texto; // null

// Inicialização explícita (recomendado)
int numero = 0;
boolean status = false;
String texto = "";
```

## Subseções

* [Tipos Primitivos](primitive-types.html)

* [Tipos de Referência](reference-types.html)

* [Type Casting](type-casting.html)

* [Palavra-chave var](var-keyword.html)

[Tipos Primitivos](primitive-types.html)

Tip:

"Variáveis são como terminais na Matrix - pontos de acesso para manipular a realidade digital."



# Tipos Primitivos

```
PRIMITIVE DATA TYPES
├── Inteiros
│   ├── byte  (8 bits)
│   ├── short (16 bits)
│   ├── int   (32 bits)
│   └── long  (64 bits)
├── Decimais
│   ├── float  (32 bits)
│   └── double (64 bits)
├── Caractere
│   └── char   (16 bits)
└── Lógico
    └── boolean (1 bit)
```

## Tipos Numéricos Inteiros

### byte

```JAVA
// Range: -128 até 127
byte nivelPoder = 100;
byte codigoStatus = -50;
```

### short

```JAVA
// Range: -32,768 até 32,767
short populacao = 30000;
short temperatura = -200;
```

### int

```JAVA
// Range: -2^31 até 2^31-1
int usuarios = 1000000;
int pontuacao = 2147483647;
```

### long

```JAVA
// Range: -2^63 até 2^63-1
long populacaoMundial = 7800000000L;
long distanciaEspacial = 9223372036854775807L;
```

## Tipos Numéricos Decimais

### float

```JAVA
// Precisão: 6-7 dígitos decimais
float taxa = 19.99f;
float temperatura = -273.15f;
```

### double

```JAVA
// Precisão: 15-16 dígitos decimais
double pi = 3.141592653589793;
double velocidadeLuz = 299792458.0;
```

## Tipo Caractere

### char

```JAVA
// Unicode 16-bit
char nivel = 'A';
char simbolo = '$';
char unicode = '\u0041'; // 'A'
```

## Tipo Booleano

### boolean

```JAVA
// Valores: true ou false
boolean sistemaAtivo = true;
boolean acessoPermitido = false;
```

## Valores Padrão

### Inicialização Automática

```
DEFAULT VALUES
├── byte, short, int, long → 0
├── float, double → 0.0
├── char → '\u0000'
└── boolean → false
```

## Limites e Constantes

### Valores Máximos e Mínimos

```JAVA
// Constantes úteis
byte maxByte = Byte.MAX_VALUE;    // 127
int minInt = Integer.MIN_VALUE;   // -2147483648
long maxLong = Long.MAX_VALUE;    // 9223372036854775807
```

## Literais Numéricos

### Representações

```JAVA
// Decimal
int decimal = 1234;

// Hexadecimal
int hexadecimal = 0xFF; // 255

// Binário
int binario = 0b1010; // 10

// Octal
int octal = 0757; // 495
```

## Separador de Dígitos

### Uso do Underscore

```JAVA
// Melhorando legibilidade
long cartaoCredito = 1234_5678_9012_3456L;
int milhao = 1_000_000;
```

## Considerações de Performance

### Escolha do Tipo

```
PERFORMANCE TIPS
├── Use int para loops
├── Prefira double a float
├── byte/short para arrays grandes
└── boolean para flags
```

## Próximos Passos

### Tópicos Relacionados

* [Tipos de Referência](reference-types.html)

* [Type Casting](type-casting.html)

* [Operadores](operators.html)

[Tipos de Referência](reference-types.html)

Tip:

"Os tipos primitivos são como os átomos da Matrix - as unidades fundamentais que compõem toda a realidade digital."



# Tipos de Referência

```
REFERENCE TYPES
├── Classes
├── Interfaces
├── Arrays
└── Enums
```

## Classes

### Definição e Uso

```JAVA
// Declaração
String mensagem = new String("Conexão estabelecida");
StringBuilder buffer = new StringBuilder();

// Null é permitido
String dados = null;
```

### Classes Comuns

```JAVA
// Wrapper classes
Integer numero = 42;
Double valor = 3.14;
Boolean flag = true;

// Utilitários
Date data = new Date();
Random gerador = new Random();
```

## Arrays

### Declaração e Inicialização

```JAVA
// Arrays unidimensionais
int[] numeros = new int[5];
String[] comandos = {"LOGIN", "EXECUTE", "LOGOUT"};

// Arrays multidimensionais
int[][] matriz = new int[3][3];
```

### Manipulação

```JAVA
// Acessando elementos
int primeiro = numeros[0];

// Modificando elementos
numeros[1] = 42;

// Comprimento
int tamanho = numeros.length;
```

## Enums

### Definição

```JAVA
public enum NivelAcesso {
    ADMIN,
    USUARIO,
    CONVIDADO
}
```

### Uso

```JAVA
NivelAcesso nivel = NivelAcesso.ADMIN;

switch (nivel) {
    case ADMIN:
        System.out.println("Acesso total");
        break;
    case USUARIO:
        System.out.println("Acesso parcial");
        break;
    case CONVIDADO:
        System.out.println("Acesso limitado");
        break;
}
```

## Interfaces

### Implementação

```JAVA
public interface Conexao {
    void conectar();
    void desconectar();
}

public class ConexaoSegura implements Conexao {
    @Override
    public void conectar() {
        // Implementação
    }

    @Override
    public void desconectar() {
        // Implementação
    }
}
```

## Diferenças dos Primitivos

### Características

```
REFERENCE VS PRIMITIVE
├── Armazenamento (Heap vs Stack)
├── Null permitido
├── Métodos disponíveis
└── Overhead de memória
```

### Exemplo

```JAVA
// Primitivo
int x = 10;

// Referência
Integer y = 10;
y.toString(); // Métodos disponíveis
y = null; // Permitido
```

## Garbage Collection

### Ciclo de Vida

```
OBJECT LIFECYCLE
├── Criação (new)
├── Referenciação
├── Desreferenciação
└── Coleta de lixo
```

### Exemplo

```JAVA
String texto = new String("temp"); // Objeto criado
texto = null; // Objeto elegível para GC
```

## Collections Framework

### Tipos Principais

```JAVA
// List
List<String> lista = new ArrayList<>();

// Set
Set<Integer> conjunto = new HashSet<>();

// Map
Map<String, Integer> mapa = new HashMap<>();
```

## Boas Práticas

### Recomendações

```
BEST PRACTICES
├── Inicialize referências
├── Use interfaces apropriadas
├── Verifique null
└── Libere recursos
```

### Exemplo

```JAVA
// Verificação de null
if (objeto != null) {
    objeto.metodo();
}

// Try-with-resources
try (Scanner scanner = new Scanner(System.in)) {
    // Uso do scanner
}
```

## Próximos Passos

### Tópicos Relacionados

* [Type Casting](type-casting.html)

* [Palavra-chave var](var-keyword.html)

* [Collections](collections-overview.html)

[Type Casting](type-casting.html)

Tip:

"Os tipos de referência são como os programas da Matrix - entidades complexas que manipulam a realidade digital."



# Type Casting em Java

```
TYPE CASTING
├── Implícito (Widening)
├── Explícito (Narrowing)
├── Referência
└── Autoboxing/Unboxing
```

## Casting Implícito

### Widening Casting

```
WIDENING PATH
byte → short → int → long → float → double
        char ↗
```

### Exemplos

```JAVA
// Conversões automáticas
byte byteNum = 100;
int intNum = byteNum; // byte para int

int intValue = 10;
double doubleValue = intNum; // int para double
```

## Casting Explícito

### Narrowing Casting

```
NARROWING PATH
double → float → long → int → short → byte
                        ↘ char
```

### Exemplos

```JAVA
// Conversões manuais
double doubleNum = 9.78;
int intNum = (int) doubleNum; // double para int

int largeNum = 130;
byte byteNum = (byte) largeNum; // int para byte
```

## Casting de Referência

### Upcasting

```JAVA
// Classe pai para filho
class Animal {}
class Gato extends Animal {}

Animal animal = new Gato(); // Upcast automático
```

### Downcasting

```JAVA
// Filho para pai (requer verificação)
Animal animal = new Gato();
if (animal instanceof Gato) {
    Gato gato = (Gato) animal; // Downcast explícito
}
```

## Autoboxing e Unboxing

### Autoboxing

```JAVA
// Primitivo para Wrapper
int primitivo = 42;
Integer wrapper = primitivo; // Autoboxing
```

### Unboxing

```JAVA
// Wrapper para primitivo
Integer wrapper = 42;
int primitivo = wrapper; // Unboxing
```

## Verificações de Tipo

### instanceof

```JAVA
Object obj = "teste";
if (obj instanceof String) {
    String str = (String) obj;
    System.out.println(str.length());
}
```

### Pattern Matching (Java 16+)

```JAVA
Object obj = "teste";
if (obj instanceof String str) {
    System.out.println(str.length());
}
```

## Conversões Comuns

### String Conversions

```JAVA
// String para número
String strNum = "42";
int num = Integer.parseInt(strNum);
double dNum = Double.parseDouble("3.14");

// Número para String
String str1 = String.valueOf(42);
String str2 = Integer.toString(42);
```

## Perda de Dados

### Exemplos

```JAVA
// Perda de precisão
int x = 128;
byte b = (byte) x; // Overflow: -128

double pi = 3.14159;
int iPi = (int) pi; // Truncado: 3
```

## Boas Práticas

### Recomendações

```
CASTING GUIDELINES
├── Prefira casting implícito
├── Verifique antes de downcast
├── Evite casting numérico arriscado
└── Use métodos de conversão apropriados
```

### Exemplo Seguro

```JAVA
// Verificação de range
long longValue = 42L;
if (longValue >= Integer.MIN_VALUE && 
    longValue <= Integer.MAX_VALUE) {
    int intValue = (int) longValue;
}
```

## Casos Especiais

### Char Casting

```JAVA
// Char para número
char ch = 'A';
int ascii = ch; // 65

// Número para char
int num = 66;
char character = (char) num; // 'B'
```

## Próximos Passos

### Tópicos Relacionados

* [Palavra-chave var](var-keyword.html)

* [Operadores](operators.html)

* [Tipos de Dados](variables.html)

[Palavra-chave var](var-keyword.html)

Tip:

"O type casting é como hackear a Matrix - transformando dados de uma forma para outra."



# Palavra-chave var

```
VAR KEYWORD
├── Inferência de Tipo
├── Restrições
├── Usos Comuns
└── Boas Práticas
```

## Introdução

### O que é var?

```JAVA
// Inferência de tipo local
var mensagem = "Conexão estabelecida";
var contador = 0;
var lista = new ArrayList<String>();
```

## Inferência de Tipo

### Como Funciona

```JAVA
// O compilador infere o tipo
var numero = 42; // int
var texto = "Matrix"; // String
var decimal = 3.14; // double
```

### Tipos Inferidos

```JAVA
// Tipos complexos
var mapa = new HashMap<String, Integer>();
var executor = Executors.newFixedThreadPool(10);
var padrao = Pattern.compile("\\w+");
```

## Restrições

### Onde Não Usar

```JAVA
// Não permitido:
var campo; // Sem inicialização
var = "valor"; // Sem nome
var[] array = new int[10]; // Arrays
var método() { } // Retorno de método
```

### Limitações

```
RESTRICTIONS
├── Variáveis de classe
├── Parâmetros de método
├── Retorno de método
└── Catch blocks
```

## Usos Comuns

### Loops

```JAVA
// Iteração em collections
for (var item : lista) {
    System.out.println(item);
}

// Loop tradicional
for (var i = 0; i < 10; i++) {
    // código
}
```

### Lambda

```JAVA
// Com var em parâmetros (Java 11+)
Consumer<String> consumer = (@NonNull var s) -> 
    System.out.println(s);
```

### Try-with-resources

```JAVA
try (var arquivo = new FileInputStream
```



# Operadores em Java

## Visão Geral

```
OPERATOR TYPES
├── Aritméticos (+, -, *, /, %)
├── Lógicos (&&, ||, !)
└── Bit a Bit (&, |, ^, ~, <<, >>, >>>)
```

## Categorias Principais

### Classificação

```
OPERATOR CATEGORIES
├── Unários (++, --, !, ~)
├── Binários (+, -, *, /, &, |)
└── Ternário (?:)
```

## Precedência

### Ordem de Execução

```
PRECEDENCE ORDER
├── Unários (++, --, !)
├── Multiplicativos (*, /, %)
├── Aditivos (+, -)
├── Shift (<<, >>, >>>)
├── Relacionais (<, >, <=, >=)
├── Igualdade (==, !=)
├── Bit a Bit (&, ^, |)
├── Lógicos (&&, ||)
└── Atribuição (=, +=, -=, etc)
```

## Próximos Passos

### Tópicos Detalhados

* [Operadores Aritméticos](arithmetic.html)

* [Operadores Lógicos](logical.html)

* [Operadores Bit a Bit](bitwise.html)

[Operadores Aritméticos](arithmetic.html)

Tip:

"Os operadores são como os comandos básicos da Matrix - eles transformam e manipulam os dados em sua forma mais fundamental."



# Operadores Aritméticos

## Operadores Básicos

### Operações Fundamentais

```JAVA
// Adição
int soma = 5 + 3;        // 8

// Subtração
int diferenca = 10 - 4;  // 6

// Multiplicação
int produto = 3 * 4;     // 12

// Divisão
int quociente = 15 / 3;  // 5

// Módulo (resto)
int resto = 17 % 5;      // 2
```

## Incremento e Decremento

### Pré e Pós

```JAVA
int x = 5;
int y = ++x;  // x = 6, y = 6 (pré-incremento)
int z = x++;  // z = 6, x = 7 (pós-incremento)

int a = 5;
int b = --a;  // a = 4, b = 4 (pré-decremento)
int c = a--;  // c = 4, a = 3 (pós-decremento)
```

## Operadores Compostos

### Atribuição com Operação

```JAVA
int valor = 10;
valor += 5;   // valor = valor + 5
valor -= 3;   // valor = valor - 3
valor *= 2;   // valor = valor * 2
valor /= 4;   // valor = valor / 4
valor %= 3;   // valor = valor % 3
```

## Próximos Passos

### Tópicos Relacionados

* [Operadores Lógicos](logical.html)

* [Operadores Bit a Bit](bitwise.html)

* [Expressões](null)

[Operadores Lógicos](logical.html)



# Operadores Lógicos

## Operadores Básicos

### Booleanos

```JAVA
// AND lógico (&&)
boolean and = true && false;  // false

// OR lógico (||)
boolean or = true || false;   // true

// NOT lógico (!)
boolean not = !true;         // false
```

## Curto-Circuito

### Avaliação Otimizada

```JAVA
// AND com curto-circuito
if (obj != null && obj.getValue() > 0) {
    // Segundo termo só é avaliado se obj != null
}

// OR com curto-circuito
if (cache.containsKey(key) || loadFromDatabase()) {
    // loadFromDatabase() só é chamado se necessário
}
```

## Operadores Bit a Bit Booleanos

### Operações sem Curto-Circuito

```JAVA
// AND bit a bit (&)
boolean bitwiseAnd = true & false;

// OR bit a bit (|)
boolean bitwiseOr = true | false;

// XOR bit a bit (^)
boolean xor = true ^ false;
```

## Próximos Passos

### Tópicos Relacionados

* [Operadores Bit a Bit](bitwise.html)

* [Estruturas Condicionais](conditionals.html)

* [Expressões Booleanas](null)

[Operadores Bit a Bit](bitwise.html)



# Operadores Bit a Bit

## Operadores Básicos

### Manipulação de Bits

```JAVA
// AND bit a bit (&)
int and = 12 & 5;   // 1100 & 0101 = 0100 (4)

// OR bit a bit (|)
int or = 12 | 5;    // 1100 | 0101 = 1101 (13)

// XOR bit a bit (^)
int xor = 12 ^ 5;   // 1100 ^ 0101 = 1001 (9)

// NOT bit a bit (~)
int not = ~12;      // ~1100 = ...11110011
```

## Operadores de Deslocamento

### Shift de Bits

```JAVA
// Shift left (<<)
int left = 8 << 2;    // 1000 -> 100000 (32)

// Shift right (>>)
int right = 8 >> 2;   // 1000 -> 0010 (2)

// Shift right sem sinal (>>>)
int unsignedRight = -8 >>> 2;  // Preenche com 0
```

## Aplicações Práticas

### Uso Comum

```JAVA
// Flags de bit
int FLAG_READ = 1;     // 0001
int FLAG_WRITE = 2;    // 0010
int FLAG_EXECUTE = 4;  // 0100

// Combinando flags
int permissions = FLAG_READ | FLAG_WRITE;  // 0011

// Verificando flags
boolean canRead = (permissions & FLAG_READ) != 0;
```

### Otimizações

```JAVA
// Multiplicação por 2
int multiply = num << 1;  // Equivalente a num * 2

// Divisão por 2
int divide = num >> 1;    // Equivalente a num / 2

// Alternância de bit
int toggleBit = num ^ (1 << position);
```

## Máscaras de Bits

### Técnicas de Mascaramento

```JAVA
// Máscara para últimos 8 bits
int mask = 0xFF;

// Aplicando máscara
int lastByte = number & mask;

// Limpando bits
int clearBits = number & ~mask;
```

## Próximos Passos

### Tópicos Relacionados

* [Tipos Primitivos](primitive-types.html)

* [Operadores Lógicos](logical.html)

[Tipos Primitivos](primitive-types.html)

Tip:

"Os operadores bit a bit são como os comandos de baixo nível da Matrix - manipulando a realidade digital bit por bit."



# Internacionalização (i18n)

## Conceitos Básicos

### Locale

```JAVA
// Criando Locales
Locale brLocale = new Locale("pt", "BR");
Locale usLocale = Locale.US;
Locale currentLocale = Locale.getDefault();

// Definindo Locale padrão
Locale.setDefault(brLocale);
```

### ResourceBundle

```JAVA
// Arquivo: messages_pt_BR.properties
// mensagem=Olá, {0}!

// Arquivo: messages_en_US.properties
// message=Hello, {0}!

ResourceBundle bundle = ResourceBundle.getBundle("messages", brLocale);
String msg = bundle.getString("mensagem");
```

## Textos e Mensagens

### Properties Files

```PROPERTIES
# messages_pt_BR.properties
welcome=Bem-vindo
error.notfound=Não encontrado
app.title=Minha Aplicação

# messages_en_US.properties
welcome=Welcome
error.notfound=Not found
app.title=My Application
```

### Uso em Código

```JAVA
public class I18nDemo {
    private ResourceBundle messages;
    
    public void setLocale(Locale locale) {
        messages = ResourceBundle.getBundle("messages", locale);
    }
    
    public String getMessage(String key) {
        return messages.getString(key);
    }
}
```

## Boas Práticas

### Organização

* Separar textos em arquivos properties

* Usar chaves hierárquicas

* Manter consistência entre traduções

* Documentar contexto das mensagens

### Dicas de Implementação

```JAVA
// Uso de MessageFormat
String pattern = messages.getString("welcome.user");
MessageFormat formatter = new MessageFormat(pattern);
String result = formatter.format(new Object[]{"João"});

// Fallback para locale padrão
try {
    String msg = messages.getString("key");
} catch (MissingResourceException e) {
    msg = defaultMessages.getString("key");
}
```

## Frameworks e Ferramentas

### Spring Framework

```JAVA
@Configuration
public class I18nConfig {
    @Bean
    public MessageSource messageSource() {
        ResourceBundleMessageSource source = new ResourceBundleMessageSource();
        source.setBasenames("messages");
        source.setDefaultEncoding("UTF-8");
        return source;
    }
}
```

### Ferramentas de Gestão

* POEditor

* Crowdin

* Lokalise

* Trados

## Testes

### Testando Internacionalização

```JAVA
@Test
public void testMessageInDifferentLocales() {
    ResourceBundle ptBR = ResourceBundle.getBundle("messages", new Locale("pt", "BR"));
    ResourceBundle enUS = ResourceBundle.getBundle("messages", Locale.US);
    
    assertEquals("Olá", ptBR.getString("greeting"));
    assertEquals("Hello", enUS.getString("greeting"));
}
```

## Próximos Passos

* [Formatação de Datas](date-formatting.html)

* [Formatação de Números](number-formatting.html)



# Formatação de Datas

## DateTimeFormatter

### Padrões Básicos

```JAVA
// Formatadores predefinidos
DateTimeFormatter isoDate = DateTimeFormatter.ISO_DATE;
DateTimeFormatter isoTime = DateTimeFormatter.ISO_TIME;
DateTimeFormatter isoDateTime = DateTimeFormatter.ISO_DATE_TIME;

// Formatação básica
LocalDate date = LocalDate.now();
String formatted = date.format(isoDate);  // 2024-01-20
```

### Padrões Customizados

```JAVA
// Criando formatadores customizados
DateTimeFormatter custom = DateTimeFormatter.ofPattern("dd/MM/yyyy");
DateTimeFormatter withTime = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");

// Aplicando formatação
LocalDateTime now = LocalDateTime.now();
String result = now.format(custom);       // 20/01/2024
```

## Localização

### Formatação por Locale

```JAVA
// Formatadores localizados
DateTimeFormatter brFormat = 
    DateTimeFormatter.ofPattern("dd/MM/yyyy")
                    .withLocale(new Locale("pt", "BR"));

DateTimeFormatter usFormat = 
    DateTimeFormatter.ofPattern("MM/dd/yyyy")
                    .withLocale(Locale.US);
```

### Nomes Localizados

```JAVA
// Meses e dias da semana
DateTimeFormatter monthFormat = 
    DateTimeFormatter.ofPattern("MMMM", new Locale("pt", "BR"));
String mes = monthFormat.format(LocalDate.now());  // "janeiro"
```

## Parsing

### Conversão de Strings

```JAVA
// Parse básico
String dateStr = "2024-01-20";
LocalDate date = LocalDate.parse(dateStr);

// Parse com formato específico
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
LocalDate customDate = LocalDate.parse("20/01/2024", formatter);
```

### Tratamento de Erros

```JAVA
try {
    LocalDate date = LocalDate.parse("data-inválida");
} catch (DateTimeParseException e) {
    System.err.println("Formato de data inválido");
}
```

## Casos Especiais

### Zonas de Tempo

```JAVA
// Formatação com timezone
ZonedDateTime zdt = ZonedDateTime.now();
DateTimeFormatter zoneFormat = 
    DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm z");
String withZone = zdt.format(zoneFormat);  // "20/01/2024 15:30 BRT"
```

### Períodos e Durações

```JAVA
// Formatando períodos
Period period = Period.between(
    LocalDate.of(2023, 1, 1),
    LocalDate.of(2024, 1, 1)
);
// P1Y (ISO-8601)

// Formatando durações
Duration duration = Duration.between(
    LocalDateTime.now(),
    LocalDateTime.now().plusHours(2)
);
// PT2H (ISO-8601)
```

## Boas Práticas

### Constantes de Formato

```JAVA
public class DateUtils {
    public static final DateTimeFormatter BR_DATE = 
        DateTimeFormatter.ofPattern("dd/MM/yyyy");
    
    public static final DateTimeFormatter BR_DATE_TIME = 
        DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
}
```

### Validação

```JAVA
public boolean isValidDate(String dateStr, DateTimeFormatter formatter) {
    try {
        LocalDate.parse(dateStr, formatter);
        return true;
    } catch (DateTimeParseException e) {
        return false;
    }
}
```

## Próximos Passos

* [Formatação de Números](number-formatting.html)

* [Internacionalização](i18n.html)



# Formatação de Números

## NumberFormat

### Formatação Básica

```JAVA
// Formatadores básicos
NumberFormat nf = NumberFormat.getInstance();
NumberFormat currencyFormat = NumberFormat.getCurrencyInstance();
NumberFormat percentFormat = NumberFormat.getPercentInstance();

// Exemplos
double number = 1234.56;
String formatted = nf.format(number);          // "1,234.56"
String currency = currencyFormat.format(number);// "$1,234.56"
String percent = percentFormat.format(0.75);   // "75%"
```

### Localização

```JAVA
// Formatadores localizados
Locale brLocale = new Locale("pt", "BR");
NumberFormat brCurrency = NumberFormat.getCurrencyInstance(brLocale);
String brValue = brCurrency.format(1234.56);   // "R$ 1.234,56"

Locale frLocale = new Locale("fr", "FR");
NumberFormat frCurrency = NumberFormat.getCurrencyInstance(frLocale);
String frValue = frCurrency.format(1234.56);   // "1 234,56 €"
```

## DecimalFormat

### Padrões Customizados

```JAVA
// Padrões de formatação
DecimalFormat df = new DecimalFormat("#,###.##");
String num = df.format(1234567.89);    // "1,234,567.89"

// Zeros à esquerda
DecimalFormat df2 = new DecimalFormat("000000.00");
String padded = df2.format(123.4);     // "000123.40"

// Sufixos e prefixos
DecimalFormat df3 = new DecimalFormat("€ #,###.00");
String euro = df3.format(1234.56);     // "€ 1,234.56"
```

### Símbolos Customizados

```JAVA
DecimalFormatSymbols symbols = new DecimalFormatSymbols(Locale.US);
symbols.setDecimalSeparator(',');
symbols.setGroupingSeparator('.');

DecimalFormat custom = new DecimalFormat("#,###.##", symbols);
String result = custom.format(1234.56); // "1.234,56"
```

## Parsing

### Conversão de Strings

```JAVA
// Parse básico
NumberFormat nf = NumberFormat.getInstance();
Number num = nf.parse("1,234.56");

// Parse com locale
NumberFormat frFormat = NumberFormat.getInstance(Locale.FRANCE);
Number frNum = frFormat.parse("1 234,56");

// Tratamento de erros
try {
    Number value = nf.parse("invalid");
} catch (ParseException e) {
    System.err.println("Formato inválido");
}
```

## Casos Especiais

### Números Científicos

```JAVA
// Notação científica
DecimalFormat scientific = new DecimalFormat("0.###E0");
String sci = scientific.format(123456.789); // "1.235E5"

// Precisão customizada
DecimalFormat precise = new DecimalFormat("0.000000");
String precision = precise.format(Math.PI); // "3.141593"
```

### Arredondamento

```JAVA
DecimalFormat df = new DecimalFormat("#,###.##");
df.setRoundingMode(RoundingMode.HALF_UP);

String rounded = df.format(123.456);  // "123.46"
```

## Boas Práticas

### Constantes de Formato

```JAVA
public class NumberUtils {
    public static final DecimalFormat MONEY_FORMAT = 
        new DecimalFormat("#,##0.00");
    
    public static final DecimalFormat PERCENT_FORMAT = 
        new DecimalFormat("#.##%");
}
```

### Validação

```JAVA
public boolean isValidNumber(String numStr, NumberFormat format) {
    try {
        format.parse(numStr);
        return true;
    } catch (ParseException e) {
        return false;
    }
}
```

## Frameworks e Bibliotecas

### Java Money API

```JAVA
// Usando JavaMoney
MonetaryAmount amount = Money.of(1234.56, "USD");
MonetaryAmountFormat format = 
    MonetaryFormats.getAmountFormat(Locale.US);
String formatted = format.format(amount);
```

## Próximos Passos

* [Internacionalização](i18n.html)

* [Formatação de Datas](date-formatting.html)



# Strings em Java

## Visão Geral

```
STRING CONCEPTS
├── Imutabilidade
├── Pool de Strings
├── Concatenação
└── Comparação
```

## Criação de Strings

### Formas de Inicialização

```JAVA
// Literal
String comando = "EXECUTE";

// Construtor
String status = new String("ONLINE");

// Pool vs Heap
String s1 = "MATRIX";         // Pool de Strings
String s2 = new String("MATRIX"); // Heap
```

## Operações Básicas

### Manipulação

```JAVA
String codigo = "NET_RUNNER";
int tamanho = codigo.length();     // 10
char primeiro = codigo.charAt(0);   // 'N'
String sub = codigo.substring(0,3); // "NET"
```

## Próximos Passos

### Tópicos Detalhados

* [Métodos de String](string-methods.html)

* [StringBuilder](string-builder.html)

* [Formatação de Strings](string-formatting.html)

[Métodos de String](string-methods.html)

Tip:

"Strings são como os dados criptografados da Matrix - precisam ser manipulados com precisão e eficiência."



# Métodos de String

## Métodos de Busca

### Localização

```JAVA
String texto = "CYBERPUNK_2077";

// Busca
int posicao = texto.indexOf("PUNK");    // 5
int ultimo = texto.lastIndexOf("7");     // 12
boolean contem = texto.contains("CYBER"); // true
```

## Métodos de Transformação

### Modificação

```JAVA
String codigo = "NetRunner";

// Transformações
String maiusculo = codigo.toUpperCase(); // "NETRUNNER"
String minusculo = codigo.toLowerCase(); // "netrunner"
String semEspacos = codigo.trim();      // Remove espaços
String[] partes = codigo.split("R");    // ["Net", "unner"]
```

## Métodos de Comparação

### Verificação

```JAVA
String s1 = "MATRIX";
String s2 = "matrix";

// Comparações
boolean igual = s1.equals(s2);           // false
boolean ignoraCase = s1.equalsIgnoreCase(s2); // true
int comparacao = s1.compareTo(s2);       // Comparação lexicográfica
```

## Métodos de Substituição

### Alteração

```JAVA
String log = "Error:404:NotFound";

// Substituições
String novo = log.replace(":", "-");     // "Error-404-NotFound"
String primeiro = log.replaceFirst(":", "-"); // "Error-404:NotFound"
```

## Próximos Passos

### Tópicos Relacionados

* [StringBuilder](string-builder.html)

* [Formatação de Strings](string-formatting.html)

* [Expressões Regulares](null)

[StringBuilder](string-builder.html)



# StringBuilder

## Conceitos Básicos

### Criação

```JAVA
// Inicialização
StringBuilder buffer = new StringBuilder();
StringBuilder preset = new StringBuilder("INIT:");
StringBuilder sized = new StringBuilder(32);
```

## Operações Principais

### Manipulação

```JAVA
StringBuilder log = new StringBuilder();

// Adição
log.append("STATUS: ")    // Concatenação
   .append("ONLINE")      // Encadeamento
   .append(" - ")
   .append(2077);

// Inserção
log.insert(0, "[LOG] ");  // Início
log.insert(6, "DEBUG ");  // Meio

// Remoção
log.delete(0, 5);         // Range
log.deleteCharAt(10);     // Caractere único

// Reversão
log.reverse();            // Inverte a string
```

## Performance

### Comparação com String

```JAVA
// Má prática (String)
String result = "";
for (int i = 0; i < 1000; i++) {
    result += "Data";  // Cria nova String cada vez
}

// Boa prática (StringBuilder)
StringBuilder builder = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    builder.append("Data");  // Modifica o mesmo objeto
}
String result = builder.toString();
```

## Métodos Úteis

### Funcionalidades Adicionais

```JAVA
StringBuilder cmd = new StringBuilder("EXECUTE");

// Capacidade
int cap = cmd.capacity();     // Capacidade atual
cmd.ensureCapacity(100);      // Garante capacidade mínima

// Modificação
cmd.setCharAt(0, 'e');       // Modifica caractere
cmd.setLength(4);            // Trunca ou expande
cmd.replace(0, 2, "RE");     // Substitui range
```

## Próximos Passos

### Tópicos Relacionados

* [Formatação de Strings](string-formatting.html)

* [StringBuffer](null)

* [Performance](null)

[Formatação de Strings](string-formatting.html)



# Formatação de Strings

## String.format()

### Sintaxe Básica

```JAVA
// Formatação básica
String msg = String.format("Usuário: %s, ID: %d", "Neo", 1337);

// Números
String num = String.format("%.2f", 3.14159);  // "3.14"
String hex = String.format("%x", 255);        // "ff"
```

## System.out.printf()

### Saída Formatada

```JAVA
// Impressão formatada
System.out.printf("Status: %s%n", "ONLINE");

// Múltiplos argumentos
System.out.printf("X: %d, Y: %d%n", 10, 20);
```

## Especificadores de Formato

### Tipos Comuns

```JAVA
// Strings e caracteres
%s  // String
%c  // Caractere
%n  // Nova linha

// Números
%d  // Inteiro decimal
%f  // Ponto flutuante
%e  // Notação científica
%x  // Hexadecimal
```

## Flags de Formatação

### Modificadores

```JAVA
// Alinhamento e preenchimento
String align = String.format("|%-10s|", "LEFT");   // Alinha à esquerda
String pad = String.format("%05d", 42);            // "00042"

// Números
String prec = String.format("%.3f", 3.14159);      // "3.142"
String group = String.format("%,d", 1000000);      // "1,000,000"
```

## MessageFormat

### Formatação Complexa

```JAVA
import java.text.MessageFormat;

// Padrão de mensagem
String pattern = "User {0} logged in at {1}";
String msg = MessageFormat.format(pattern, "Trinity", "12:00");

// Números e datas
MessageFormat mf = new MessageFormat("Balance: {0,number,currency}");
String balance = mf.format(new Object[]{1234.56});
```

## Próximos Passos

### Tópicos Relacionados

* [Internacionalização](i18n.html)

* [Formatação de Datas](date-formatting.html)

* [Formatação de Números](number-formatting.html)

[Internacionalização](i18n.html)

Tip:

"A formatação de strings é como a interface da Matrix - a forma como apresentamos os dados ao mundo real."



# Projetos Básicos

Os projetos nesta seção aplicam os conceitos fundamentais de Java em cenários práticos inspirados no universo cyberpunk.

## Visão Geral dos Projetos

```MERMAID
graph LR
    A[Matrix Code Generator] --> D[Visualização de Dados]
    B[Cyber Deck Simulator] --> E[Interface de Comando]
    C[Data Encryptor] --> F[Segurança de Dados]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#33ccff
    style E fill:#1a1a1a,stroke:#33ccff
    style F fill:#1a1a1a,stroke:#33ccff
```

## Objetivos de Aprendizado

### Matrix Code Generator

* Manipulação de strings e caracteres

* Loops e controle de fluxo

* Temporização básica

* Saída formatada no console

* Arrays unidimensionais e bidimensionais

### Cyber Deck Simulator

* Entrada e saída do usuário

* Estruturas condicionais

* Comandos e argumentos

* Formatação de terminal

* Processamento de strings

### Data Encryptor

* Operações com bytes

* Algoritmos básicos

* Manipulação de arquivos

* Geração de chaves

* Conversão de tipos

## Habilidades Desenvolvidas

| Projeto |Conceitos Principais |Dificuldade |
----------------------------------------------
| Matrix Code Generator |Strings, Arrays, Loops |⭐⭐ |
| Cyber Deck Simulator |I/O, Condicionais |⭐⭐ |
| Data Encryptor |Bytes, Arquivos |⭐⭐⭐ |

## Pré-requisitos

```JAVA
// Conhecimentos necessários
public class Prerequisites {
    // Sintaxe básica
    String[] fundamentals = {
        "Variáveis",
        "Tipos de dados",
        "Operadores",
        "Estruturas de controle"
    };
    
    // Ambiente de desenvolvimento
    boolean ready = hasJDK() && hasIDE();
}
```

## Estrutura dos Projetos

```
PROJETO
├── src/
│   ├── main/
│   │   └── java/
│   │       └── com/
│   │           └── netrunner/
│   │               └── project/
│   │                   ├── Main.java
│   │                   └── core/
│   └── test/
│       └── java/
└── README.md
```

## Dicas de Implementação

* Comece com uma versão básica funcional

* Adicione recursos gradualmente

* Teste cada nova funcionalidade

* Mantenha o código organizado

* Documente as partes importantes

## Desafios Extras

### Matrix Code Generator

* Adicionar cores diferentes

* Implementar velocidades variáveis

* Criar padrões personalizados

### Cyber Deck Simulator

* Adicionar novos comandos

* Implementar histórico

* Criar aliases para comandos

### Data Encryptor

* Suportar múltiplos algoritmos

* Adicionar compressão

* Implementar assinaturas digitais

## Recursos Adicionais

### Referências

* [Java Documentation](https://docs.oracle.com/en/java/)

* [Console Colors](https://stackoverflow.com/questions/5762491/how-to-print-color-in-console-using-system-out-println)

* [File Handling in Java](https://www.w3schools.com/java/java_files.asp)

### Ferramentas Úteis

* Terminal: [JLine](https://github.com/jline/jline3)

* Criptografia: [Bouncy Castle](https://www.bouncycastle.org/)

* Logging: [SLF4J](http://www.slf4j.org/)

## Próximos Passos

Após completar estes projetos básicos, você estará preparado para:

* Explorar projetos mais complexos

* Aprender sobre design patterns

* Trabalhar com bibliotecas externas

* Desenvolver aplicações mais robustas

```

## Conclusão

Estes projetos fornecem uma base sólida em programação Java através de aplicações práticas e envolventes. Cada projeto pode ser expandido e personalizado de acordo com seus interesses e necessidades de aprendizado.
```



# Calculadora Básica

## Conceitos Aplicados

* Variáveis primitivas (`int`, `double`)

* Operadores aritméticos

* Type casting

* Palavra-chave `var`

## Implementação Base

```JAVA
public class Calculator {
    // Usando tipos primitivos para armazenar resultados
    private double result;
    
    // Demonstração de operadores aritméticos básicos
    public double add(double a, double b) {
        result = a + b;
        return result;
    }
    
    public double subtract(double a, double b) {
        result = a - b;
        return result;
    }
    
    // Exemplo de casting implícito
    public double multiply(int a, double b) {
        result = a * b; // int é automaticamente convertido para double
        return result;
    }
    
    // Demonstração de var com inferência de tipo
    public double divide(double a, double b) {
        var quotient = a / b; // var infere double
        result = quotient;
        return result;
    }
}
```

## Exercícios Propostos

1. Implementar operações com diferentes tipos numéricos

2. Praticar conversões explícitas entre tipos

3. Explorar precedência de operadores

4. Usar var em diferentes contextos

## Desafios

1. Adicionar operações com números inteiros e decimais

2. Implementar conversões entre tipos numéricos

3. Criar operações com diferentes precedências



# Conversor de Temperatura

## Conceitos Aplicados

* Tipos primitivos (`double`)

* Operadores aritméticos

* Type casting

* Operadores lógicos

## Implementação Base

```JAVA
public class TemperatureConverter {
    // Demonstração de constantes com tipos primitivos
    private static final double ABSOLUTE_ZERO_C = -273.15;
    
    // Uso de operadores aritméticos e type casting
    public double celsiusToFahrenheit(double celsius) {
        return (celsius * 9/5) + 32;
    }
    
    public double fahrenheitToCelsius(double fahrenheit) {
        return (fahrenheit - 32) * 5/9;
    }
    
    // Demonstração de operadores lógicos
    public boolean isValidTemperature(double celsius) {
        return celsius >= ABSOLUTE_ZERO_C;
    }
}
```

## Exercícios Propostos

1. Trabalhar com diferentes escalas de precisão

2. Implementar validações usando operadores lógicos

3. Praticar conversões entre tipos numéricos

4. Explorar formatação de números decimais

## Desafios

1. Adicionar validações de temperatura

2. Implementar arredondamento de resultados

3. Criar verificações de limites físicos



# Manipulador de Strings

## Conceitos Aplicados

* String como tipo de referência

* Métodos de String

* StringBuilder

* String formatting

## Implementação Base

```JAVA
public class StringManipulator {
    // Demonstração de String como tipo de referência
    private String text;
    
    public StringManipulator(String text) {
        this.text = text;
    }
    
    // Uso de métodos de String
    public String toUpperCase() {
        return text.toUpperCase();
    }
    
    // Demonstração de StringBuilder
    public String reverse() {
        StringBuilder builder = new StringBuilder(text);
        return builder.reverse().toString();
    }
    
    // Exemplo de String formatting
    public String format() {
        return String.format("Texto: %s, Tamanho: %d", 
                           text, text.length());
    }
}
```

## Exercícios Propostos

1. Explorar métodos da classe String

2. Praticar concatenação com StringBuilder

3. Implementar diferentes formatos de string

4. Trabalhar com substrings e caracteres

## Desafios

1. Criar diferentes formatos de saída

2. Implementar manipulações de texto

3. Otimizar operações com StringBuilder



# Controle de Fluxo

![Control Flow Banner](control-flow-banner.png)

```
>> Inicializando módulo de controle...
>> Carregando padrões de decisão...
>> Estabelecendo loops de execução...
```

## Visão Geral

O controle de fluxo é fundamental para direcionar a execução do seu código. Como um netrunner navegando pela matrix, você precisa tomar decisões e repetir ações de forma eficiente.

```MERMAID
graph TD
    A[Entrada] --> B{Decisão}
    B -->|Condição 1| C[Execução A]
    B -->|Condição 2| D[Execução B]
    C --> E[Próximo Passo]
    D --> E
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#00ff00
```

## Elementos Principais

### 1. Estruturas Condicionais

* if/else

* switch/case

* operador ternário

### 2. Estruturas de Repetição

* while

* do-while

* for

* for-each

### 3. Controle de Fluxo

* break

* continue

* return

## Exemplo Prático

```JAVA
public class AccessControl {
    private static final int MAX_ATTEMPTS = 3;
    
    public void validateAccess(String code) {
        int attempts = 0;
        
        while (attempts < MAX_ATTEMPTS) {
            if (code.equals("MATRIX")) {
                System.out.println("Acesso concedido");
                return;
            } else {
                attempts++;
                if (attempts == MAX_ATTEMPTS) {
                    System.out.println("Sistema bloqueado");
                    break;
                }
                System.out.println("Tentativa " + attempts);
                continue;
            }
        }
    }
}
```

## Padrões de Uso

### Estrutura Condicional

```JAVA
if (condicao) {
    // código para condição verdadeira
} else if (outraCondicao) {
    // código para outra condição
} else {
    // código para nenhuma condição verdadeira
}
```

### Loop com For

```JAVA
for (int i = 0; i < 10; i++) {
    // código a ser repetido
    if (condicaoParada) {
        break;
    }
}
```

### Switch Expression (Java 14+)

```JAVA
String status = switch (code) {
    case 200 -> "Success";
    case 404 -> "Not Found";
    case 500 -> "Server Error";
    default -> "Unknown";
};
```

## Boas Práticas

1. Clareza nas Condições

* Use nomes descritivos

* Evite negações complexas

* Mantenha condições simples

2. Estrutura dos Loops

* Defina condições de parada claras

* Evite loops infinitos

* Use o tipo correto de loop

3. Otimização

* Minimize aninhamentos

* Use break/continue com critério

* Prefira switch para múltiplas condições

## Próximos Passos

Explore cada conceito em detalhes:

* [Condicionais](conditionals.html)

* [Loops](loops.html)

* [Switch Expressions](switch-expressions.html)

* [Pattern Matching](pattern-matching.html)

[Condicionais](conditionals.html)

Tip:

"O controle de fluxo é como navegar pela Matrix - você precisa saber quando dobrar as regras e quando quebrá-las."



# Estruturas Condicionais

```
>> Inicializando sistema de decisão...
>> Carregando árvores lógicas...
>> Estabelecendo caminhos de execução...
```

## Visão Geral

As estruturas condicionais são como os checkpoints da Matrix - elas determinam quais caminhos seu código pode seguir.

## Estruturas Básicas

### 1. if-else

```JAVA
if (condicao) {
    // código executado se verdadeiro
} else {
    // código executado se falso
}
```

#### Exemplo Prático

```JAVA
int securityLevel = 5;
if (securityLevel >= 4) {
    System.out.println("Acesso concedido ao mainframe");
} else {
    System.out.println("Acesso negado");
}
```

### 2. else-if

```JAVA
if (condicao1) {
    // código para condição 1
} else if (condicao2) {
    // código para condição 2
} else {
    // código padrão
}
```

#### Exemplo Prático

```JAVA
int threatLevel = 3;
if (threatLevel == 1) {
    System.out.println("Alerta Verde");
} else if (threatLevel == 2) {
    System.out.println("Alerta Amarelo");
} else {
    System.out.println("Alerta Vermelho");
}
```

### 3. Operador Ternário

```JAVA
resultado = (condicao) ? valorSeVerdadeiro : valorSeFalso;
```

#### Exemplo Prático

```JAVA
int energia = 50;
String status = (energia > 20) ? "Online" : "Offline";
```

## Operadores de Comparação

| Operador |Descrição |
-----------------------
| `==` |Igual a |
| `!=` |Diferente de |
| `>` |Maior que |
| `<` |Menor que |
| `>=` |Maior ou igual |
| `<=` |Menor ou igual |

## Operadores Lógicos

| Operador |Descrição |
-----------------------
| `&&` |AND lógico |
| `\\|\\|` |OR lógico |
| `!` |NOT lógico |

## Boas Práticas

1. Clareza nas Condições

```JAVA
// Ruim
if (x == 1 && y == 2 || z == 3 && !w) { }

// Bom
boolean isValidX = (x == 1);
boolean isValidY = (y == 2);
boolean isValidZ = (z == 3 && !w);
if (isValidX && isValidY || isValidZ) { }
```

2. Evite Aninhamento Excessivo

```JAVA
// Evite
if (a) {
    if (b) {
        if (c) {
            // código
        }
    }
}

// Prefira
if (!a || !b || !c) return;
// código
```

3. Use Chaves Sempre

```JAVA
// Evite
if (condicao) comando;

// Prefira
if (condicao) {
    comando;
}
```

## Padrões Avançados

### Switch Expression (Java 14+)

```JAVA
String mensagem = switch (nivelAcesso) {
    case 1 -> "Acesso Básico";
    case 2 -> "Acesso Intermediário";
    case 3 -> "Acesso Total";
    default -> "Sem Acesso";
};
```

### Pattern Matching (Preview)

```JAVA
if (obj instanceof String s && s.length() > 5) {
    System.out.println("String longa: " + s);
}
```

## Exercícios Práticos

1. Sistema de Autenticação

```JAVA
public boolean verificarAcesso(String usuario, int nivel) {
    if (usuario == null || usuario.isEmpty()) {
        return false;
    }
    return nivel >= 3 && usuario.startsWith("ADMIN_");
}
```

2. Validador de Status

```JAVA
public String verificarStatus(int memoria, int cpu) {
    if (memoria < 10 || cpu > 90) {
        return "CRÍTICO";
    } else if (memoria < 30 || cpu > 70) {
        return "ALERTA";
    }
    return "NORMAL";
}
```

## Próximos Passos

* Explore estruturas de repetição em [Loops](loops.html)

* Aprenda sobre expressões switch em [Switch Expressions](switch-expressions.html)

* Descubra pattern matching em [Pattern Matching](pattern-matching.html)

[Loops](loops.html)



# Estruturas de Repetição

```
>> Iniciando ciclos de execução...
>> Configurando iteradores...
>> Estabelecendo pontos de controle...
```

## Visão Geral

Loops são como rotinas de hack - eles permitem executar operações repetitivas de forma eficiente e controlada.

## Tipos de Loops

### 1. for Loop

```JAVA
for (inicialização; condição; incremento) {
    // código a ser repetido
}
```

#### Exemplo Prático

```JAVA
for (int i = 0; i < 5; i++) {
    System.out.println("Tentativa de acesso: " + i);
}
```

### 2. while Loop

```JAVA
while (condição) {
    // código a ser repetido
}
```

#### Exemplo Prático

```JAVA
int tentativas = 0;
while (tentativas < 3) {
    System.out.println("Tentando conexão...");
    tentativas++;
}
```

### 3. do-while Loop

```JAVA
do {
    // código a ser repetido
} while (condição);
```

#### Exemplo Prático

```JAVA
int senha;
do {
    senha = gerarSenha();
} while (!validarSenha(senha));
```

### 4. for-each Loop

```JAVA
for (tipo elemento : coleção) {
    // código a ser repetido
}
```

#### Exemplo Prático

```JAVA
String[] servidores = {"Alpha", "Beta", "Gamma"};
for (String servidor : servidores) {
    System.out.println("Verificando servidor: " + servidor);
}
```

## Controle de Loop

### break

Interrompe a execução do loop completamente.

```JAVA
for (int i = 0; i < 100; i++) {
    if (detectarIntruso()) {
        break; // Sai do loop imediatamente
    }
}
```

### continue

Pula para a próxima iteração do loop.

```JAVA
for (int porta = 0; porta < 1024; porta++) {
    if (!portaVulneravel(porta)) {
        continue; // Verifica próxima porta
    }
    atacarPorta(porta);
}
```

## Padrões de Uso

### 1. Loop Infinito Controlado

```JAVA
while (true) {
    if (condicaoParada()) {
        break;
    }
    // processamento
}
```

### 2. Loop com Múltiplas Variáveis

```JAVA
for (int i = 0, j = 10; i < j; i++, j--) {
    System.out.printf("i: %d, j: %d%n", i, j);
}
```

### 3. Loop Aninhado

```JAVA
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        System.out.printf("[%d,%d] ", i, j);
    }
    System.out.println();
}
```

## Boas Práticas

1. Use o Loop Adequado

```JAVA
// Para número conhecido de iterações
for (int i = 0; i < tamanho; i++) { }

// Para condição desconhecida
while (temDados()) { }

// Para arrays/collections
for (Elemento e : colecao) { }
```

2. Evite Loop Infinito Acidental

```JAVA
// Ruim - possível loop infinito
while (x > 0) {
    // esqueceu de modificar x
}

// Bom
while (x > 0) {
    x--;
    // processamento
}
```

3. Mantenha Loops Simples

```JAVA
// Evite
for (int i = 0; i < 100; i++) {
    // muito código aqui
}

// Prefira
for (int i = 0; i < 100; i++) {
    processarItem(i);
}
```

## Exemplos Avançados

### 1. Loop com Timer

```JAVA
long inicio = System.currentTimeMillis();
long limite = 5000; // 5 segundos

while (System.currentTimeMillis() - inicio < limite) {
    // processamento limitado por tempo
}
```

### 2. Loop com Retry

```JAVA
int maxTentativas = 3;
int tentativa = 0;

while (tentativa < maxTentativas) {
    try {
        conectar();
        break;
    } catch (Exception e) {
        tentativa++;
        if (tentativa == maxTentativas) {
            throw new RuntimeException("Falha na conexão");
        }
    }
}
```

### 3. Loop com Buffer

```JAVA
StringBuilder buffer = new StringBuilder();
for (int i = 0; i < dados.length; i++) {
    buffer.append(dados[i]);
    if (buffer.length() >= 1000) {
        processarBuffer(buffer.toString());
        buffer.setLength(0);
    }
}
```

## Exercícios Práticos

1. Scanner de Portas

```JAVA
public void scanearPortas(int inicio, int fim) {
    for (int porta = inicio; porta <= fim; porta++) {
        if (portaAberta(porta)) {
            System.out.println("Porta " + porta + " está aberta");
        }
    }
}
```

2. Processador de Dados

```JAVA
public void processarDados(List<String> dados) {
    int processados = 0;
    while (!dados.isEmpty()) {
        String dado = dados.remove(0);
        processar(dado);
        processados++;
        if (processados % 100 == 0) {
            System.out.println("Progresso: " + processados);
        }
    }
}
```

## Próximos Passos

* Aprenda sobre condicionais em [Conditionals](conditionals.html)

* Explore expressões switch em [Switch Expressions](switch-expressions.html)

* Descubra pattern matching em [Pattern Matching](pattern-matching.html)

[Pattern Matching](pattern-matching.html)



# Switch Expressions

```
>> Inicializando sistema de expressões switch...
>> Carregando padrões de correspondência...
>> Estabelecendo rotas de decisão...
```

## Introdução

O switch expression é uma feature moderna do Java que oferece uma forma mais concisa e segura de escrever estruturas de decisão múltipla.

## Sintaxe Básica

### Switch Expression Tradicional

```JAVA
String status = switch (statusCode) {
    case 200 -> "OK";
    case 404 -> "Not Found";
    case 500 -> "Internal Server Error";
    default -> "Unknown Status";
};
```

### Switch com Múltiplos Casos

```JAVA
String category = switch (score) {
    case 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100 -> "A";
    case 80, 81, 82, 83, 84, 85, 86, 87, 88, 89 -> "B";
    case 70, 71, 72, 73, 74, 75, 76, 77, 78, 79 -> "C";
    default -> "F";
};
```

## Recursos Avançados

### Yield

```JAVA
String message = switch (level) {
    case "INFO" -> {
        logInfo();
        yield "Information message";
    }
    case "WARNING" -> {
        logWarning();
        yield "Warning message";
    }
    case "ERROR" -> {
        logError();
        yield "Error message";
    }
    default -> "Unknown level";
};
```

### Pattern Matching (Preview)

```JAVA
String typeCheck = switch (obj) {
    case String s -> "Text: " + s;
    case Integer i -> "Number: " + i;
    case Long l -> "Long: " + l;
    case null -> "Null value";
    default -> "Unknown type";
};
```

## Boas Práticas

1. Expressividade

* Use nomes descritivos para variáveis

* Mantenha casos relacionados agrupados

* Evite lógica complexa dentro dos casos

2. Organização

* Ordene os casos de forma lógica

* Agrupe casos similares

* Use comentários para documentar casos complexos

3. Manutenibilidade

* Evite fallthrough entre casos

* Sempre inclua um caso default

* Mantenha a lógica simples e direta

## Exemplos Práticos

### Processador de Status HTTP

```JAVA
HttpResponse processStatus(int code) {
    return switch (code) {
        case 200, 201, 202 -> new SuccessResponse();
        case 400, 401, 403 -> new ClientErrorResponse();
        case 500, 502, 503 -> new ServerErrorResponse();
        default -> new UnknownResponse();
    };
}
```

### Calculadora Simples

```JAVA
double calculate(double a, double b, String operator) {
    return switch (operator) {
        case "+" -> a + b;
        case "-" -> a - b;
        case "*" -> a * b;
        case "/" -> {
            if (b == 0) {
                throw new ArithmeticException("Divisão por zero");
            }
            yield a / b;
        }
        default -> throw new IllegalArgumentException("Operador inválido");
    };
}
```

## Troubleshooting

### Problemas Comuns

1. Esquecimento do Default

```JAVA
// Incorreto - Compilação falha
String result = switch (value) {
    case 1 -> "Um";
    case 2 -> "Dois";
}; // Erro: falta caso default

// Correto
String result = switch (value) {
    case 1 -> "Um";
    case 2 -> "Dois";
    default -> "Outro";
};
```

1. Mistura de Arrow e Block

```JAVA
// Incorreto - Sintaxe inconsistente
String result = switch (value) {
    case 1 -> "Um"
    case 2: yield "Dois";
};

// Correto
String result = switch (value) {
    case 1 -> "Um";
    case 2 -> "Dois";
};
```

## Exercícios Práticos

1. Conversor de Dia da Semana

```JAVA
String getDayName(int day) {
    return switch (day) {
        case 1 -> "Domingo";
        case 2 -> "Segunda";
        case 3 -> "Terça";
        case 4 -> "Quarta";
        case 5 -> "Quinta";
        case 6 -> "Sexta";
        case 7 -> "Sábado";
        default -> "Dia inválido";
    };
}
```

1. Classificador de Notas

```JAVA
String classifyGrade(double grade) {
    return switch ((int) grade / 10) {
        case 10, 9 -> "A";
        case 8 -> "B";
        case 7 -> "C";
        case 6 -> "D";
        default -> "F";
    };
}
```

## Próximos Passos

* Explore pattern matching em [Pattern Matching](pattern-matching.html)

* Pratique com exercícios em [Control Flow Projects](control-flow-projects.html)

* Aprenda sobre expressões lambda em [Lambda](lambda.html)

[Pattern Matching](pattern-matching.html)



# Pattern Matching

```
>> Inicializando sistema de correspondência de padrões...
>> Carregando tipos de dados...
>> Estabelecendo regras de matching...
```

## Introdução

Pattern Matching é uma feature moderna do Java que permite testar e extravar valores de objetos de forma mais elegante e segura.

## Pattern Matching com instanceof

### Sintaxe Tradicional vs. Nova

```JAVA
// Forma antiga
if (obj instanceof String) {
    String str = (String) obj;
    System.out.println(str.length());
}

// Pattern Matching
if (obj instanceof String str) {
    System.out.println(str.length());
}
```

### Uso com Negação

```JAVA
if (!(obj instanceof String str)) {
    return;
}
// str está disponível aqui
System.out.println(str.length());
```

## Pattern Matching em Switch (Preview)

### Matching por Tipo

```JAVA
String formatted = switch (obj) {
    case String str -> "String: " + str.toUpperCase();
    case Integer num -> "Int: " + num.toString();
    case Double d -> "Double: " + String.format("%.2f", d);
    case null -> "null";
    default -> "Unknown: " + obj.toString();
};
```

### Guarded Patterns

```JAVA
String checkNumber = switch (num) {
    case Integer i when i < 0 -> "Negativo";
    case Integer i when i > 0 -> "Positivo";
    case Integer i -> "Zero";
    default -> "Não é um número";
};
```

## Casos de Uso Avançados

### Hierarquia de Classes

```JAVA
public sealed interface Shape 
    permits Circle, Rectangle, Triangle {}

record Circle(double radius) implements Shape {}
record Rectangle(double width, double height) implements Shape {}
record Triangle(double base, double height) implements Shape {}

double calculateArea(Shape shape) {
    return switch (shape) {
        case Circle c -> Math.PI * c.radius() * c.radius();
        case Rectangle r -> r.width() * r.height();
        case Triangle t -> (t.base() * t.height()) / 2;
    };
}
```

### Processamento de Dados

```JAVA
String processData(Object data) {
    return switch (data) {
        case String s when s.length() > 10 -> "String longa: " + s.substring(0, 10) + "...";
        case String s -> "String: " + s;
        case List<?> list when list.isEmpty() -> "Lista vazia";
        case List<?> list -> "Lista com " + list.size() + " elementos";
        case Map<?, ?> map -> "Map com " + map.size() + " entradas";
        case null -> "Dado nulo";
        default -> "Tipo não suportado";
    };
}
```

## Boas Práticas

1. Clareza

* Use nomes descritivos para variáveis de pattern

* Mantenha padrões simples e diretos

* Documente casos complexos

2. Organização

* Ordene casos do mais específico para o mais genérico

* Agrupe padrões relacionados

* Use guards para refinar a lógica

3. Performance

* Evite operações pesadas em guards

* Considere a ordem dos padrões

* Mantenha o código eficiente

## Exemplos Práticos

### Validador de Dados

```JAVA
String validateInput(Object input) {
    return switch (input) {
        case String s when s.isBlank() -> "String vazia";
        case String s when s.matches("\\d+") -> "Número válido: " + s;
        case String s -> "Texto válido: " + s;
        case Integer i when i >= 0 -> "Número positivo: " + i;
        case Integer i -> "Número negativo: " + i;
        case null -> "Input nulo";
        default -> "Input inválido";
    };
}
```

### Processador de Eventos

```JAVA
void processEvent(Event event) {
    switch (event) {
        case UserEvent u when u.isAdmin() -> handleAdminEvent(u);
        case UserEvent u -> handleUserEvent(u);
        case SystemEvent s when s.isCritical() -> handleCriticalSystemEvent(s);
        case SystemEvent s -> handleSystemEvent(s);
        case null -> throw new IllegalArgumentException("Evento nulo");
        default -> handleUnknownEvent(event);
    }
}
```

## Troubleshooting

### Problemas Comuns

1. Ordem dos Patterns

```JAVA
// Incorreto - Padrão inalcançável
switch (obj) {
    case Object o -> "Objeto";    // Captura tudo
    case String s -> "String";    // Nunca alcançado
}

// Correto
switch (obj) {
    case String s -> "String";    // Mais específico primeiro
    case Object o -> "Objeto";    // Mais genérico depois
}
```

1. Null Handling

```JAVA
// Incorreto - NullPointerException possível
switch (obj) {
    case String s -> s.length();
    default -> 0;
}

// Correto
switch (obj) {
    case null -> 0;
    case String s -> s.length();
    default -> 0;
}
```

## Exercícios Práticos

1. Analisador de Dados

```JAVA
String analyzeData(Object data) {
    return switch (data) {
        case String s when s.contains("@") -> "Email: " + s;
        case String s when s.matches("\\d{10}") -> "Telefone: " + s;
        case String s -> "Texto: " + s;
        case Integer i -> "Número: " + i;
        case List<?> l -> "Lista[" + l.size() + "]";
        case null -> "NULO";
        default -> "Desconhecido";
    };
}
```

1. Calculadora de Formas

```JAVA
record Point(int x, int y) {}
record Circle(Point center, double radius) {}
record Rectangle(Point topLeft, double width, double height) {}

String describeShape(Object shape) {
    return switch (shape) {
        case Circle c -> 
            String.format("Círculo em (%d,%d) com raio %.2f",
                c.center().x(), c.center().y(), c.radius());
        case Rectangle r -> 
            String.format("Retângulo em (%d,%d) de %.2fx%.2f",
                r.topLeft().x(), r.topLeft().y(), r.width(), r.height());
        case null -> "Forma nula";
        default -> "Forma não reconhecida";
    };
}
```

## Próximos Passos

* Explore expressões switch em [Switch Expressions](switch-expressions.html)

* Pratique com projetos em [Control Flow Projects](control-flow-projects.html)

* Aprenda sobre sealed classes em [Sealed Classes](sealed-classes.html)

[Control Flow Projects](control-flow-projects.html)



# Projetos de Controle de Fluxo

```
>> Iniciando simulação de projetos...
>> Carregando cenários de teste...
>> Executando casos de uso...
```

## Visão Geral

Esta seção apresenta três projetos práticos que demonstram diferentes aspectos do controle de fluxo em Java, todos ambientados em um contexto cyberpunk.

```MERMAID
graph TD
    A[Projetos de Controle] --> B[Jogo de Números]
    A --> C[Sistema de Menu]
    A --> D[Máquina de Estados]
    
    B --> E[if/else]
    B --> F[while]
    
    C --> G[switch]
    C --> H[break]
    
    D --> I[switch/case]
    D --> J[estados]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#33ccff
    style F fill:#1a1a1a,stroke:#33ccff
    style G fill:#1a1a1a,stroke:#33ccff
    style H fill:#1a1a1a,stroke:#33ccff
    style I fill:#1a1a1a,stroke:#33ccff
    style J fill:#1a1a1a,stroke:#33ccff
```

## Projetos Disponíveis

### 1. Jogo de Números

* [Jogo de Números](number-game.html) - Um jogo de adivinhação que utiliza loops e condicionais

* Demonstra uso de `while`, `if/else` e operadores de comparação

* Implementa sistema de pontuação e feedback ao usuário

### 2. Sistema de Menu

* [Sistema de Menu](menu-system.html) - Interface de comando baseada em menus

* Explora uso extensivo de `switch/case`

* Demonstra navegação entre diferentes estados do menu

### 3. Máquina de Estados

* [Máquina de Estados](state-machine.html) - Sistema de segurança com estados

* Implementa uma máquina de estados simples

* Utiliza combinação de `switch/case` e controle de fluxo

## Conceitos Aplicados

1. Estruturas Condicionais

* `if/else`

* `switch/case`

* Operadores de comparação

2. Loops

* `while`

* Controle de iteração

* Condições de saída

3. Controle de Fluxo

* `break`

* `continue`

* Estados e transições

## Objetivos de Aprendizado

* Praticar diferentes estruturas de controle

* Entender fluxo de execução

* Implementar lógica de decisão

* Gerenciar estados do programa

## Próximos Passos

Após completar estes projetos, você estará preparado para:

1. Desenvolver sistemas mais complexos

2. Combinar diferentes estruturas de controle

3. Implementar lógica de negócios mais sofisticada

[Arrays e Coleções](arrays-collections.html)

Tip:

"O controle de fluxo é como hackear a Matrix - você precisa saber exatamente onde e quando dobrar as regras."



# Jogo de Números

## Descrição do Projeto

Desenvolva um jogo de adivinhação onde o jogador tenta adivinhar um número gerado aleatoriamente pelo sistema.

## Conceitos Aplicados

* Loops (while/do-while)

* Condicionais (if/else)

* Switch Expressions

* Pattern Matching

## Implementação Base

```JAVA
public class NumberGame {
    public static void main(String[] args) {
        // Configurações do jogo usando tipos primitivos
        int numeroSecreto = 42; // Número fixo para simplificar
        int tentativasMaximas = 5;
        int tentativas = 0;
        boolean jogoAtivo = true;
        
        // Mensagem inicial usando Text Block
        System.out.println("""
            === JOGO DE ADIVINHAÇÃO ===
            Tente adivinhar o número entre 1 e 100
            Você tem 5 tentativas!
            =========================
            """);
        
        // Loop principal do jogo
        while (jogoAtivo && tentativas < tentativasMaximas) {
            System.out.println("\nTentativa " + (tentativas + 1) + " de " + tentativasMaximas);
            System.out.print("Digite seu palpite: ");
            
            // Simulando entrada do usuário (você pode modificar para testar)
            var palpite = 50; // Simula entrada do usuário
            
            // Incrementa tentativas
            tentativas++;
            
            // Verifica o palpite
            if (palpite == numeroSecreto) {
                System.out.println("Parabéns! Você acertou em " + tentativas + " tentativas!");
                jogoAtivo = false;
            } else {
                // Verifica se ainda tem tentativas
                if (tentativas >= tentativasMaximas) {
                    System.out.println("Game Over! O número era " + numeroSecreto);
                } else {
                    // Dá dicas baseadas no palpite
                    if (palpite < numeroSecreto) {
                        System.out.println("Tente um número MAIOR!");
                    } else {
                        System.out.println("Tente um número MENOR!");
                    }
                    
                    // Mostra tentativas restantes
                    System.out.println("Tentativas restantes: " + (tentativasMaximas - tentativas));
                }
            }
            
            // Pequena pausa para simular processamento
            System.out.println("Processando...");
        }
        
        // Pontuação final
        int pontuacao = 0;
        if (!jogoAtivo) { // Se acertou
            pontuacao = (tentativasMaximas - tentativas + 1) * 100;
            System.out.println("Sua pontuação: " + pontuacao);
        }
        
        System.out.println("Fim do jogo!");
    }
}
```

## Interface com Usuário

```JAVA
public class NumberGameUI {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        NumberGame game = new NumberGame(100, 5);
        
        System.out.println("=== Jogo de Adivinhação ===");
        System.out.println("Tente adivinhar o número entre 1 e 100");
        
        do {
            System.out.print("Digite seu palpite: ");
            if (scanner.hasNextInt()) {
                int guess = scanner.nextInt();
                String result = game.processGuess(guess);
                System.out.println(result);
            } else {
                System.out.println("Por favor, digite um número válido!");
                scanner.next();
            }
        } while (!game.isGameOver());
    }
}
```

## Desafios de Extensão

1. Níveis de Dificuldade

```JAVA
public enum Difficulty {
    EASY(1, 10, 6),
    MEDIUM(1, 100, 5),
    HARD(1, 1000, 4);

    final int min, max, attempts;
    
    Difficulty(int min, int max, int attempts) {
        this.min = min;
        this.max = max;
        this.attempts = attempts;
    }
}
```

1. Sistema de Pontuação

```JAVA
public int calculateScore() {
    return switch (state) {
        case WON -> (maxAttempts - attempts + 1) * 100;
        case LOST -> 0;
        default -> throw new IllegalStateException("Jogo ainda em andamento");
    };
}
```

## Próximos Passos

* Implemente o sistema de dificuldade

* Adicione um sistema de recordes

* Crie um modo multiplayer

[Menu System](menu-system.html)



# Sistema de Menu

## Descrição do Projeto

Desenvolva um sistema de menu interativo estilo cyberpunk para uma interface de terminal.

## Conceitos Aplicados

* Switch Expressions

* Pattern Matching

* Loops

* Condicionais Aninhados

## Implementação Base

```JAVA
public class MenuSystem {
    public static void main(String[] args) {
        // Estado atual do menu usando String
        String menuAtual = "PRINCIPAL";
        
        // Flag para controle do loop
        boolean sistemaAtivo = true;
        
        // Mensagem de boas-vindas usando Text Block
        System.out.println("""
            === SISTEMA CYBERDECK v1.0 ===
            Menu Principal:
            1. Iniciar Sistema
            2. Configurações
            3. Status
            4. Sair
            ===========================
            """);
        
        // Loop principal do sistema
        while (sistemaAtivo) {
            System.out.println("\nMenu atual: " + menuAtual);
            System.out.print("Digite uma opção: ");
            
            // Simulando entrada do usuário (você pode modificar para testar)
            var opcao = "1"; // Simula entrada do usuário
            
            // Controle de fluxo baseado no menu atual
            switch (menuAtual) {
                case "PRINCIPAL":
                    switch (opcao) {
                        case "1":
                            menuAtual = "SISTEMA";
                            System.out.println("""
                                === Menu do Sistema ===
                                1. Verificar Status
                                2. Executar Diagnóstico
                                3. Voltar
                                """);
                            break;
                        case "2":
                            menuAtual = "CONFIG";
                            System.out.println("""
                                === Menu de Configurações ===
                                1. Display
                                2. Segurança
                                3. Rede
                                4. Voltar
                                """);
                            break;
                        case "3":
                            System.out.println("""
                                Status do Sistema:
                                - Memória: OK
                                - Processador: OK
                                - Rede: OK
                                """);
                            break;
                        case "4":
                            sistemaAtivo = false;
                            break;
                    }
                    break;
                    
                case "CONFIG":
                    switch (opcao) {
                        case "1":
                            System.out.println("Configurando Display...");
                            break;
                        case "2":
                            System.out.println("Configurando Segurança...");
                            break;
                        case "3":
                            System.out.println("Configurando Rede...");
                            break;
                        case "4":
                            menuAtual = "PRINCIPAL";
                            System.out.println("Voltando ao Menu Principal...");
                            break;
                    }
                    break;
                    
                case "SISTEMA":
                    switch (opcao) {
                        case "1":
                            System.out.println("Verificando status...");
                            break;
                        case "2":
                            System.out.println("Executando diagnóstico...");
                            break;
                        case "3":
                            menuAtual = "PRINCIPAL";
                            System.out.println("Voltando ao Menu Principal...");
                            break;
                    }
                    break;
            }
            
            // Pequena pausa para simular processamento
            System.out.println("Processando...");
        }
        
        System.out.println("Sistema finalizado.");
    }
}
```

## Interface com Usuário

```JAVA
public class MenuSystemUI {
    public static void main(String[] args) {
        MenuSystem menu = new MenuSystem();
        Scanner scanner = new Scanner(System.in);
        
        System.out.println("""
            === SISTEMA CYBERDECK v1.0 ===
            Iniciando interface...
            """);
        
        String input;
        do {
            System.out.print("> ");
            input = scanner.nextLine().trim();
            String response = menu.processInput(input);
            System.out.println(response);
        } while (!input.equals("exit"));
    }
}
```

## Recursos Avançados

1. Animações de Terminal

```JAVA
public class TerminalEffects {
    public static void typeWriter(String text) {
        for (char c : text.toCharArray()) {
            System.out.print(c);
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        System.out.println();
    }
}
```

1. Sistema de Cores

```JAVA
public class ColoredOutput {
    public static final String ANSI_GREEN = "\u001B[32m";
    public static final String ANSI_RED = "\u001B[31m";
    public static final String ANSI_RESET = "\u001B[0m";
    
    public static String success(String text) {
        return ANSI_GREEN + text + ANSI_RESET;
    }
    
    public static String error(String text) {
        return ANSI_RED + text + ANSI_RESET;
    }
}
```

## Desafios de Extensão

1. Adicione autenticação de usuário

2. Implemente submenus dinâmicos

3. Crie um sistema de logs

4. Adicione efeitos visuais ASCII art

## Próximos Passos

* Implemente mais funcionalidades no menu

* Adicione persistência de configurações

* Crie uma interface gráfica ASCII mais elaborada

[State Machine](state-machine.html)



# Máquina de Estados

## Descrição do Projeto

Implemente uma máquina de estados que simula um sistema de segurança cyberpunk.

## Conceitos Aplicados

* Pattern Matching

* Switch Expressions

* Loops Controlados por Estado

* Condicionais Complexos

## Implementação Base

```JAVA
public class StateMachine {
    public static void main(String[] args) {
        // Estados possíveis usando String
        String estado = "TRAVADO";  // estado inicial
        
        // Contadores e flags usando tipos primitivos
        int tentativasInvalidas = 0;
        boolean sistemaAtivo = true;
        
        // Mensagem de boas-vindas usando Text Block
        System.out.println("""
            === SISTEMA DE SEGURANÇA CYBERPUNK ===
            Estados: TRAVADO, DESTRAVADO, ALERTA
            Comandos: 
            1 - Inserir código válido
            2 - Inserir código inválido
            3 - Travar sistema
            4 - Sair
            ====================================
            """);
        
        // Loop principal do sistema
        while (sistemaAtivo) {
            System.out.println("\nEstado atual: " + estado);
            System.out.print("Digite um comando: ");
            
            // Simulando entrada do usuário (você pode modificar os valores para testar)
            var comando = "1"; // Simula entrada do usuário
            
            // Controle de fluxo baseado no estado atual
            switch (estado) {
                case "TRAVADO":
                    if (comando.equals("1")) {
                        estado = "DESTRAVADO";
                        tentativasInvalidas = 0;
                        System.out.println("Acesso concedido!");
                    } else if (comando.equals("2")) {
                        tentativasInvalidas++;
                        if (tentativasInvalidas >= 3) {
                            estado = "ALERTA";
                            System.out.println("ALERTA: Múltiplas tentativas inválidas!");
                        } else {
                            System.out.println("Código inválido. Tentativas restantes: " + (3 - tentativasInvalidas));
                        }
                    }
                    break;
                    
                case "DESTRAVADO":
                    if (comando.equals("3")) {
                        estado = "TRAVADO";
                        System.out.println("Sistema travado!");
                    }
                    break;
                    
                case "ALERTA":
                    if (comando.equals("1")) {
                        estado = "TRAVADO";
                        tentativasInvalidas = 0;
                        System.out.println("Sistema resetado!");
                    }
                    break;
            }
            
            // Condição de saída
            if (comando.equals("4")) {
                sistemaAtivo = false;
                System.out.println("Encerrando sistema...");
            }
            
            // Pequena pausa para simular processamento
            System.out.println("Processando...");
        }
    }
}
```

## Interface com Usuário

```JAVA
public class SecuritySystemUI {
    public static void main(String[] args) {
        SecuritySystem system = new SecuritySystem();
        Scanner scanner = new Scanner(System.in);
        
        System.out.println("""
            === SISTEMA DE SEGURANÇA CYBERPUNK ===
            Digite 'help' para ver os comandos disponíveis
            """);
        
        while (true) {
            System.out.print(">> ");
            String input = scanner.nextLine().toUpperCase();
            
            if (input.equals("EXIT")) break;
            
            try {
                SecurityEvent event = SecurityEvent.valueOf(input);
                String result = system.processEvent(event);
                System.out.println(result);
            } catch (IllegalArgumentException e) {
                if (input.equals("HELP")) {
                    showHelp();
                } else {
                    System.out.println("Comando inválido");
                }
            }
        }
    }
    
    private static void showHelp() {
        System.out.println("""
            Comandos disponíveis:
            VALID_CODE - Tentar código de acesso
            INVALID_CODE - Código inválido
            LOCK - Travar sistema
            EMERGENCY - Ativar emergência
            MAINTENANCE_KEY - Modo manutenção
            RESET - Resetar sistema
            SHUTDOWN - Desligar sistema
            EXIT - Sair do programa
            """);
    }
}
```

## Recursos Avançados

1. Sistema de Biometria

```JAVA
public class BiometricScanner {
    public boolean validateBiometric(String bioData) {
        return switch (bioData.length()) {
            case 32 -> bioData.matches("[A-F0-9]+");
            case 64 -> bioData.matches("[a-f0-9]+");
            default -> false;
        };
    }
}
```

1. Monitor de Atividades

```JAVA
public class ActivityMonitor {
    private final Queue<SecurityEvent> recentEvents;
    private static final int MAX_EVENTS = 10;
    
    public ActivityMonitor() {
        this.recentEvents = new LinkedList<>();
    }
    
    public void recordEvent(SecurityEvent event) {
        recentEvents.offer(event);
        if (recentEvents.size() > MAX_EVENTS) {
            recentEvents.poll();
        }
    }
    
    public boolean detectSuspiciousActivity() {
        long invalidAttempts = recentEvents.stream()
            .filter(e -> e == SecurityEvent.INVALID_CODE)
            .count();
        return invalidAttempts >= 3;
    }
}
```

## Desafios de Extensão

1. Implemente um sistema de níveis de acesso

2. Adicione criptografia para códigos de acesso

3. Crie um sistema de backup automático

4. Implemente notificações em tempo real

## Próximos Passos

* Adicione mais estados e eventos

* Implemente persistência de logs

* Crie uma interface gráfica mais elaborada

* Adicione suporte a múltiplos usuários

[Control Flow](control-flow.html)



# Arrays e Coleções

```
DATA STRUCTURES
├── Arrays
│   ├── Unidimensionais
│   └── Multidimensionais
└── Collections
    ├── List
    ├── Set
    ├── Queue
    └── Map
```

## Visão Geral

Esta seção explora as estruturas de dados fundamentais em Java, desde arrays básicos até as coleções mais sofisticadas do framework Collections.

```MERMAID
graph TD
    A[Estruturas de Dados] --> B[Arrays]
    A --> C[Collections]
    
    B --> D[Arrays Primitivos]
    B --> E[Arrays de Objetos]
    
    C --> F[List]
    C --> G[Set]
    C --> H[Queue]
    C --> I[Map]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#33ccff
    style E fill:#1a1a1a,stroke:#33ccff
    style F fill:#1a1a1a,stroke:#33ccff
    style G fill:#1a1a1a,stroke:#33ccff
    style H fill:#1a1a1a,stroke:#33ccff
    style I fill:#1a1a1a,stroke:#33ccff
```

## Módulos do Curso

### 1. Arrays Fundamentais

* [Arrays](arrays.html) - Estruturas básicas e manipulação

* Arrays unidimensionais e multidimensionais

* Operações comuns e boas práticas

### 2. Framework Collections

* [Visão Geral das Collections](collections-overview.html)

* [Listas](lists.html) - Sequências ordenadas

* [Sets](sets.html) - Conjuntos sem duplicatas

* [Maps](maps.html) - Pares chave-valor

* [Queues](queues.html) - Filas e pilhas

* [Stacks](stacks.html) - Estruturas LIFO

### 3. Projetos Práticos

* [Gerenciador de Tarefas](task-manager.html)

* [Sistema de Inventário](inventory-system.html)

* [Implementação de Cache](cache-implementation.html)

## Conceitos Principais

1. Arrays

* Alocação de memória

* Indexação

* Iteração

* Arrays multidimensionais

2. Collections Framework

* Interfaces principais

* Implementações comuns

* Algoritmos de coleções

* Iteradores

3. Performance e Uso

* Complexidade de tempo

* Uso de memória

* Escolha da estrutura adequada

* Otimizações

## Objetivos de Aprendizado

* Dominar manipulação de arrays

* Entender o framework Collections

* Escolher estruturas apropriadas

* Implementar soluções eficientes

## Próximos Passos

Após esta seção, você estará preparado para:

1. Trabalhar com estruturas de dados complexas

2. Implementar algoritmos eficientes

3. Desenvolver sistemas escaláveis

[Fundamentos de OOP](oop-fundamentals.html)

Tip:

"Em um mundo digital, dados são poder. A forma como você os estrutura determina sua eficiência no combate."



# Arrays em Java

```
ARRAY OPERATIONS
├── Declaração (Como registrar clientes em um bordel)
├── Inicialização (Abrir as portas)
├── Acesso (Encontrar seu favorito)
├── Modificação (Trocar os números)
└── Iteração (Fazer a ronda noturna)
```

## Fundamentos

Arrays são como um bordel bem organizado - cada quarto tem seu número, e você sabe exatamente o que esperar em cada um. Sem surpresas desagradáveis.

```JAVA
// Declaração e inicialização
int[] quartos = new int[5];  // 5 quartos vazios
String[] servicos = {"BASICO", "ESPECIAL", "COMPLETO"};

// Array multidimensional (como um prédio com vários andares)
int[][] predio = new int[3][3];
```

## Características Principais

### 1. Tamanho Fixo (Como um Motel Lotado)

```JAVA
// Uma vez definido o número de quartos, não dá pra criar mais
int numQuartos = 10;
double[] precos = new double[numQuartos];

// Nem adianta chorar, não vai caber mais
System.out.println("Quartos disponíveis: " + precos.length);
```

### 2. Indexação Base-Zero (Como Idade de Político)

```JAVA
// O primeiro sempre começa do zero
int primeiro = quartos[0];  // Quarto 0 (mas na placa tá 1)

// O último é sempre um a menos que o total
int ultimo = quartos[quartos.length - 1];
```

### 3. Tipo Homogêneo (Como Menu de Boteco)

```JAVA
// Aqui só serve cachaça, amigo
String[] drinks = new String[3];
drinks[0] = "51";
drinks[1] = "Velho Barreiro";
drinks[2] = "Pitú";
```

## Operações Comuns

### Iteração (Como Fazer a Ronda)

```JAVA
// Método tradicional (checando quarto por quarto)
for (int i = 0; i < quartos.length; i++) {
    System.out.println("Verificando quarto " + i);
}

// Método moderno (câmeras de segurança)
for (String drink : drinks) {
    System.out.println("Bebida disponível: " + drink);
}
```

### Manipulação (Como Gerenciar o Estabelecimento)

```JAVA
// Resetar preços (promoção de segunda)
Arrays.fill(precos, 29.90);

// Ordenar por preço (do mais barato pro mais caro)
Arrays.sort(precos);

// Procurar aquele cliente especial
int indice = Arrays.binarySearch(drinks, "51");
```

## Arrays Multidimensionais (Como um Cassino de Luxo)

### Matrizes

```JAVA
// Mapa do cassino (3 andares, cada um com 3 salas)
int[][] cassino = {
    {1, 2, 3},  // Caça-níqueis
    {4, 5, 6},  // Poker
    {7, 8, 9}   // Roleta
};

// Encontrar mesa específica
int mesa = cassino[1][2];  // Mesa 6 de poker
```

### Iteração em Matrizes (Inspeção Sanitária)

```JAVA
// Verificando todas as mesas
for (int andar = 0; andar < cassino.length; andar++) {
    for (int sala = 0; sala < cassino[andar].length; sala++) {
        System.out.print("Verificando mesa " + cassino[andar][sala]);
    }
    System.out.println(" - Andar limpo!");
}
```

## Boas Práticas (Regras da Casa)

1. Validação de Índices (Checagem de ID)

```JAVA
if (quarto >= 0 && quarto < quartos.length) {
    // Cliente pode entrar
    return quartos[quarto];
}
```

1. Cópia de Arrays (Expandindo o Negócio)

```JAVA
// Abrindo filial com mesma configuração
int[] filial = Arrays.copyOf(quartos, quartos.length);

// Pegando só o melhor da casa
int[] vips = Arrays.copyOfRange(quartos, 1, 4);
```

## Exercícios Práticos

1. Implemente um sistema de rodízio de "funcionários"

2. Crie um controle de mesas de poker

3. Desenvolva um algoritmo de distribuição de gorjetas

## Próximos Passos

Depois de dominar esse bordel de arrays, você estará pronto para:

1. Gerenciar uma rede de estabelecimentos

2. Implementar sistemas de fidelidade

3. Expandir para o mercado internacional

[Collections: Quando Um Não é Suficiente](collections-overview.html)

Tip:

"Arrays são como um bordel bem administrado - cada elemento no seu lugar, e você sempre sabe onde encontrar o que procura."



# Collections Framework: O Submundo das Estruturas de Dados

```
COLLECTIONS HIERARCHY
├── List (Como uma Lista de Devedores)
├── Set (Clube Exclusivo, Sem Repetidos)
├── Queue (Fila do Pão, Mas Com Classe)
└── Map (Agenda Telefônica do Traficante)
```

## Anatomia do Submundo

Imagine o Collections Framework como uma organização criminosa bem estruturada - cada família tem sua especialidade, mas todas trabalham juntas quando necessário.

```JAVA
// As principais famílias
List<String> listaDaChantagem = new ArrayList<>();
Set<String> membrosVIP = new HashSet<>();
Queue<String> filaDeEspera = new LinkedList<>();
Map<String, Double> contasAReceber = new HashMap<>();
```

## Famílias Principais

### 1. List (A Lista Negra)

```JAVA
List<String> alvos = new ArrayList<>();
alvos.add("João Caloteiro");    // Adiciona no final
alvos.add(0, "Maria Malandra"); // Adiciona no início
String proximo = alvos.get(0);  // Próxima vítima
```

### 2. Set (Clube dos Exclusivos)

```JAVA
Set<String> vips = new HashSet<>();
vips.add("Don Corleone");     // Entra no clube
vips.add("Don Corleone");     // Tenta entrar de novo (falha)
boolean isMembro = vips.contains("Don Corleone"); // Tá na lista?
```

### 3. Queue (Fila do Desespero)

```JAVA
Queue<String> esperando = new LinkedList<>();
esperando.offer("Zé Devedor");  // Entra na fila
String proximo = esperando.poll(); // Próximo a ser "atendido"
String espiadinha = esperando.peek(); // Quem é o próximo sem tirar
```

### 4. Map (Livro Caixa)

```JAVA
Map<String, Double> dividas = new HashMap<>();
dividas.put("Zé", 1000.0);     // Deve mil
dividas.put("Maria", 2000.0);   // Deve dois mil
Double quanto = dividas.get("Zé"); // Quanto o Zé deve?
```

## Escolhendo sua Arma

### ArrayList vs LinkedList

```JAVA
// ArrayList: Acesso rápido, como endereço fixo
List<String> enderecos = new ArrayList<>();  // Ótimo para consultas

// LinkedList: Inserção rápida, como mensageiro
List<String> mensagens = new LinkedList<>();  // Bom para alterações
```

### HashSet vs TreeSet

```JAVA
// HashSet: Rápido e caótico, como bar de porto
Set<String> frequentadores = new HashSet<>();  // Não liga pra ordem

// TreeSet: Organizado e lento, como clube de madame
Set<String> clientesVIP = new TreeSet<>();     // Tudo ordenadinho
```

### HashMap vs TreeMap

```JAVA
// HashMap: Bagunçado mas eficiente, como caderno de agiota
Map<String, Double> pagamentos = new HashMap<>();

// TreeMap: Organizado e metódico, como livro contábil
Map<String, Double> contabilidade = new TreeMap<>();
```

## Operações Especiais

### Iteração (Fazendo a Ronda)

```JAVA
// For each moderno
for (String devedor : alvos) {
    System.out.println("Procurando: " + devedor);
}

// Iterator (modo old school)
Iterator<String> it = alvos.iterator();
while (it.hasNext()) {
    String alvo = it.next();
    if (alvo.contains("Delator")) {
        it.remove(); // Remove o X9
    }
}
```

### Ordenação (Organizando a Casa)

```JAVA
// Ordenar a lista de devedores por nome
Collections.sort(alvos);

// Ordenar por valor da dívida
alvos.sort((a, b) -> dividas.get(a).compareTo(dividas.get(b)));
```

## Dicas de Sobrevivência

1. Escolha Certa

* ArrayList para acesso rápido

* LinkedList para muitas alterações

* HashSet para unicidade

* TreeSet para ordem natural

* HashMap para acesso por chave

* TreeMap para ordem nas chaves

2. Performance

```JAVA
// Defina o tamanho inicial se souber
List<String> lista = new ArrayList<>(1000);

// Use a estrutura certa pro trabalho
Set<String> conjunto = new HashSet<>();  // Mais rápido que List pra busca
```

## Exercícios Práticos

1. Implemente um sistema de controle de território

2. Crie um gerenciador de dívidas com juros compostos

3. Desenvolva uma lista de "proteção" com prioridades

## Próximos Passos

Depois de dominar as Collections, você estará pronto para:

1. Gerenciar dados como um profissional

2. Implementar estruturas complexas

3. Otimizar operações de dados

[Arrays: De Volta ao Básico](arrays.html)
[Lists: Quando a Ordem Importa](lists.html)

Tip:

"Collections são como uma família do crime organizado - cada uma tem seu papel, e juntas controlam toda a cidade dos dados."



# Lists: A Playlist do Baile Funk

```
LIST TYPES
├── ArrayList (Camarote VIP)
└── LinkedList (Fila do Open Bar)
```

## Fundamentos

Lists são como uma festa funk - tem ordem, repetição e sempre cabe mais um.

```JAVA
// Criando a lista de convidados
List<String> convidados = new ArrayList<>();
convidados.add("MC Kevinho");    // Adiciona no fim da lista
convidados.add(0, "MC Livinho"); // Fura a fila (adiciona no início)
```

## ArrayList vs LinkedList

### ArrayList (Camarote VIP)

```JAVA
// Rápido pra achar alguém, como camarote numerado
ArrayList<String> camarote = new ArrayList<>();
camarote.add("Anitta");
camarote.get(0);         // Acesso direto, mesa 0
```

### LinkedList (Fila do Open Bar)

```JAVA
// Melhor pra galera entrar e sair, como fila de open bar
LinkedList<String> openBar = new LinkedList<>();
openBar.addFirst("Sedento");   // Furando fila
openBar.addLast("Paciente");   // Entrando no fim
```

## Operações Básicas (Como Gerenciar o Baile)

### Adição (Deixa Entrar)

```JAVA
// Vários jeitos de deixar a galera entrar
List<String> baile = new ArrayList<>();
baile.add("Dançarino");           // Fim da fila
baile.add(0, "DJ");               // VIP, direto pro início
baile.addAll(Arrays.asList("MC", "DJ", "Beat Maker")); // Grupo
```

### Remoção (Expulsando da Festa)

```JAVA
// Diferentes formas de expulsar
baile.remove("Confusão");          // Remove elemento específico
baile.remove(0);                   // Remove da posição
baile.removeIf(x -> x.contains("Briga")); // Remove todos briguentos
```

### Acesso (Procurando na Multidão)

```JAVA
// Encontrando a galera
String vip = baile.get(0);         // Pega pela posição
int pos = baile.indexOf("DJ");     // Onde tá o DJ?
boolean temMC = baile.contains("MC"); // O MC chegou?
```

## Lists Especializadas (Áreas VIP)

### Vector (Antiga Casa de Show)

```JAVA
// Synchronized por padrão, como segurança old school
Vector<String> casaAntiga = new Vector<>();
casaAntiga.add("Dançarino Clássico");
```

### Stack (Pilha de Caixas de Som)

```JAVA
// LIFO - Last In, First Out
Stack<String> equipamento = new Stack<>();
equipamento.push("Grave");     // Empilha
String topo = equipamento.pop(); // Desempilha
```

## Ordenação (Organizando o Line-up)

```JAVA
// Ordenando a lista de apresentações
List<String> lineup = new ArrayList<>();
lineup.addAll(Arrays.asList("MC Late", "DJ Early", "MC Prime"));

// Ordem alfabética
Collections.sort(lineup);

// Ordem personalizada
lineup.sort((a, b) -> a.length() - b.length()); // Por tamanho do nome
```

## Iteração (Passando o Som)

```JAVA
// For tradicional (Contagem regressiva)
for (int i = 0; i < lineup.size(); i++) {
    System.out.println("Próximo: " + lineup.get(i));
}

// For each (Passando o som)
for (String artista : lineup) {
    System.out.println("No palco: " + artista);
}

// Iterator (Revista na entrada)
Iterator<String> revista = lineup.iterator();
while (revista.hasNext()) {
    String pessoa = revista.next();
    if (pessoa.contains("Problema")) {
        revista.remove(); // Barrado
    }
}
```

## Dicas Pro Baile

1. Escolha Certa

* ArrayList: Quando precisa acessar rápido

* LinkedList: Quando a galera entra e sai muito

2. Performance

```JAVA
// Define o tamanho se souber quantos vem
List<String> convidados = new ArrayList<>(100);

// Limpa a lista depois da festa
convidados.clear();
```

## Exercícios Práticos

1. Implemente um sistema de fila de entrada

2. Crie um gerenciador de playlists

3. Desenvolva um controlador de pedidos de música

## Próximos Passos

Depois de dominar as Lists, você estará pronto para:

1. Gerenciar qualquer tipo de sequência ordenada

2. Implementar filas e pilhas eficientes

3. Organizar dados com repetição

[Collections Overview](collections-overview.html)
[Sets: Sem Repeteco](sets.html)

Tip:

"Lists são como um baile funk: tem ordem, aceita repetição e sempre cabe mais um na pista!"



# Sets: O Clube dos Únicos

```
SET TYPES
├── HashSet (Balada Alternativa)
├── LinkedHashSet (Festa Temática)
└── TreeSet (Clube da Alta Sociedade)
```

## Fundamentos

Sets são como uma festa exclusiva - não tem repetido e cada um é único.

```JAVA
// Criando a lista do clube mais exclusivo
Set<String> clubeDosUnicos = new HashSet<>();
clubeDosUnicos.add("Hipster");    // Entra
clubeDosUnicos.add("Hipster");    // Barrado! Já tem um igual
```

## Tipos de Sets (Diferentes Baladas)

### HashSet (Balada Alternativa)

```JAVA
// Rápido e caótico, como uma rave
HashSet<String> rave = new HashSet<>();
rave.add("Raver");      // Ordem? Que ordem?
rave.add("DJ");         // Entra onde der
```

### LinkedHashSet (Festa Temática)

```JAVA
// Mantém a ordem de entrada, como fila organizada
LinkedHashSet<String> tematica = new LinkedHashSet<>();
tematica.add("Anos 80");  // Primeiro
tematica.add("Anos 90");  // Segundo
```

### TreeSet (Clube da Alta Sociedade)

```JAVA
// Sempre ordenado, como lista de socialites
TreeSet<String> clubeSocial = new TreeSet<>();
clubeSocial.add("Baronesa");   // Será ordenado
clubeSocial.add("Condessa");   // Automaticamente
```

## Operações Básicas (Regras do Clube)

### Adição (Tentando Entrar)

```JAVA
Set<String> clube = new HashSet<>();
clube.add("Sócio");            // Bem-vindo ao clube
clube.add("Sócio");            // Negado! Já é membro
clube.addAll(Arrays.asList("VIP", "Premium")); // Grupo VIP
```

### Remoção (Cancelando Sociedade)

```JAVA
// Diferentes formas de expulsar
clube.remove("Ex-sócio");       // Remove específico
clube.removeIf(x -> x.startsWith("Inadimplente")); // Remove todos inadimplentes
```

### Verificação (Lista na Porta)

```JAVA
// Checando quem pode entrar
boolean isMembro = clube.contains("VIP");     // Está na lista?
boolean todosVIP = clube.containsAll(vips);   // Grupo inteiro na lista?
```

## Operações de Conjunto (Misturando as Tribos)

```JAVA
Set<String> metaleiros = new HashSet<>();
Set<String> punks = new HashSet<>();

// União (Festa de Rock)
Set<String> rockeiros = new HashSet<>(metaleiros);
rockeiros.addAll(punks);

// Interseção (Amigos em Comum)
Set<String> hibridos = new HashSet<>(metaleiros);
hibridos.retainAll(punks);

// Diferença (Só Metaleiros)
Set<String> puristas = new HashSet<>(metaleiros);
puristas.removeAll(punks);
```

## Iteração (Fazendo a Social)

```JAVA
// For each (Cumprimentando todo mundo)
for (String socio : clube) {
    System.out.println("Boa noite, " + socio);
}

// Iterator (Revista VIP)
Iterator<String> revista = clube.iterator();
while (revista.hasNext()) {
    String pessoa = revista.next();
    if (pessoa.contains("Indesejado")) {
        revista.remove(); // Tchau!
    }
}
```

## Dicas de Etiqueta

1. Escolha do Clube

* HashSet: Quando só importa ser único

* LinkedHashSet: Quando a ordem de entrada importa

* TreeSet: Quando precisa manter tudo ordenado

2. Performance

```JAVA
// Define tamanho inicial se souber
Set<String> vips = new HashSet<>(100);

// Use o tipo certo pra cada ocasião
Set<String> ordenados = new TreeSet<>();  // Sempre ordenado
```

## Exercícios Práticos

1. Implemente um sistema de controle de sócios

2. Crie um gerenciador de eventos exclusivos

3. Desenvolva um verificador de duplicatas

## Próximos Passos

Depois de dominar os Sets, você estará pronto para:

1. Gerenciar coleções sem duplicatas

2. Implementar sistemas de membros

3. Trabalhar com conjuntos matemáticos

[Lists: A Sequência](lists.html)
[Maps: Chave e Valor](maps.html)

Tip:

"Sets são como clubes exclusivos - não importa quantas vezes você tente entrar, só passa uma vez!"



# Maps: O Guarda-Volumes da Matrix

```
MAP TYPES
├── HashMap (Armário Digital)
├── LinkedHashMap (Armário com Histórico)
└── TreeMap (Armário Ordenado)
```

## Fundamentos

Maps são como um guarda-volumes high-tech - cada item tem sua chave única, e você pode guardar qualquer coisa lá dentro.

```JAVA
// Criando um guarda-volumes digital
Map<String, String> lockers = new HashMap<>();
lockers.put("A123", "Katana Digital");    // Guarda item
lockers.get("A123");                      // Recupera item
```

## Tipos de Maps (Diferentes Sistemas)

### HashMap (Armário Quantum)

```JAVA
// Rápido e aleatório, como teletransporte
HashMap<Integer, String> quantum = new HashMap<>();
quantum.put(42, "Dados Encriptados");  // Ordem? Irrelevante!
quantum.put(7, "Código Fonte");        // Acesso instantâneo
```

### LinkedHashMap (Registro Cronológico)

```JAVA
// Mantém ordem de inserção, como log de sistema
LinkedHashMap<String, String> logs = new LinkedHashMap<>();
logs.put("09:00", "Login");    // Primeiro registro
logs.put("09:01", "Download"); // Segundo registro
```

### TreeMap (Mainframe Ordenado)

```JAVA
// Sempre ordenado pela chave, como diretório indexado
TreeMap<String, String> mainframe = new TreeMap<>();
mainframe.put("sys.exe", "Sistema");     // Ordenação
mainframe.put("hack.exe", "Ferramentas"); // automática
```

## Operações Básicas (Protocolos de Acesso)

### Inserção (Upload)

```JAVA
Map<String, Object> database = new HashMap<>();
database.put("user.dat", new User());          // Novo registro
database.putIfAbsent("backup.dat", new Data()); // Só se não existir
```

### Recuperação (Download)

```JAVA
// Diferentes formas de acessar
Object data = database.get("user.dat");        // Acesso direto
Object safe = database.getOrDefault("temp.dat", new Data()); // Com fallback
```

### Remoção (Delete)

```JAVA
// Limpando registros
database.remove("temp.dat");              // Remove entrada
database.remove("user.dat", oldUser);     // Remove se valor bater
```

## Navegação (Scanning)

```JAVA
Map<String, String> matrix = new HashMap<>();

// Iterando chaves (Scanning IDs)
for (String key : matrix.keySet()) {
    System.out.println("ID: " + key);
}

// Iterando valores (Data Mining)
for (String value : matrix.values()) {
    System.out.println("Data: " + value);
}

// Iterando pares (Full Scan)
for (Map.Entry<String, String> entry : matrix.entrySet()) {
    System.out.println(entry.getKey() + " -> " + entry.getValue());
}
```

## Operações Avançadas (Hacks)

```JAVA
// Computação condicional
matrix.compute("stats", (k, v) -> v == null ? "new" : v + "_updated");

// Merge de dados
matrix.merge("downloads", 1, (old, new) -> old + new);

// Operações em massa
matrix.replaceAll((k, v) -> v.toUpperCase());
```

## Dicas de Segurança

1. Escolha do Sistema

* HashMap: Para acesso rápido e aleatório

* LinkedHashMap: Quando ordem de inserção importa

* TreeMap: Para manter chaves ordenadas

2. Performance

```JAVA
// Inicialize com tamanho se souber
Map<String, String> system = new HashMap<>(100);

// Use o tipo certo para cada operação
Map<String, Integer> sorted = new TreeMap<>();  // Para dados ordenados
```

## Exercícios Práticos

1. Implemente um sistema de cache

2. Crie um gerenciador de sessões

3. Desenvolva um contador de frequência

## Próximos Passos

Depois de dominar os Maps, você estará pronto para:

1. Criar sistemas de armazenamento chave-valor

2. Implementar caches eficientes

3. Gerenciar dados indexados

[Sets: Exclusividade](sets.html)
[Queues: Processamento](queues.html)

Tip:

"Maps são como o guarda-volumes da Matrix - cada segredo tem sua chave, e só você sabe onde procurar!"



# Queues: A Fila do Banco Digital

```
QUEUE TYPES
├── Queue (Fila Normal)
├── Deque (Fila Premium)
└── PriorityQueue (Fila Preferencial)
```

## Fundamentos

Queues são como filas de banco digitais - primeiro a chegar, primeiro a ser atendido (FIFO).

```JAVA
// Criando uma fila digital
Queue<String> fila = new LinkedList<>();
fila.offer("Cliente#1");    // Entra na fila
String proximo = fila.poll(); // Próximo a ser atendido
```

## Tipos de Queues

### Queue Básica

```JAVA
Queue<String> atendimento = new LinkedList<>();
atendimento.offer("Usuário");  // Adiciona ao fim
atendimento.poll();            // Remove do início
atendimento.peek();            // Consulta próximo
```

### Deque (Double-Ended Queue)

```JAVA
Deque<String> premium = new ArrayDeque<>();
premium.offerFirst("VIP");     // Fura fila
premium.offerLast("Regular");  // Entra normal
premium.pollFirst();           // Remove do início
premium.pollLast();           // Remove do fim
```

### PriorityQueue

```JAVA
// Fila com prioridades
PriorityQueue<Integer> senha = new PriorityQueue<>();
senha.offer(3);  // Organiza automaticamente
senha.offer(1);  // por ordem natural
senha.offer(2);  // ou comparador customizado
```

## Operações Comuns

### Inserção

```JAVA
Queue<String> fila = new LinkedList<>();
fila.offer("Normal");      // Preferido (retorna boolean)
fila.add("Força");        // Lança exceção se cheio
```

### Remoção

```JAVA
String cliente = fila.poll();     // Retorna null se vazio
String proximo = fila.remove();   // Lança exceção se vazio
```

### Consulta

```JAVA
String espiar = fila.peek();      // Retorna null se vazio
String primeiro = fila.element(); // Lança exceção se vazio
```

## Casos de Uso

1. Processamento de Transações

```JAVA
Queue<Transaction> transactions = new LinkedList<>();
transactions.offer(new Transaction("Depósito"));
processTransaction(transactions.poll());
```

1. Sistema de Mensagens

```JAVA
PriorityQueue<Message> messages = new PriorityQueue<>();
messages.offer(new Message("Urgente", 1));
messages.offer(new Message("Normal", 2));
```

## Dicas de Performance

```JAVA
// Inicialize com tamanho se souber
Queue<String> fila = new LinkedList<>(100);

// Use o tipo certo para o caso
Deque<String> rapido = new ArrayDeque<>();  // Mais eficiente que LinkedList
```

## Exercícios Práticos

1. Implemente um sistema de atendimento

2. Crie um processador de eventos

3. Desenvolva um escalonador de tarefas

## Próximos Passos

Depois de dominar Queues, você estará pronto para:

1. Gerenciar filas de processamento

2. Implementar sistemas de mensageria

3. Criar escalonadores de tarefas

[Maps: Chave-Valor](maps.html)
[Stacks: Pilha](stacks.html)

Tip:

"Queues são como filas digitais: justas, ordenadas e sempre processando na ordem certa!"



# Stacks: A Pilha de Downloads

```
STACK OPERATIONS
├── push() (Upload)
├── pop()  (Download)
└── peek() (Preview)
```

## Fundamentos

Stacks são como uma pilha de downloads - o último arquivo baixado é o primeiro que você acessa (LIFO).

```JAVA
// Criando uma pilha de downloads
Stack<String> downloads = new Stack<>();
downloads.push("arquivo.zip");    // Adiciona no topo
String ultimo = downloads.pop();  // Remove do topo
```

## Operações Básicas

### Push (Upload)

```JAVA
Stack<String> stack = new Stack<>();
stack.push("Camada 1");  // Base
stack.push("Camada 2");  // Meio
stack.push("Camada 3");  // Topo
```

### Pop (Download)

```JAVA
String top = stack.pop();     // Remove e retorna topo
String peek = stack.peek();   // Só espia o topo
boolean vazia = stack.empty(); // Checa se está vazia
```

### Busca

```JAVA
int posicao = stack.search("Camada 1"); // Busca na pilha
// Retorna posição (1 = topo) ou -1 se não encontrar
```

## Casos de Uso

### 1. Histórico de Navegação

```JAVA
Stack<String> historico = new Stack<>();
historico.push("homepage.html");
historico.push("perfil.html");
String voltar = historico.pop(); // Volta página
```

### 2. Desfazer/Refazer

```JAVA
Stack<Command> undoStack = new Stack<>();
undoStack.push(new Command("save"));
Command lastCommand = undoStack.pop(); // Desfaz
```

### 3. Validação de Sintaxe

```JAVA
Stack<Character> brackets = new Stack<>();
brackets.push('{');  // Abre
char close = brackets.pop(); // Fecha
// Válido se stack vazia no final
```

## Implementação Alternativa

```JAVA
// Usando Deque como Stack (mais moderno)
Deque<String> stack = new ArrayDeque<>();
stack.push("Novo");
String top = stack.pop();
```

## Dicas de Performance

```JAVA
// Vector é thread-safe mas mais lento
Stack<Integer> threadsafe = new Stack<>();

// ArrayDeque é mais rápido mas não thread-safe
Deque<Integer> fast = new ArrayDeque<>();
```

## Exercícios Práticos

1. Implemente um verificador de parênteses

2. Crie um sistema de desfazer/refazer

3. Desenvolva um navegador simplificado

## Próximos Passos

Depois de dominar Stacks, você estará pronto para:

1. Implementar históricos e navegação

2. Criar sistemas de desfazer/refazer

3. Validar expressões e sintaxe

[Queues: Filas](queues.html)
[Collections Projects](collections-projects.html)

Tip:

"Stacks são como downloads: o último que chegou é o primeiro que você acessa!"



# Projetos Práticos: Collections em Ação

## Projeto 1: Task Manager (Lista de Contratos)

### Objetivo

Criar um sistema de gerenciamento de tarefas usando diferentes Collections.

```JAVA
public class TaskManager {
    private List<Task> allTasks = new ArrayList<>();
    private Map<String, Task> taskById = new HashMap<>();
    private PriorityQueue<Task> urgentTasks = new PriorityQueue<>();
    
    public void addTask(Task task) {
        allTasks.add(task);
        taskById.put(task.getId(), task);
        if (task.isUrgent()) {
            urgentTasks.offer(task);
        }
    }
    
    public Task getNextUrgentTask() {
        return urgentTasks.poll();
    }
}
```

### Funcionalidades

* Adicionar/remover tarefas

* Priorização automática

* Busca por ID/status

* Histórico de alterações

## Projeto 2: Inventory System (Controle de Arsenal)

### Objetivo

Implementar um sistema de inventário com controle de estoque.

```JAVA
public class InventorySystem {
    private Map<String, Item> inventory = new HashMap<>();
    private Set<String> lowStock = new HashSet<>();
    private Queue<Order> pendingOrders = new LinkedList<>();
    
    public void addItem(Item item) {
        inventory.put(item.getCode(), item);
        checkStock(item);
    }
    
    private void checkStock(Item item) {
        if (item.getQuantity() < item.getMinimum()) {
            lowStock.add(item.getCode());
            createRestockOrder(item);
        }
    }
}
```

### Funcionalidades

* Controle de estoque

* Alertas de baixo estoque

* Processamento de pedidos

* Relatórios de inventário

## Projeto 3: Cache Implementation (Memória Temporária)

### Objetivo

Desenvolver um sistema de cache com política de expiração.

```JAVA
public class CacheSystem<K, V> {
    private Map<K, CacheEntry<V>> cache = new LinkedHashMap<>();
    private Queue<K> expirationQueue = new PriorityQueue<>();
    
    public void put(K key, V value, long ttl) {
        cache.put(key, new CacheEntry<>(value, ttl));
        expirationQueue.offer(key);
        cleanExpired();
    }
    
    public V get(K key) {
        CacheEntry<V> entry = cache.get(key);
        return (entry != null && !entry.isExpired()) ? entry.getValue() : null;
    }
}
```

### Funcionalidades

* Cache com TTL (Time To Live)

* Política LRU (Least Recently Used)

* Limpeza automática

* Estatísticas de hit/miss

## Desafios Extras

### 1. Sistema Multi-Thread

```JAVA
public class ThreadSafeTaskManager {
    private final ConcurrentHashMap<String, Task> tasks = new ConcurrentHashMap<>();
    private final BlockingQueue<Task> taskQueue = new LinkedBlockingQueue<>();
    
    public void processTask() {
        while (true) {
            Task task = taskQueue.take(); // Bloqueia até ter tarefa
            executeTask(task);
        }
    }
}
```

### 2. Sistema de Eventos

```JAVA
public class EventSystem {
    private final Deque<Event> eventHistory = new ArrayDeque<>();
    private final Map<String, List<EventHandler>> handlers = new HashMap<>();
    
    public void emit(Event event) {
        eventHistory.push(event);
        notifyHandlers(event);
    }
    
    public void undo() {
        if (!eventHistory.isEmpty()) {
            revertEvent(eventHistory.pop());
        }
    }
}
```

## Próximos Passos

1. Implemente os projetos base

2. Adicione funcionalidades extras

3. Otimize o código

4. Adicione testes unitários

5. Documente seu código

[Stacks: Pilhas](stacks.html)
[OOP Fundamentals](oop-fundamentals.html)

Tip:

"A verdadeira maestria vem da prática. Cada projeto é uma chance de aperfeiçoar suas habilidades!"



# Task Manager: Gerenciador de Tarefas Digital

## Objetivo do Projeto

Criar um gerenciador de tarefas simples usando arrays e collections básicas.

## Estruturas de Dados Utilizadas

```JAVA
// Lista de tarefas usando array
String[] tarefas = new String[100];
int[] prioridades = new int[100];
boolean[] concluidas = new boolean[100];
int totalTarefas = 0;

// Lista dinâmica usando ArrayList
ArrayList<String> tarefasDinamicas = new ArrayList<>();

// Fila de tarefas urgentes
Queue<String> tarefasUrgentes = new LinkedList<>();

// Mapa para busca rápida
HashMap<String, Integer> indiceTarefas = new HashMap<>();
```

## Funcionalidades Principais

### 1. Adicionar Tarefa

```JAVA
public static void adicionarTarefa(String tarefa, int prioridade) {
    if (totalTarefas < tarefas.length) {
        tarefas[totalTarefas] = tarefa;
        prioridades[totalTarefas] = prioridade;
        concluidas[totalTarefas] = false;
        
        // Adiciona nas estruturas dinâmicas
        tarefasDinamicas.add(tarefa);
        indiceTarefas.put(tarefa, totalTarefas);
        
        if (prioridade > 8) {
            tarefasUrgentes.offer(tarefa);
        }
        
        totalTarefas++;
        System.out.println("Tarefa adicionada: " + tarefa);
    }
}
```

### 2. Listar Tarefas

```JAVA
public static void listarTarefas() {
    System.out.println("\n=== Lista de Tarefas ===");
    for (int i = 0; i < totalTarefas; i++) {
        String status = concluidas[i] ? "[X]" : "[ ]";
        System.out.printf("%s %s (Prioridade: %d)%n", 
            status, tarefas[i], prioridades[i]);
    }
}
```

### 3. Marcar Como Concluída

```JAVA
public static void concluirTarefa(String tarefa) {
    Integer indice = indiceTarefas.get(tarefa);
    if (indice != null) {
        concluidas[indice] = true;
        System.out.println("Tarefa concluída: " + tarefa);
    }
}
```

### 4. Buscar Tarefas

```JAVA
public static void buscarTarefa(String termo) {
    System.out.println("\n=== Resultados da Busca ===");
    for (int i = 0; i < totalTarefas; i++) {
        if (tarefas[i].toLowerCase().contains(termo.toLowerCase())) {
            System.out.println("- " + tarefas[i]);
        }
    }
}
```

### 5. Próxima Tarefa Urgente

```JAVA
public static String proximaTarefaUrgente() {
    return tarefasUrgentes.poll();
}
```

## Exemplo de Uso

```JAVA
public static void main(String[] args) {
    // Adicionar algumas tarefas
    adicionarTarefa("Debugar código", 9);
    adicionarTarefa("Backup sistema", 7);
    adicionarTarefa("Atualizar firewall", 10);
    
    // Listar todas as tarefas
    listarTarefas();
    
    // Concluir uma tarefa
    concluirTarefa("Backup sistema");
    
    // Buscar tarefas
    buscarTarefa("firewall");
    
    // Verificar próxima tarefa urgente
    String urgente = proximaTarefaUrgente();
    System.out.println("Próxima urgente: " + urgente);
}
```

## Desafios para Praticar

1. Filtrar por Prioridade

```JAVA
public static void filtrarPorPrioridade(int minimo) {
    for (int i = 0; i < totalTarefas; i++) {
        if (prioridades[i] >= minimo) {
            System.out.println(tarefas[i]);
        }
    }
}
```

1. Remover Tarefa

```JAVA
public static void removerTarefa(String tarefa) {
    Integer indice = indiceTarefas.get(tarefa);
    if (indice != null) {
        // Shift elements
        for (int i = indice; i < totalTarefas - 1; i++) {
            tarefas[i] = tarefas[i + 1];
            prioridades[i] = prioridades[i + 1];
            concluidas[i] = concluidas[i + 1];
        }
        totalTarefas--;
        
        // Atualizar estruturas dinâmicas
        tarefasDinamicas.remove(tarefa);
        indiceTarefas.remove(tarefa);
    }
}
```

## Exercícios Propostos

1. Implementar ordenação por prioridade

2. Adicionar data limite para tarefas

3. Criar filtro por status (pendente/concluída)

4. Implementar sistema de tags usando arrays

5. Adicionar persistência em arquivo texto

## Próximos Passos

* [Inventory System](inventory-system.html)

* [Cache Implementation](cache-implementation.html)

Tip:

"Uma tarefa bem organizada é uma tarefa meio feita!"



# Sistema de Inventário (Arsenal)

Um sistema de inventário cyberpunk para gerenciar equipamentos e recursos.

## Objetivos de Aprendizado

* Implementar um sistema usando `Map`, `Set` e `Queue`

* Gerenciar estoque com estruturas de dados apropriadas

* Aplicar lógica de negócios com coleções

## Conceitos Aplicados

* HashMap para armazenamento principal

* HashSet para itens em baixo estoque

* Queue para pedidos pendentes

* Encapsulamento de dados

* Validações de negócio

## Implementação Base

### Classe Item

```JAVA
public class Item {
    private String code;
    private String name;
    private int quantity;
    private int minimum;
    private double price;

    public Item(String code, String name, int quantity, int minimum, double price) {
        this.code = code;
        this.name = name;
        this.quantity = quantity;
        this.minimum = minimum;
        this.price = price;
    }

    // Getters e Setters
    public String getCode() { return code; }
    public String getName() { return name; }
    public int getQuantity() { return quantity; }
    public int getMinimum() { return minimum; }
    public double getPrice() { return price; }

    public void setQuantity(int quantity) { this.quantity = quantity; }
}
```

### Classe Order

```JAVA
public class Order {
    private String itemCode;
    private int quantity;
    private String status;

    public Order(String itemCode, int quantity) {
        this.itemCode = itemCode;
        this.quantity = quantity;
        this.status = "PENDING";
    }

    // Getters e Setters
    public String getItemCode() { return itemCode; }
    public int getQuantity() { return quantity; }
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
}
```

### Sistema Principal

```JAVA
public class InventorySystem {
    private Map<String, Item> inventory = new HashMap<>();
    private Set<String> lowStock = new HashSet<>();
    private Queue<Order> pendingOrders = new LinkedList<>();
    
    // Adicionar item ao inventário
    public void addItem(Item item) {
        inventory.put(item.getCode(), item);
        checkStock(item);
    }
    
    // Verificar nível de estoque
    private void checkStock(Item item) {
        if (item.getQuantity() < item.getMinimum()) {
            lowStock.add(item.getCode());
            createRestockOrder(item);
        }
    }
    
    // Criar pedido de reposição
    private void createRestockOrder(Item item) {
        int orderQuantity = item.getMinimum() - item.getQuantity();
        Order order = new Order(item.getCode(), orderQuantity);
        pendingOrders.offer(order);
    }
    
    // Remover item do inventário
    public void removeItem(String code) {
        inventory.remove(code);
        lowStock.remove(code);
    }
    
    // Atualizar quantidade
    public void updateQuantity(String code, int quantity) {
        Item item = inventory.get(code);
        if (item != null) {
            item.setQuantity(quantity);
            checkStock(item);
        }
    }
    
    // Listar itens em baixo estoque
    public Set<String> getLowStockItems() {
        return new HashSet<>(lowStock);
    }
    
    // Processar próximo pedido
    public Order processNextOrder() {
        return pendingOrders.poll();
    }
}
```

## Exemplo de Uso

```JAVA
public class InventoryDemo {
    public static void main(String[] args) {
        InventorySystem system = new InventorySystem();
        
        // Adicionar itens
        system.addItem(new Item("HACK001", "NetHack Module", 5, 10, 299.99));
        system.addItem(new Item("DECK002", "CyberDeck", 2, 5, 999.99));
        
        // Verificar baixo estoque
        Set<String> lowStock = system.getLowStockItems();
        System.out.println("Itens em baixo estoque: " + lowStock);
        
        // Processar pedidos
        Order nextOrder = system.processNextOrder();
        if (nextOrder != null) {
            System.out.println("Processando pedido: " + nextOrder.getItemCode());
        }
    }
}
```

## Exercícios Propostos

1. Implementar Relatórios

* Gerar relatório de valor total do inventário

* Listar itens por faixa de preço

* Calcular estatísticas de pedidos

2. Adicionar Validações

* Verificar códigos duplicados

* Validar quantidades negativas

* Implementar limites de estoque

3. Expandir Funcionalidades

* Adicionar categorias de itens

* Implementar sistema de alertas

* Criar histórico de transações

## Desafios Avançados

1. Sistema de Prioridade

* Implementar PriorityQueue para pedidos

* Definir critérios de priorização

* Gerenciar pedidos urgentes

2. Persistência de Dados

* Salvar estado do inventário

* Carregar dados de arquivo

* Implementar backup automático

## Dicas de Implementação

* Use enums para status e categorias

* Implemente tratamento de exceções

* Mantenha o código modular

* Documente as funcionalidades

* Adicione logs de operações

## Próximos Passos

* [Cache Implementation](cache-implementation.html)

* [Collections Overview](collections-overview.html)

* [Maps](maps.html)

Tip:

"Um bom arsenal não é apenas sobre quantidade, mas sobre organização e controle."



# Implementação de Cache

Um sistema de cache é uma estrutura de dados que armazena temporariamente dados frequentemente acessados para melhorar a performance. Neste projeto, implementaremos um cache simples usando arrays e conceitos básicos de Java.

## Arquitetura do Sistema

```MERMAID
graph TD
    A[Cliente] --> B[Cache]
    B --> C[Armazenamento]
    B --> D[Estatísticas]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
```

## Componentes Principais

### Estrutura de Dados

* Arrays paralelos para chaves e valores

* Array para timestamps

* Array para contagem de acessos

* Controle de capacidade e tamanho atual

### Operações Básicas

* Inserção/atualização de itens

* Busca por chave

* Substituição de itens menos usados

* Monitoramento de estatísticas

## Implementação Base

### SimpleCache.java

```JAVA
public class SimpleCache {
    private String[] keys;
    private String[] values;
    private long[] timestamps;
    private int[] accessCount;
    private int capacity;
    private int size;
    
    public SimpleCache(int maxSize) {
        capacity = maxSize;
        keys = new String[capacity];
        values = new String[capacity];
        timestamps = new long[capacity];
        accessCount = new int[capacity];
        size = 0;
    }
    
    // Métodos principais aqui...
}
```

### Política de Substituição

O cache utiliza a estratégia LFU (Least Frequently Used):

1. Mantém contagem de acessos para cada item

2. Quando o cache está cheio, remove o item menos acessado

3. Em caso de empate, mantém o item mais antigo

## Interface de Usuário

### Menu Principal

```JAVA
System.out.println("\n=== Sistema de Cache ===");
System.out.println("1. Adicionar/Atualizar item");
System.out.println("2. Buscar item");
System.out.println("3. Mostrar estatísticas");
System.out.println("4. Sair");
```

### Visualização de Estatísticas

```
=== Cache Stats ===
Capacity: 5
Current Size: 3

Cache Contents:
Key | Value | Access Count | Age (ms)
------------------------------------
key1 | value1 | 3 | 1500
key2 | value2 | 1 | 1000
key3 | value3 | 2 | 500
```

## Desafios de Extensão

1. Implementar Cache Genérico

```JAVA
public class GenericCache<K, V> {
    private K[] keys;
    private V[] values;
    // ...
}
```

1. Adicionar Expiração de Items

```JAVA
public boolean isExpired(String key) {
    int index = findKey(key);
    if (index != -1) {
        long age = System.currentTimeMillis() - timestamps[index];
        return age > expirationTime;
    }
    return true;
}
```

1. Implementar Diferentes Políticas

* LRU (Least Recently Used)

* FIFO (First In First Out)

* Random Replacement

## Próximos Passos

1. Adicione suporte a tipos genéricos

2. Implemente expiração de itens

3. Crie diferentes políticas de substituição

4. Adicione persistência em arquivo

5. Implemente cache distribuído

## Conceitos Aplicados

* Arrays e manipulação

* Tipos primitivos

* Strings

* Estruturas de controle

* Métodos e classes

* Entrada/saída básica

## Dicas de Implementação

1. Mantenha o código organizado e bem documentado

2. Use constantes para valores fixos

3. Implemente validações de entrada

4. Adicione logs para depuração

5. Considere casos de erro

## Exercícios Propostos

1. Implemente um cache com limite de tempo

2. Crie um cache que persiste em arquivo

3. Adicione suporte a múltiplos tipos de dados

4. Implemente estatísticas avançadas

5. Crie testes unitários

[Inventory System](inventory-system.html)



# Fundamentos da Programação Orientada a Objetos

## O que é OOP?

A Programação Orientada a Objetos (OOP) é um paradigma de programação que organiza o código em objetos, que contêm dados e código. Os objetos são instâncias de classes, que servem como blueprints para criar objetos.

## Pilares da OOP

```MERMAID
graph TD
    A[OOP] --> B[Encapsulamento]
    A --> C[Herança]
    A --> D[Polimorfismo]
    A --> E[Abstração]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#00ff00
```

### Encapsulamento

* Oculta detalhes internos

* Protege dados sensíveis

* Reduz complexidade

### Herança

* Reutiliza código

* Estabelece hierarquias

* Especializa comportamentos

### Polimorfismo

* Flexibiliza interfaces

* Adapta comportamentos

* Simplifica código

### Abstração

* Modela conceitos

* Simplifica problemas

* Define interfaces

## Conceitos Fundamentais

### Classes e Objetos

```JAVA
public class Netrunner {
    private String codename;
    private int skillLevel;

    public Netrunner(String codename) {
        this.codename = codename;
        this.skillLevel = 1;
    }
}
```

### Atributos e Métodos

```JAVA
public class CyberDeck {
    // Atributos
    private int power;
    private String model;

    // Métodos
    public void upgrade() {
        this.power++;
    }
}
```

## Benefícios da OOP

1. Manutenibilidade

* Código organizado

* Fácil de atualizar

* Modular

2. Reusabilidade

* Componentes reutilizáveis

* Menos duplicação

* Economia de tempo

3. Flexibilidade

* Fácil de estender

* Adaptável

* Escalável

4. Segurança

* Controle de acesso

* Dados protegidos

* Código seguro

## Práticas Recomendadas

### Nomenclatura

* Classes: PascalCase

* Métodos: camelCase

* Variáveis: camelCase

* Constantes: UPPER_CASE

### Organização

* Uma classe por arquivo

* Pacotes lógicos

* Hierarquia clara

### Princípios

* Single Responsibility

* Open/Closed

* Liskov Substitution

* Interface Segregation

* Dependency Inversion

## Próximos Passos

1. Classes e Objetos

2. Encapsulamento

3. Herança

4. Polimorfismo

5. Interfaces e Classes Abstratas

6. Records

7. Sealed Classes

8. Projetos Práticos

## Conceitos Relacionados

* Design Patterns

* SOLID Principles

* Clean Code

* Refactoring

* Testing

[Classes e Objetos](classes-objects.html)

Tip:

"Na Matrix da programação, objetos são as unidades fundamentais de poder. Domine-os, e você dominará o código."



# Classes e Objetos

## Conceito Base

Uma classe é um template para criar objetos, definindo seus atributos e comportamentos. Um objeto é uma instância de uma classe.

```MERMAID
graph TD
    A[Classe] -->|instancia| B[Objeto]
    B -->|contém| C[Atributos]
    B -->|contém| D[Métodos]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
```

## Estrutura de uma Classe

```JAVA
public class CyberHacker {
    // Atributos
    private String handle;
    private int level;
    private double credits;

    // Construtor
    public CyberHacker(String handle) {
        this.handle = handle;
        this.level = 1;
        this.credits = 1000.0;
    }

    // Métodos
    public void hackSystem() {
        this.level++;
        this.credits += 500;
    }
}
```

## Criando Objetos

```JAVA
// Instanciando objetos
CyberHacker hacker1 = new CyberHacker("Shadowbyte");
CyberHacker hacker2 = new CyberHacker("NetPhantom");

// Usando objetos
hacker1.hackSystem();
```

## Componentes Principais

### Atributos

* Representam estado

* Definem características

* Armazenam dados

### Métodos

* Definem comportamento

* Manipulam atributos

* Executam operações

### Construtores

* Inicializam objetos

* Configuram estado inicial

* Validam parâmetros

## Boas Práticas

1. Nomeação

* Classes: PascalCase

* Métodos/Atributos: camelCase

2. Organização

* Um arquivo por classe

* Agrupamento lógico

* Pacotes estruturados

3. Responsabilidade

* Propósito único

* Coesão alta

* Acoplamento baixo

## Exercícios Práticos

```JAVA
public class DataMatrix {
    private String[] data;
    private int securityLevel;

    // Implemente os métodos:
    // 1. Construtor
    // 2. encrypt()
    // 3. decrypt()
    // 4. updateSecurity()
}
```

## Próximos Passos

[Encapsulamento](encapsulation.html)

Tip:

"No grid digital, cada objeto é um nó de poder. Construa-os com sabedoria."



# Encapsulamento

## Conceito Base

Encapsulamento é o princípio de ocultar detalhes internos e fornecer uma interface controlada para interação.

```MERMAID
graph TD
    A[Classe] -->|protege| B[Dados Privados]
    A -->|expõe| C[Interface Pública]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
```

## Implementação

```JAVA
public class SecureDataVault {
    // Dados privados
    private String[] encryptedData;
    private int accessLevel;
    private boolean isLocked;

    // Interface pública
    public void storeData(String data) {
        if (!isLocked) {
            // Lógica de armazenamento
        }
    }

    public String retrieveData(int index) {
        if (validateAccess()) {
            return encryptedData[index];
        }
        return null;
    }

    private boolean validateAccess() {
        // Lógica de validação
        return accessLevel > 2;
    }
}
```

## Modificadores de Acesso

1. private

* Acesso apenas na classe

* Máxima proteção

* Dados sensíveis

2. protected

* Acesso na hierarquia

* Classes derivadas

* Pacote atual

3. public

* Acesso universal

* Interface externa

* API pública

## Getters e Setters

```JAVA
public class CyberAccount {
    private double credits;
    private String owner;

    // Getter
    public double getCredits() {
        return credits;
    }

    // Setter com validação
    public void setCredits(double amount) {
        if (amount >= 0) {
            this.credits = amount;
        }
    }
}
```

## Benefícios

1. Segurança

* Controle de acesso

* Validação de dados

* Proteção de estado

2. Manutenção

* Mudanças internas

* Evolução segura

* Debugging simples

3. Flexibilidade

* Interface estável

* Implementação variável

* Versionamento

## Exercícios Práticos

```JAVA
public class SecuritySystem {
    // Implemente:
    // 1. Dados privados
    // 2. Getters/Setters
    // 3. Validações
    // 4. Métodos de acesso
}
```

## Próximos Passos

[Herança](inheritance.html)

Tip:

"Na matrix, a informação é poder. Proteja-a com encapsulamento."



# Herança

## Conceito Base

Herança permite que uma classe herde atributos e métodos de outra, estabelecendo uma relação "é um" entre classes.

```MERMAID
graph TD
    A[Netrunner] -->|herda de| B[Hacker]
    B -->|herda de| C[CyberOperator]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
```

## Implementação Básica

```JAVA
public class CyberOperator {
    protected String codename;
    protected int accessLevel;

    public CyberOperator(String codename) {
        this.codename = codename;
        this.accessLevel = 1;
    }

    public void accessNetwork() {
        System.out.println("Basic network access");
    }
}

public class Hacker extends CyberOperator {
    private int hackingSkill;

    public Hacker(String codename) {
        super(codename);
        this.hackingSkill = 50;
    }

    @Override
    public void accessNetwork() {
        System.out.println("Advanced network access");
    }
}
```

## Tipos de Herança

### Herança Simples

```JAVA
public class Netrunner extends Hacker {
    private String[] cyberdeckModules;
    
    public Netrunner(String codename) {
        super(codename);
        this.cyberdeckModules = new String[]{"Basic"};
    }
}
```

### Hierarquia de Classes

* Superclasse (pai)

* Subclasse (filho)

* Cadeia de herança

## Palavra-chave super

```JAVA
public class ICEBreaker extends Netrunner {
    public ICEBreaker(String codename) {
        super(codename);  // Chama construtor pai
    }

    @Override
    public void accessNetwork() {
        super.accessNetwork();  // Chama método pai
        System.out.println("Breaking ICE protocols");
    }
}
```

## Boas Práticas

1. Composição vs Herança

* Prefira composição

* Evite hierarquias profundas

* Mantenha coesão

2. Princípio LSP

* Substituição de Liskov

* Comportamento consistente

* Contratos respeitados

3. Documentação

* Documente extensões

* Explique sobreposições

* Defina contratos

## Exercícios Práticos

```JAVA
// Implemente:
public class SecuritySystem {
    // Base para sistema de segurança
}

public class FirewallSystem extends SecuritySystem {
    // Sistema específico de firewall
}

public class IntrusionDetection extends SecuritySystem {
    // Sistema de detecção
}
```

## Próximos Passos

[Polimorfismo](polymorphism.html)

Tip:

"Na hierarquia do código, cada classe herda o poder de seus ancestrais."



# Polimorfismo

## Conceito Base

Polimorfismo permite que objetos de diferentes classes sejam tratados como objetos de uma classe comum, possibilitando comportamentos diferentes através da mesma interface.

```MERMAID
graph TD
    A[CyberProgram] -->|executa como| B[Virus]
    A -->|executa como| C[Firewall]
    A -->|executa como| D[DataMiner]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
```

## Tipos de Polimorfismo

### Sobrescrita (Override)

```JAVA
public class CyberProgram {
    public void execute() {
        System.out.println("Running base program");
    }
}

public class Virus extends CyberProgram {
    @Override
    public void execute() {
        System.out.println("Infiltrating system");
    }
}
```

### Sobrecarga (Overload)

```JAVA
public class DataMiner {
    public void mine(String data) {
        // Processa string
    }

    public void mine(byte[] data) {
        // Processa bytes
    }

    public void mine(String data, int depth) {
        // Processa com profundidade
    }
}
```

## Polimorfismo em Ação

```JAVA
public class SystemInterface {
    public void executeProgram(CyberProgram program) {
        program.execute();  // Polimorfismo em tempo de execução
    }

    public static void main(String[] args) {
        SystemInterface system = new SystemInterface();
        
        CyberProgram virus = new Virus();
        CyberProgram firewall = new Firewall();
        
        system.executeProgram(virus);    // Executa como Virus
        system.executeProgram(firewall); // Executa como Firewall
    }
}
```

## Benefícios

1. Flexibilidade

* Código genérico

* Extensibilidade

* Manutenibilidade

2. Reutilização

* Interfaces comuns

* Comportamento variável

* Código limpo

3. Abstração

* Simplificação

* Encapsulamento

* Modularidade

## Padrões Comuns

### Factory Method

```JAVA
public interface CyberTool {
    void activate();
}

public class ToolFactory {
    public CyberTool createTool(String type) {
        return switch (type) {
            case "hack" -> new HackTool();
            case "scan" -> new ScanTool();
            default -> throw new IllegalArgumentException();
        };
    }
}
```

### Strategy Pattern

```JAVA
public interface AttackStrategy {
    void execute();
}

public class CyberAttack {
    private AttackStrategy strategy;
    
    public void setStrategy(AttackStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void execute() {
        strategy.execute();
    }
}
```

## Exercícios Práticos

```JAVA
// Implemente diferentes tipos de programas:
public interface Program {
    void run();
    void stop();
    String getStatus();
}

// Crie implementações para:
// 1. DataAnalyzer
// 2. NetworkScanner
// 3. SecurityMonitor
```

## Próximos Passos

[Interfaces e Classes Abstratas](interfaces-abstract.html)

Tip:

"No ciberespaço, um programa pode assumir muitas formas. O poder está na adaptação."



# Interfaces e Classes Abstratas

## Interfaces

### Definição Básica

```JAVA
public interface CyberSystem {
    void initialize();
    void shutdown();
    boolean isRunning();
    
    default void restart() {
        shutdown();
        initialize();
    }
}
```

### Implementação Múltipla

```JAVA
public interface Hackable {
    void breach();
    int getSecurityLevel();
}

public class SecurityGateway implements CyberSystem, Hackable {
    private boolean active;
    private int secLevel;

    @Override
    public void initialize() {
        active = true;
    }

    @Override
    public void shutdown() {
        active = false;
    }

    @Override
    public boolean isRunning() {
        return active;
    }

    @Override
    public void breach() {
        secLevel--;
    }

    @Override
    public int getSecurityLevel() {
        return secLevel;
    }
}
```

## Classes Abstratas

### Estrutura Base

```JAVA
public abstract class NetworkNode {
    protected String id;
    protected boolean connected;

    public NetworkNode(String id) {
        this.id = id;
        this.connected = false;
    }

    public abstract void processData(byte[] data);
    
    public void connect() {
        connected = true;
    }
}
```

### Implementação Concreta

```JAVA
public class DataNode extends NetworkNode {
    private DataProcessor processor;

    public DataNode(String id) {
        super(id);
        this.processor = new DataProcessor();
    }

    @Override
    public void processData(byte[] data) {
        if (connected) {
            processor.analyze(data);
        }
    }
}
```

## Comparação

### Interface vs Classe Abstrata

```MERMAID
graph TD
    A[Interface] -->|Características| B[Múltipla implementação<br>Apenas assinaturas<br>Métodos default]
    C[Classe Abstrata] -->|Características| D[Herança única<br>Estado e comportamento<br>Construtor]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
```

## Padrões de Uso

### Interface Funcional

```JAVA
@FunctionalInterface
public interface DataFilter {
    boolean test(byte[] data);
    
    static DataFilter combine(DataFilter f1, DataFilter f2) {
        return data -> f1.test(data) && f2.test(data);
    }
}
```

### Template Method

```JAVA
public abstract class CyberOperation {
    public final void execute() {
        preCheck();
        runOperation();
        postCheck();
    }

    protected abstract void runOperation();
    
    protected void preCheck() {
        // Implementação padrão
    }
    
    protected void postCheck() {
        // Implementação padrão
    }
}
```

## Exercícios Práticos

```JAVA
// 1. Crie uma hierarquia de sistemas de segurança
public interface SecurityProtocol {
    void authenticate();
    void encrypt(byte[] data);
    void decrypt(byte[] data);
}

// 2. Implemente um sistema de logs abstrato
public abstract class LogSystem {
    // Implemente métodos comuns e abstratos
}

// 3. Desenvolva diferentes tipos de nós de rede
public interface NetworkComponent {
    // Defina operações de rede
}
```

## Boas Práticas

1. Interface Segregation

* Interfaces pequenas e coesas

* Foco em comportamento específico

* Evite interfaces gordas

2. Abstração Apropriada

* Use classes abstratas para código comum

* Interfaces para contratos puros

* Balanceie flexibilidade e complexidade

3. Nomenclatura

* Interfaces: capacidade/comportamento

* Classes abstratas: conceito base

* Métodos: verbos/ações

## Próximos Passos

[Records](records.html)

Tip:

"Na matrix digital, interfaces e abstrações são as ferramentas que moldam a realidade do código."



# Records

## Conceito Base

Records são classes imutáveis que atuam como portadores transparentes de dados, introduzidos no Java 16.

```MERMAID
graph TD
    A[Record] -->|Gera automaticamente| B[Constructor]
    A -->|Gera automaticamente| C[Getters]
    A -->|Gera automaticamente| D[equals/hashCode]
    A -->|Gera automaticamente| E[toString]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
    style E fill:#1a1a1a,stroke:#00ff00
```

## Sintaxe Básica

```JAVA
public record NetrunnerCredentials(
    String handle,
    byte[] biometricHash,
    int clearanceLevel
) {}

// Uso
var creds = new NetrunnerCredentials("Phantom", 
    "bio123".getBytes(), 
    5);

System.out.println(creds.handle());        // Getter automático
System.out.println(creds.clearanceLevel()); // Getter automático
```

## Características Principais

### Imutabilidade

```JAVA
public record SecurityToken(
    String id,
    long timestamp,
    Set<String> permissions
) {
    // Construtor canônico validador
    public SecurityToken {
        // Cria cópia defensiva imutável
        permissions = Set.copyOf(permissions);
    }
}
```

### Métodos Adicionais

```JAVA
public record DataPacket(
    byte[] payload,
    String destination,
    int priority
) {
    // Método instance
    public boolean isHighPriority() {
        return priority > 5;
    }

    // Método static
    public static DataPacket createEmergency(String dest) {
        return new DataPacket(new byte[0], dest, 10);
    }
}
```

## Casos de Uso

### DTOs (Data Transfer Objects)

```JAVA
public record UserProfile(
    String id,
    String nickname,
    int reputationScore,
    LocalDateTime lastLogin
) {}

public record NetworkStatus(
    boolean connected,
    int latency,
    List<String> activeNodes
) {}
```

### Value Objects

```JAVA
public record IpAddress(String address) {
    public IpAddress {
        if (!isValid(address)) {
            throw new IllegalArgumentException("Invalid IP");
        }
    }

    private static boolean isValid(String addr) {
        // Validação de IP
        return addr.matches("^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$");
    }
}
```

## Interoperabilidade

### Com Interfaces

```JAVA
public interface Traceable {
    String getIdentifier();
}

public record TraceRoute(
    String source,
    String destination,
    List<String> hops
) implements Traceable {
    @Override
    public String getIdentifier() {
        return source + "->" + destination;
    }
}
```

### Com Pattern Matching

```JAVA
public void processData(Object data) {
    if (data instanceof DataPacket(var payload, var dest, var priority)) {
        System.out.printf("Packet to %s with priority %d%n", 
            dest, priority);
    }
}
```

## Boas Práticas

1. Uso Apropriado

* Para dados imutáveis

* Para transferência de dados

* Para objetos de valor

2. Validação

* No construtor canônico

* Cópias defensivas

* Invariantes de negócio

3. Limitações

* Não podem estender classes

* Sempre são final

* Campos sempre são final

## Exercícios Práticos

```JAVA
// 1. Crie um record para configurações
public record SystemConfig(
    int maxConnections,
    Duration timeout,
    Set<String> allowedIPs
) {
    // Adicione validações
}

// 2. Implemente um record para métricas
public record NetworkMetrics(
    long bytesTransferred,
    int activeConnections,
    double throughput
) {
    // Adicione métodos úteis
}

// 3. Desenvolva um record para eventos
public record SecurityEvent(
    String eventId,
    LocalDateTime timestamp,
    String description,
    SecurityLevel level
) {
    // Implemente lógica adicional
}
```

## Próximos Passos

[Sealed Classes](sealed-classes.html)

Tip:

"Records: quando seus dados precisam ser tão transparentes quanto o vidro e tão imutáveis quanto a lei da física digital."



# Sealed Classes

## Conceito Base

Sealed Classes controlam a hierarquia de herança, permitindo apenas classes específicas como subclasses.

```MERMAID
graph TD
    A[Sealed Class/Interface] -->|permits| B[Subclasse 1]
    A -->|permits| C[Subclasse 2]
    A -->|permits| D[Subclasse 3]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#00ff00
    style C fill:#1a1a1a,stroke:#00ff00
    style D fill:#1a1a1a,stroke:#00ff00
```

## Sintaxe Básica

```JAVA
public sealed interface CyberwareComponent 
    permits NeuralImplant, BiometricEnhancer, CombatModule {
    
    void initialize();
    int getPowerConsumption();
}

public final class NeuralImplant implements CyberwareComponent {
    @Override
    public void initialize() {
        // Implementação
    }

    @Override
    public int getPowerConsumption() {
        return 50;
    }
}

public non-sealed class BiometricEnhancer 
    implements CyberwareComponent {
    // Implementação
}

public sealed class CombatModule implements CyberwareComponent 
    permits RangedModule, MeleeModule {
    // Implementação
}
```

## Modificadores de Permissão

### final

```JAVA
public sealed class SecurityProtocol 
    permits BiometricAuth, TokenAuth {
    // Base implementation
}

public final class BiometricAuth extends SecurityProtocol {
    // Não pode ser estendida
}
```

### non-sealed

```JAVA
public sealed interface DataProcessor 
    permits StreamProcessor, BatchProcessor {
    void process(byte[] data);
}

public non-sealed class StreamProcessor 
    implements DataProcessor {
    // Pode ser estendida por qualquer classe
}
```

### sealed

```JAVA
public sealed interface NetworkNode 
    permits Router, Switch, Firewall {
    void connect();
    void disconnect();
}

public sealed class Router implements NetworkNode 
    permits CoreRouter, EdgeRouter {
    // Implementação
}
```

## Pattern Matching

```JAVA
public String analyzeComponent(CyberwareComponent component) {
    return switch (component) {
        case NeuralImplant n -> 
            "Neural Implant: Power=" + n.getPowerConsumption();
        case BiometricEnhancer b -> 
            "Biometric: Power=" + b.getPowerConsumption();
        case CombatModule c -> 
            "Combat: Power=" + c.getPowerConsumption();
    };
}
```

## Casos de Uso

### Hierarquia de Comandos

```JAVA
public sealed interface Command 
    permits QueryCommand, UpdateCommand, DeleteCommand {
    void execute();
}

public final class QueryCommand implements Command {
    private final String query;
    
    @Override
    public void execute() {
        // Implementação
    }
}
```

### Sistema de Plugins

```JAVA
public sealed interface Plugin 
    permits SecurityPlugin, NetworkPlugin, DataPlugin {
    void load();
    void unload();
    String getVersion();
}
```

## Boas Práticas

1. Hierarquia Clara

* Defina hierarquias explícitas

* Limite extensibilidade apropriadamente

* Documente o propósito de cada permissão

2. Escolha de Modificadores

* Use `final` para folhas da hierarquia

* Use `non-sealed` para pontos de extensão

* Use `sealed` para controle intermediário

3. Pattern Matching

* Aproveite o pattern matching exaustivo

* Combine com records quando apropriado

* Mantenha switches concisos

## Exercícios Práticos

```JAVA
// 1. Sistema de Protocolos de Rede
public sealed interface NetworkProtocol 
    permits TCP, UDP, ICMP {
    void sendPacket(byte[] data);
    void receivePacket();
}

// 2. Hierarquia de Eventos
public sealed class SystemEvent 
    permits UserEvent, NetworkEvent, SecurityEvent {
    private final LocalDateTime timestamp;
    // Implementação
}

// 3. Framework de Processamento
public sealed interface DataProcessor 
    permits RealTimeProcessor, BatchProcessor {
    void process(List<byte[]> data);
    ProcessingStats getStats();
}
```

## Próximos Passos

[Projetos OOP](oop-projects.html)

Tip:

"Em um mundo digital sem fronteiras, sealed classes são as muralhas que protegem sua hierarquia de código."



# Projetos OOP

## Visão Geral

```MERMAID
graph TD
    A[Projetos OOP] --> B[Sistema Bancário]
    A --> C[Hierarquia de Formas]
    A --> D[Sistema de Plugins]
    
    B --> B1[Contas]
    B --> B2[Transações]
    B --> B3[Segurança]
    
    C --> C1[Renderização]
    C --> C2[Cálculos]
    C --> C3[Transformações]
    
    D --> D1[Carregamento]
    D --> D2[Extensibilidade]
    D --> D3[Integração]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style C fill:#1a1a1a,stroke:#33ccff
    style D fill:#1a1a1a,stroke:#33ccff
```

## Estrutura dos Projetos

```
PROJETO
├── src/
│   ├── main/
│   │   └── java/
│   │       └── com/
│   │           └── netrunner/
│   │               └── project/
│   │                   ├── core/
│   │                   ├── model/
│   │                   ├── service/
│   │                   └── util/
│   └── test/
│       └── java/
└── README.md
```

## Sistema Bancário Digital

### Objetivos de Aprendizado

* Encapsulamento de dados sensíveis

* Herança para diferentes tipos de contas

* Polimorfismo em operações financeiras

* Interfaces para serviços bancários

* Records para transações imutáveis

* Classes seladas para hierarquia de contas

### Componentes Principais

```JAVA
// Hierarquia de contas
public sealed abstract class Account 
    permits CheckingAccount, SavingsAccount, CryptoAccount {
    
    private final String id;
    private BigDecimal balance;
    private final SecurityModule security;
    
    // Métodos abstratos e concretos
}

// Transações imutáveis
public record Transaction(
    String id,
    BigDecimal amount,
    LocalDateTime timestamp,
    TransactionType type,
    String description
) {}

// Interface de serviços
public interface BankingService {
    void processTransaction(Transaction tx);
    Account getAccount(String id);
    List<Transaction> getHistory(String accountId);
}
```

## Hierarquia de Formas

### Objetivos de Aprendizado

* Abstração de formas geométricas

* Herança para especialização

* Polimorfismo em renderização

* Interfaces para comportamentos

* Records para pontos e dimensões

* Classes seladas para tipos de formas

### Componentes Principais

```JAVA
// Ponto imutável
public record Point(double x, double y) {
    public double distanceTo(Point other) {
        // Cálculo de distância
    }
}

// Hierarquia de formas
public sealed interface Shape 
    permits Circle, Rectangle, Triangle {
    
    double area();
    double perimeter();
    void render(Graphics g);
    boolean contains(Point p);
}

// Transformações
public interface Transformable {
    void rotate(double angle);
    void scale(double factor);
    void translate(Point delta);
}
```

## Sistema de Plugins

### Objetivos de Aprendizado

* Interfaces para extensibilidade

* Carregamento dinâmico

* Gerenciamento de dependências

* Padrão Observer para eventos

* Records para configurações

* Classes seladas para tipos de plugins

### Componentes Principais

```JAVA
// Configuração de plugin
public record PluginConfig(
    String name,
    String version,
    Set<String> dependencies,
    Map<String, String> settings
) {}

// Interface base de plugin
public sealed interface Plugin 
    permits SecurityPlugin, NetworkPlugin, DataPlugin {
    
    void initialize(PluginConfig config);
    void start();
    void stop();
    String getStatus();
}

// Gerenciador de plugins
public class PluginManager {
    private final Map<String, Plugin> plugins;
    private final DependencyResolver resolver;
    
    public void loadPlugin(String path) {
        // Carregamento dinâmico
    }
}
```

## Desafios Extras

### Sistema Bancário

* Implementar criptografia de dados

* Adicionar autenticação biométrica

* Criar sistema de alertas

* Implementar transações programadas

* Adicionar suporte multi-moeda

### Hierarquia de Formas

* Implementar formas 3D

* Adicionar animações

* Criar sistema de colisões

* Implementar exportação SVG

* Adicionar efeitos visuais

### Sistema de Plugins

* Implementar hot-reload

* Adicionar versionamento

* Criar marketplace

* Implementar sandbox

* Adicionar telemetria

## Dicas de Implementação

1. Planejamento

* Comece com diagramas UML

* Identifique abstrações

* Defina interfaces claras

2. Desenvolvimento

* Use TDD

* Refatore frequentemente

* Documente decisões

3. Testes

* Cubra casos de borda

* Teste integrações

* Valide segurança

## Próximos Passos

[Sistema Bancário](banking-system.html)

Tip:

"Na Matrix do código orientado a objetos, cada projeto é uma oportunidade de criar um universo digital coerente e extensível."



# Sistema Bancário Digital

## Arquitetura do Sistema

```MERMAID
graph TD
    A[Sistema Bancário] --> B[Core]
    A --> C[Serviços]
    A --> D[Segurança]
    
    B --> B1[Contas]
    B --> B2[Transações]
    B --> B3[Usuários]
    
    C --> C1[Transferências]
    C --> C2[Investimentos]
    C --> C3[Pagamentos]
    
    D --> D1[Autenticação]
    D --> D2[Criptografia]
    D --> D3[Auditoria]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style C fill:#1a1a1a,stroke:#33ccff
    style D fill:#1a1a1a,stroke:#ff3366
```

## Estrutura do Código

### Hierarquia de Contas

```JAVA
public sealed abstract class Account 
    permits CheckingAccount, SavingsAccount, CryptoAccount {
    
    private final String id;
    private final String userId;
    private BigDecimal balance;
    private final SecurityModule security;
    
    public abstract boolean withdraw(BigDecimal amount);
    public abstract boolean deposit(BigDecimal amount);
    public abstract AccountType getType();
    
    protected final void logTransaction(TransactionType type, 
                                      BigDecimal amount) {
        // Logging seguro
    }
}

public final class CheckingAccount extends Account {
    private final BigDecimal overdraftLimit;
    
    @Override
    public boolean withdraw(BigDecimal amount) {
        if (getBalance().add(overdraftLimit).compareTo(amount) < 0) {
            return false;
        }
        // Processamento do saque
        return true;
    }
    // Outros métodos
}
```

### Sistema de Transações

```JAVA
public record Transaction(
    String id,
    String accountId,
    BigDecimal amount,
    TransactionType type,
    LocalDateTime timestamp,
    String description,
    TransactionStatus status
) {}

public interface TransactionProcessor {
    TransactionResult process(Transaction tx);
    void rollback(String txId);
    TransactionStatus checkStatus(String txId);
}

public class SecureTransactionProcessor 
    implements TransactionProcessor {
    
    private final SecurityModule security;
    private final TransactionLogger logger;
    
    @Override
    public TransactionResult process(Transaction tx) {
        try {
            security.validateTransaction(tx);
            // Processamento
            logger.logSuccess(tx);
            return TransactionResult.success(tx.id());
        } catch (SecurityException e) {
            logger.logFailure(tx, e);
            return TransactionResult.failure(tx.id(), e);
        }
    }
}
```

### Módulo de Segurança

```JAVA
public final class SecurityModule {
    private final EncryptionService encryption;
    private final AuthenticationService auth;
    private final AuditLogger audit;
    
    public void validateTransaction(Transaction tx) {
        if (!auth.isAuthenticated()) {
            throw new SecurityException("Não autenticado");
        }
        
        if (!encryption.isSecureChannel()) {
            throw new SecurityException("Canal inseguro");
        }
        
        audit.logAccess(tx);
    }
}
```

## Implementação Passo a Passo

1. Configuração Inicial

```JAVA
public class BankSystem {
    private final AccountRepository accounts;
    private final TransactionProcessor txProcessor;
    private final SecurityModule security;

    public BankSystem() {
        this.security = new SecurityModule();
        this.accounts = new AccountRepository();
        this.txProcessor = new SecureTransactionProcessor(security);
    }
}
```

2. Criação de Conta

```JAVA
public class AccountService {
    public Account createAccount(AccountType type, 
                               String userId) {
        return switch (type) {
            case CHECKING -> new CheckingAccount(userId);
            case SAVINGS -> new SavingsAccount(userId);
            case CRYPTO -> new CryptoAccount(userId);
        };
    }
}
```

3. Processamento de Transações

```JAVA
public class TransactionService {
    public TransactionResult transfer(String fromId, 
                                    String toId, 
                                    BigDecimal amount) {
        var tx = new Transaction(
            UUID.randomUUID().toString(),
            fromId,
            amount,
            TransactionType.TRANSFER,
            LocalDateTime.now(),
            "Transferência entre contas",
            TransactionStatus.PENDING
        );

        return txProcessor.process(tx);
    }
}
```

## Testes

```JAVA
@Test
void testOverdraftLimit() {
    var account = new CheckingAccount("user123");
    account.deposit(new BigDecimal("100.00"));
    
    assertFalse(account.withdraw(new BigDecimal("150.00")));
    assertEquals(new BigDecimal("100.00"), account.getBalance());
}

@Test
void testSecureTransaction() {
    var processor = new SecureTransactionProcessor(
        new SecurityModule()
    );
    
    var tx = new Transaction(/* ... */);
    var result = processor.process(tx);
    
    assertTrue(result.isSuccess());
    assertEquals(TransactionStatus.COMPLETED, 
                processor.checkStatus(tx.id()));
}
```

## Considerações de Segurança

1. Criptografia

* Dados em repouso

* Dados em trânsito

* Chaves seguras

2. Autenticação

* Multi-fator

* Biometria

* Tokens JWT

3. Auditoria

* Logs detalhados

* Trilha de auditoria

* Alertas de segurança

## Próximos Passos

[Hierarquia de Formas](shape-hierarchy.html)

Tip:

"No submundo digital das finanças, a segurança não é apenas uma característica - é uma necessidade."



# Hierarquia de Formas Geométricas

## Visão Geral

Este projeto implementa um sistema de formas geométricas usando conceitos avançados de Programação Orientada a Objetos em Java.

```MERMAID
graph TD
    A[Shape] --> B[Circle]
    A --> C[Rectangle]
    A --> D[Triangle]
    E[Point] --> B
    E --> C
    E --> D
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style C fill:#1a1a1a,stroke:#33ccff
    style D fill:#1a1a1a,stroke:#33ccff
    style E fill:#1a1a1a,stroke:#ff3366
```

## Conceitos Demonstrados

* Classes seladas (sealed classes)

* Records para dados imutáveis

* Herança e polimorfismo

* Classes e métodos abstratos

* Encapsulamento

* Geometria computacional

## Estrutura do Projeto

### Classe Base: Shape

```JAVA
public sealed abstract class Shape permits Circle, Rectangle, Triangle {
    private Point position;
    private String color;
    
    // Métodos abstratos que todas as formas devem implementar
    public abstract double area();
    public abstract double perimeter();
    public abstract boolean contains(Point point);
}
```

### Record Point

```JAVA
public record Point(double x, double y) {
    public double distanceTo(Point other) {
        double dx = this.x - other.x;
        double dy = this.y - other.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
}
```

## Implementações

### Circle

* Usa um ponto central e raio

* Área: πr²

* Perímetro: 2πr

* Contém ponto: distância ao centro ≤ raio

### Rectangle

* Definido por ponto superior esquerdo, largura e altura

* Área: largura × altura

* Perímetro: 2(largura + altura)

* Contém ponto: verifica coordenadas x,y dentro dos limites

### Triangle

* Definido por três pontos

* Área: Fórmula de Heron

* Perímetro: soma das distâncias entre pontos

* Contém ponto: coordenadas baricêntricas

## Exemplo de Uso

```JAVA
// Criar formas
Circle circle = new Circle(new Point(0, 0), 5, "red");
Rectangle rectangle = new Rectangle(new Point(2, 2), 4, 3, "blue");
Triangle triangle = new Triangle(
    new Point(0, 0),
    new Point(3, 0),
    new Point(0, 4),
    "green"
);

// Array polimórfico
Shape[] shapes = {circle, rectangle, triangle};

// Operações com formas
for (Shape shape : shapes) {
    System.out.println("Área: " + shape.area());
    System.out.println("Perímetro: " + shape.perimeter());
}
```

## Exercícios Práticos

1. Extensão Básica

* Adicione uma nova forma (ex: Hexágono)

* Implemente rotação para as formas

* Adicione cálculo de escala

2. Funcionalidades Avançadas

* Detecção de colisão entre formas

* Transformações geométricas

* Serialização de formas

3. Interface Gráfica

* Renderização das formas

* Interface para criar/editar formas

* Animações de movimento

## Desafios

1. Otimização

* Melhore o algoritmo de verificação de ponto em triângulo

* Implemente cache para cálculos frequentes

* Otimize operações em lote

2. Extensibilidade

* Adicione sistema de eventos

* Implemente padrão Observer

* Crie sistema de plugins

## Dicas de Implementação

1. Precisão Numérica

* Use `double` para cálculos geométricos

* Considere tolerância em comparações

* Implemente arredondamento adequado

2. Boas Práticas

* Valide parâmetros nos construtores

* Mantenha imutabilidade onde possível

* Use nomes descritivos

3. Testes

* Teste casos limites

* Verifique formas degeneradas

* Valide transformações

## Recursos Adicionais

* [Geometria Computacional](https://www.geeksforgeeks.org/computational-geometry-introduction/)

* [Java Graphics2D](https://docs.oracle.com/javase/tutorial/2d/index.html)

* [Matemática para Programadores](https://www.mathsisfun.com/geometry/index.html)

## Próximos Passos

* Explore padrões de design relacionados

* Implemente persistência de dados

* Adicione suporte a formas compostas



# Sistema de Plugins

## Visão Geral

Este projeto implementa um sistema de plugins básico usando Java, demonstrando conceitos fundamentais de programação orientada a objetos e estruturas de dados básicas.

```MERMAID
graph TD
    A[PluginSystem] --> B[Plugin]
    B --> C[name]
    B --> D[commands]
    B --> E[isEnabled]
    A --> F[plugins array]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style F fill:#1a1a1a,stroke:#ff3366
```

## Componentes Principais

### Classe Plugin

A classe `Plugin` representa um plugin individual no sistema:

```JAVA
public class Plugin {
    private String name;
    private boolean isEnabled;
    private String[] commands;

    // Construtor e métodos principais
    public Plugin(String name, String[] commands) {
        this.name = name;
        this.isEnabled = false;
        this.commands = commands;
    }

    public void enable() {
        isEnabled = true;
    }

    public void disable() {
        isEnabled = false;
    }

    public void executeCommand(String command) {
        // Executa um comando se o plugin estiver ativado
    }
}
```

### Sistema de Gerenciamento

A classe `PluginSystem` gerencia todos os plugins:

```JAVA
public class PluginSystem {
    private Plugin[] plugins;
    private int pluginCount;
    private static final int MAX_PLUGINS = 10;

    public void addPlugin(Plugin plugin) {
        // Adiciona um novo plugin ao sistema
    }

    public void enablePlugin(String name) {
        // Ativa um plugin específico
    }

    public void disablePlugin(String name) {
        // Desativa um plugin específico
    }

    public void executeCommand(String pluginName, String command) {
        // Executa um comando em um plugin específico
    }
}
```

## Funcionalidades Principais

1. Gerenciamento de Plugins

* Adicionar plugins

* Ativar/desativar plugins

* Listar plugins instalados

2. Sistema de Comandos

* Cada plugin possui seus próprios comandos

* Verificação de comandos disponíveis

* Execução segura de comandos

3. Estado dos Plugins

* Controle de estado (ativado/desativado)

* Verificação antes da execução

* Feedback de operações

## Exemplo de Uso

```JAVA
// Criar sistema de plugins
PluginSystem system = new PluginSystem();

// Criar um plugin de calculadora
Plugin calculadora = new Plugin("Calculadora", 
    new String[]{"somar", "subtrair", "multiplicar"});

// Adicionar ao sistema
system.addPlugin(calculadora);

// Ativar o plugin
system.enablePlugin("Calculadora");

// Executar um comando
system.executeCommand("Calculadora", "somar");
```

## Exercícios Práticos

1. Plugin Básico

* Crie um novo plugin com comandos personalizados

* Implemente a lógica de execução dos comandos

* Teste a ativação e desativação

2. Sistema de Plugins

* Adicione múltiplos plugins ao sistema

* Gerencie as interações entre plugins

* Implemente listagem de plugins

3. Comandos Personalizados

* Crie comandos com parâmetros

* Implemente validação de comandos

* Adicione feedback de execução

## Boas Práticas

1. Organização do Código

* Mantenha métodos curtos e focados

* Use nomes descritivos para variáveis

* Comente seções importantes do código

2. Validação

* Verifique estados antes de executar ações

* Valide entradas de usuário

* Forneça feedback claro

3. Manutenção

* Mantenha o código organizado

* Documente funcionalidades

* Teste todas as operações

## Próximos Passos

* Adicione mais tipos de plugins

* Implemente sistema de configuração

* Crie uma interface de usuário simples

* Adicione persistência de dados

## Recursos Adicionais

* [Documentação Java](https://docs.oracle.com/javase/tutorial/)

* [Boas Práticas de Programação](https://www.oracle.com/java/technologies/javase/codeconventions.html)



# Tratamento de Erros em Java

O tratamento de erros é uma parte fundamental da programação em Java, permitindo que você lide com situações inesperadas de forma elegante e robusta.

## Por que o Tratamento de Erros é Importante?

```MERMAID
graph TD
    A[Programa] --> B{Erro?}
    B -->|Sim| C[Tratamento de Erro]
    B -->|Não| D[Fluxo Normal]
    C --> E[Recuperação]
    C --> F[Log]
    C --> G[Feedback ao Usuário]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#ff3366
    style C fill:#1a1a1a,stroke:#33ccff
```

### Benefícios Principais

1. Robustez

* Previne falhas catastróficas

* Mantém o programa funcionando

* Garante consistência dos dados

2. Experiência do Usuário

* Mensagens de erro claras

* Feedback apropriado

* Recuperação graciosa

3. Manutenibilidade

* Código mais organizado

* Melhor depuração

* Logs mais efetivos

## Conceitos Fundamentais

### Tipos de Erros

1. Erros de Compilação

* Sintaxe incorreta

* Tipos incompatíveis

* Recursos não encontrados

2. Erros de Runtime

* Divisão por zero

* Null pointer

* Array index out of bounds

3. Erros Lógicos

* Bugs de negócio

* Cálculos incorretos

* Fluxos inesperados

### Hierarquia de Exceções

```JAVA
try {
    // Código que pode gerar exceção
    riskyOperation();
} catch (Exception e) {
    // Tratamento do erro
    handleError(e);
} finally {
    // Código que sempre executa
    cleanup();
}
```

## Tópicos Principais

Este módulo abordará:

* [Exceções em Java](exceptions.html)

* [Try-Catch e Finally](try-catch.html)

* [Exceções Personalizadas](custom-exceptions.html)

* [Try-with-Resources](try-with-resources.html)

## Melhores Práticas

1. Nunca Ignore Exceções

```JAVA
try {
    // operação
} catch (Exception e) {
    // NO MÍNIMO faça log do erro
    logger.error("Erro na operação", e);
}
```

2. Use Exceções Específicas

```JAVA
try {
    // operação
} catch (FileNotFoundException e) {
    // tratamento específico
} catch (IOException e) {
    // tratamento mais genérico
}
```

3. Documente Exceções

```JAVA
/**
 * @throws IllegalArgumentException se o valor for negativo
 */
public void setValue(int value) {
    if (value < 0) {
        throw new IllegalArgumentException("Valor não pode ser negativo");
    }
}
```

## Próximos Passos

* Explore os diferentes tipos de exceções

* Pratique criando exceções personalizadas

* Implemente tratamento de erros em seus projetos

* Aprenda sobre logging e debugging

## Recursos Adicionais

* [Java Exception Handling Tutorial](https://docs.oracle.com/javase/tutorial/essential/exceptions/)

* [Best Practices for Exception Handling](https://www.oracle.com/java/technologies/javase/exceptions.html)

Tip:

"Em um mundo perfeito, não precisaríamos de tratamento de erros. Mas no mundo real, ele é tão essencial quanto o próprio código."

[Começar com Exceções](exceptions.html)



# Exceções em Java

## Hierarquia de Exceções

```MERMAID
graph TD
    A[Throwable] --> B[Error]
    A --> C[Exception]
    C --> D[RuntimeException]
    C --> E[CheckedException]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#ff3366
    style C fill:#1a1a1a,stroke:#33ccff
```

## Tipos de Exceções

### 1. Checked Exceptions

* Verificadas em tempo de compilação

* Devem ser declaradas ou tratadas

* Exemplos: `IOException`, `SQLException`

```JAVA
public void readFile() throws IOException {
    FileReader file = new FileReader("arquivo.txt");
    // código para ler arquivo
}
```

### 2. Unchecked Exceptions (RuntimeException)

* Não verificadas em tempo de compilação

* Geralmente indicam erros de programação

* Exemplos: `NullPointerException`, `ArrayIndexOutOfBoundsException`

```JAVA
public void processArray(int[] array) {
    // Pode lançar NullPointerException ou ArrayIndexOutOfBoundsException
    int value = array[10];
}
```

### 3. Errors

* Problemas graves na JVM

* Não devem ser tratados pelo programa

* Exemplos: `OutOfMemoryError`, `StackOverflowError`

## Exceções Comuns

1. NullPointerException

```JAVA
String str = null;
str.length(); // Lança NullPointerException
```

1. ArrayIndexOutOfBoundsException

```JAVA
int[] array = new int[5];
array[10] = 1; // Lança ArrayIndexOutOfBoundsException
```

1. IllegalArgumentException

```JAVA
public void setAge(int age) {
    if (age < 0) {
        throw new IllegalArgumentException("Idade não pode ser negativa");
    }
}
```

## Boas Práticas

1. Seja Específico

* Use exceções específicas em vez de genéricas

* Ajuda na identificação e tratamento do problema

1. Documente as Exceções

```JAVA
/**
 * @throws IllegalArgumentException se o valor for negativo
 * @throws IOException em caso de erro de leitura
 */
public void processValue(int value) throws IOException {
    // implementação
}
```

1. Mantenha a Granularidade

* Lance exceções no nível mais baixo possível

* Trate no nível apropriado da aplicação

## Exemplos Práticos

### Exemplo 1: Validação de Entrada

```JAVA
public class UserValidator {
    public void validateUsername(String username) {
        if (username == null || username.trim().isEmpty()) {
            throw new IllegalArgumentException("Username não pode ser vazio");
        }
        if (username.length() < 3) {
            throw new IllegalArgumentException("Username deve ter no mínimo 3 caracteres");
        }
    }
}
```

### Exemplo 2: Operações de Arquivo

```JAVA
public class FileProcessor {
    public String readFile(String path) throws IOException {
        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
            return reader.readLine();
        }
    }
}
```

## Próximos Passos

* Aprenda sobre [Try-Catch e Finally](try-catch.html)

* Explore [Exceções Personalizadas](custom-exceptions.html)

* Estude [Try-with-Resources](try-with-resources.html)

## Recursos Adicionais

* [Java Exception Tutorial](https://docs.oracle.com/javase/tutorial/essential/exceptions/)

* [Java Exception Best Practices](https://www.oracle.com/java/technologies/javase/exceptions.html)



# Try-Catch e Finally em Java

## Estrutura Básica

```JAVA
try {
    // Código que pode lançar exceção
} catch (ExceptionType e) {
    // Tratamento da exceção
} finally {
    // Código que sempre executa
}
```

## Blocos Try-Catch

### Try Block

* Contém código que pode lançar exceções

* Pode conter múltiplas linhas

* Deve ser seguido por catch ou finally

```JAVA
try {
    int result = 10 / 0;  // Lança ArithmeticException
    System.out.println(result);
}
```

### Catch Block

* Captura e trata exceções específicas

* Pode ter múltiplos blocos catch

* Deve ser ordenado do mais específico para o mais genérico

```JAVA
try {
    // código arriscado
} catch (ArithmeticException e) {
    System.out.println("Erro de divisão: " + e.getMessage());
} catch (Exception e) {
    System.out.println("Erro genérico: " + e.getMessage());
}
```

### Finally Block

* Sempre executa, independente de exceção

* Útil para limpeza de recursos

* Opcional, mas importante para boas práticas

```JAVA
FileReader reader = null;
try {
    reader = new FileReader("file.txt");
    // processar arquivo
} catch (IOException e) {
    System.out.println("Erro ao ler arquivo");
} finally {
    if (reader != null) {
        try {
            reader.close();
        } catch (IOException e) {
            // handle close exception
        }
    }
}
```

## Padrões Comuns

### 1. Múltiplos Catch

```JAVA
try {
    // código arriscado
} catch (FileNotFoundException e) {
    // tratamento específico para arquivo não encontrado
} catch (IOException e) {
    // tratamento para outros erros de I/O
} catch (Exception e) {
    // tratamento para qualquer outra exceção
}
```

### 2. Multi-catch (Java 7+)

```JAVA
try {
    // código arriscado
} catch (IOException | SQLException e) {
    // tratamento comum para ambas exceções
}
```

### 3. Rethrow

```JAVA
try {
    // código arriscado
} catch (Exception e) {
    // log do erro
    logger.error("Erro durante processamento", e);
    throw e; // relança a exceção
}
```

## Boas Práticas

1. Seja Específico

```JAVA
// Ruim
try {
    // código
} catch (Exception e) { }

// Bom
try {
    // código
} catch (FileNotFoundException e) {
    // tratamento específico
}
```

1. Log Adequado

```JAVA
try {
    // código
} catch (Exception e) {
    logger.error("Contexto do erro: " + e.getMessage(), e);
}
```

1. Limpeza de Recursos

```JAVA
Connection conn = null;
try {
    conn = getConnection();
    // usar conexão
} finally {
    if (conn != null) {
        conn.close();
    }
}
```

## Exemplos Práticos

### Exemplo 1: Processamento de Arquivo

```JAVA
public class FileProcessor {
    public void processFile(String path) {
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader(path));
            String line;
            while ((line = reader.readLine()) != null) {
                processLine(line);
            }
        } catch (FileNotFoundException e) {
            System.err.println("Arquivo não encontrado: " + path);
        } catch (IOException e) {
            System.err.println("Erro ao ler arquivo: " + e.getMessage());
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    System.err.println("Erro ao fechar arquivo");
                }
            }
        }
    }
}
```

### Exemplo 2: Operações de Banco de Dados

```JAVA
public class DatabaseOperations {
    public void updateRecord(int id, String data) {
        Connection conn = null;
        PreparedStatement stmt = null;
        try {
            conn = getConnection();
            stmt = conn.prepareStatement("UPDATE records SET data = ? WHERE id = ?");
            stmt.setString(1, data);
            stmt.setInt(2, id);
            stmt.executeUpdate();
        } catch (SQLException e) {
            System.err.println("Erro de banco de dados: " + e.getMessage());
        } finally {
            closeResources(conn, stmt);
        }
    }
}
```

## Próximos Passos

* Aprenda sobre [Try-with-Resources](try-with-resources.html)

* Explore [Exceções Personalizadas](custom-exceptions.html)

* Pratique com diferentes tipos de exceções

## Recursos Adicionais

* [Java Exception Handling Tutorial](https://docs.oracle.com/javase/tutorial/essential/exceptions/)

* [Best Practices for Exception Handling](https://www.oracle.com/java/technologies/javase/exceptions.html)



# Exceções Personalizadas em Java

## Introdução

Exceções personalizadas permitem criar tipos específicos de erro para seu domínio de negócio, tornando o código mais expressivo e manutenível.

## Criando Exceções Personalizadas

### Exceção Verificada (Checked)

```JAVA
public class BusinessException extends Exception {
    public BusinessException(String message) {
        super(message);
    }

    public BusinessException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

### Exceção Não Verificada (Unchecked)

```JAVA
public class ValidationException extends RuntimeException {
    public ValidationException(String message) {
        super(message);
    }

    public ValidationException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

## Padrões Comuns

### 1. Exceções de Domínio

```JAVA
public class UserNotFoundException extends RuntimeException {
    private final String userId;

    public UserNotFoundException(String userId) {
        super("Usuário não encontrado: " + userId);
        this.userId = userId;
    }

    public String getUserId() {
        return userId;
    }
}
```

### 2. Exceções com Dados Adicionais

```JAVA
public class OrderProcessingException extends Exception {
    private final String orderId;
    private final OrderStatus status;

    public OrderProcessingException(String message, String orderId, OrderStatus status) {
        super(message);
        this.orderId = orderId;
        this.status = status;
    }

    // Getters para informações adicionais
    public String getOrderId() { return orderId; }
    public OrderStatus getStatus() { return status; }
}
```

## Exemplos de Uso

### Exemplo 1: Validação de Negócio

```JAVA
public class UserService {
    public void createUser(User user) throws ValidationException {
        if (user.getAge() < 18) {
            throw new ValidationException("Usuário deve ser maior de idade");
        }
        if (user.getEmail() == null || !user.getEmail().contains("@")) {
            throw new ValidationException("Email inválido");
        }
        // Continua processamento
    }
}
```

### Exemplo 2: Processamento de Pedidos

```JAVA
public class OrderProcessor {
    public void processOrder(Order order) throws OrderProcessingException {
        try {
            validateOrder(order);
            calculateTotal(order);
            saveOrder(order);
        } catch (Exception e) {
            throw new OrderProcessingException(
                "Erro ao processar pedido",
                order.getId(),
                order.getStatus()
            );
        }
    }
}
```

## Boas Práticas

1. Nomeação Clara

```JAVA
// Bom
public class InvalidPasswordException extends RuntimeException { }

// Ruim
public class PasswordException extends RuntimeException { }
```

1. Informações Relevantes

```JAVA
public class DatabaseConnectionException extends Exception {
    public DatabaseConnectionException(String server, int port, Throwable cause) {
        super(String.format("Falha ao conectar ao servidor %s:%d", server, port), cause);
    }
}
```

1. Hierarquia Apropriada

```JAVA
// Exceção base para o módulo
public abstract class PaymentException extends Exception { }

// Exceções específicas
public class PaymentDeclinedException extends PaymentException { }
public class InsufficientFundsException extends PaymentException { }
```

## Exemplos Práticos

### Sistema de Pagamento

```JAVA
public class PaymentProcessor {
    public void processPayment(Payment payment) throws PaymentException {
        try {
            validatePayment(payment);
            executeTransaction(payment);
            notifySuccess(payment);
        } catch (ValidationException e) {
            throw new PaymentValidationException("Pagamento inválido", e);
        } catch (TransactionException e) {
            throw new PaymentProcessingException("Erro na transação", e);
        }
    }
}
```

### Sistema de Arquivos

```JAVA
public class FileManager {
    public void saveDocument(Document doc) throws DocumentException {
        if (!isValidDocument(doc)) {
            throw new InvalidDocumentException("Documento inválido");
        }
        
        try {
            writeToFile(doc);
        } catch (IOException e) {
            throw new DocumentStorageException("Erro ao salvar documento", e);
        }
    }
}
```

## Próximos Passos

* Identifique casos de uso para exceções personalizadas em seu código

* Crie hierarquias de exceção para seu domínio

* Implemente tratamento adequado para suas exceções

## Recursos Adicionais

* [Java Exception Handling Best Practices](https://www.oracle.com/java/technologies/javase/exceptions.html)

* [Design Guidelines for Exceptions](https://docs.oracle.com/javase/tutorial/essential/exceptions/design.html)



# Try-with-Resources em Java

## Introdução

Try-with-resources é um recurso introduzido no Java 7 que simplifica o gerenciamento de recursos que precisam ser fechados após o uso.

## Sintaxe Básica

```JAVA
try (Resource resource = new Resource()) {
    // uso do recurso
} catch (Exception e) {
    // tratamento de exceção
}
```

## Recursos AutoCloseable

### Interface AutoCloseable

```JAVA
public interface AutoCloseable {
    void close() throws Exception;
}
```

### Implementação Básica

```JAVA
public class MyResource implements AutoCloseable {
    public MyResource() {
        System.out.println("Recurso criado");
    }

    @Override
    public void close() throws Exception {
        System.out.println("Recurso fechado");
    }
}
```

## Comparação com Try-Catch-Finally Tradicional

### Antes (Try-Catch-Finally)

```JAVA
FileReader reader = null;
try {
    reader = new FileReader("file.txt");
    // usar reader
} catch (IOException e) {
    // tratamento de erro
} finally {
    if (reader != null) {
        try {
            reader.close();
        } catch (IOException e) {
            // tratamento de erro ao fechar
        }
    }
}
```

### Depois (Try-with-Resources)

```JAVA
try (FileReader reader = new FileReader("file.txt")) {
    // usar reader
} catch (IOException e) {
    // tratamento de erro
}
```

## Múltiplos Recursos

### Gerenciando Vários Recursos

```JAVA
try (FileInputStream input = new FileInputStream("input.txt");
     FileOutputStream output = new FileOutputStream("output.txt")) {
    // usar input e output
    byte[] buffer = new byte[1024];
    int length;
    while ((length = input.read(buffer)) > 0) {
        output.write(buffer, 0, length);
    }
}
```

## Exemplos Práticos

### Exemplo 1: Processamento de Arquivo

```JAVA
public class FileProcessor {
    public List<String> readLines(String path) throws IOException {
        List<String> lines = new ArrayList<>();
        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
            String line;
            while ((line = reader.readLine()) != null) {
                lines.add(line);
            }
        }
        return lines;
    }
}
```

### Exemplo 2: Operações de Banco de Dados

```JAVA
public class DatabaseOperations {
    public void transferMoney(int fromAccount, int toAccount, double amount) {
        try (Connection conn = getConnection();
             PreparedStatement debit = conn.prepareStatement("UPDATE accounts SET balance = balance - ? WHERE id = ?");
             PreparedStatement credit = conn.prepareStatement("UPDATE accounts SET balance = balance + ? WHERE id = ?")) {
            
            conn.setAutoCommit(false);
            
            debit.setDouble(1, amount);
            debit.setInt(2, fromAccount);
            debit.executeUpdate();
            
            credit.setDouble(1, amount);
            credit.setInt(2, toAccount);
            credit.executeUpdate();
            
            conn.commit();
        }
    }
}
```

## Recursos Personalizados

### Criando Recurso Personalizado

```JAVA
public class DatabaseConnection implements AutoCloseable {
    private final Connection connection;
    
    public DatabaseConnection(String url) throws SQLException {
        this.connection = DriverManager.getConnection(url);
    }
    
    public Connection getConnection() {
        return connection;
    }
    
    @Override
    public void close() throws Exception {
        if (connection != null && !connection.isClosed()) {
            connection.close();
        }
    }
}
```

### Usando Recurso Personalizado

```JAVA
public class CustomResourceExample {
    public void useCustomResource() {
        try (DatabaseConnection db = new DatabaseConnection("jdbc:mysql://localhost/db")) {
            Connection conn = db.getConnection();
            // usar conexão
        } catch (Exception e) {
            // tratamento de erro
        }
    }
}
```

## Boas Práticas

1. Sempre Use para Recursos AutoCloseable

```JAVA
// Bom
try (InputStream in = new FileInputStream("file.txt")) {
    // código
}

// Evite
InputStream in = new FileInputStream("file.txt");
try {
    // código
} finally {
    in.close();
}
```

1. Ordem de Fechamento

```JAVA
try (ResourceOne one = new ResourceOne();
     ResourceTwo two = new ResourceTwo()) {
    // Os recursos são fechados na ord
```



# Projetos de Tratamento de Erros

## Visão Geral

```MERMAID
graph TD
    A[Projetos de Erros] --> B[Sistema de Validação]
    A --> C[Logger de Erros]
    A --> D[Circuit Breaker]
    
    B --> B1[Validadores]
    B --> B2[Regras]
    B --> B3[Feedback]
    
    C --> C1[Captura]
    C --> C2[Formatação]
    C --> C3[Persistência]
    
    D --> D1[Monitoramento]
    D --> D2[Fallback]
    D --> D3[Recuperação]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style C fill:#1a1a1a,stroke:#33ccff
    style D fill:#1a1a1a,stroke:#33ccff
```

## Projetos Disponíveis

### 1. Sistema de Validação

* [Sistema de Validação](validation-system.html) - Sistema robusto de validação de dados

* Implementa diferentes tipos de validadores

* Fornece feedback detalhado sobre erros

### 2. Logger de Erros

* [Logger de Erros](error-logger.html) - Sistema avançado de logging

* Captura e formata exceções

* Persiste logs para análise posterior

### 3. Circuit Breaker

* [Circuit Breaker](circuit-breaker.html) - Padrão de resiliência

* Previne falhas em cascata

* Implementa estados e recuperação

## Conceitos Aplicados

1. Tratamento de Exceções

* Try-catch blocks

* Exceções personalizadas

* Propagação de erros

2. Validação de Dados

* Regras de negócio

* Validação de entrada

* Feedback ao usuário

3. Logging

* Níveis de log

* Formatação de mensagens

* Rotação de arquivos

4. Resiliência

* Estados do circuit breaker

* Timeouts e retries

* Fallback mechanisms

## Objetivos de Aprendizado

* Implementar tratamento robusto de erros

* Criar sistemas de validação flexíveis

* Desenvolver mecanismos de logging eficientes

* Construir aplicações resilientes

## Boas Práticas

1. Validação

* Valide entrada no ponto mais próximo da origem

* Forneça mensagens de erro claras

* Mantenha validações consistentes

2. Logging

* Use níveis apropriados de log

* Inclua contexto relevante

* Evite informações sensíveis

3. Resiliência

* Implemente timeouts adequados

* Prepare-se para falhas

* Tenha estratégias de fallback

## Desafios Práticos

1. Sistema de Validação

* Adicione novos tipos de validadores

* Implemente validação assíncrona

* Crie regras compostas

2. Logger

* Implemente rotação de arquivos

* Adicione formatação personalizada

* Integre com sistemas externos

3. Circuit Breaker

* Adicione métricas

* Implemente recuperação gradual

* Crie dashboard de monitoramento

## Próximos Passos

* Explore padrões avançados de resiliência

* Integre com frameworks de logging

* Implemente validação distribuída

* Adicione telemetria e monitoramento

## Recursos Adicionais

* [Java Exception Handling Best Practices](https://docs.oracle.com/javase/tutorial/essential/exceptions/)

* [Resilience4j Documentation](https://resilience4j.readme.io/)

* [SLF4J User Manual](http://www.slf4j.org/manual.html)

Tip:

"Um sistema robusto não é aquele que nunca falha, mas sim aquele que sabe lidar com as falhas de forma elegante."

[Começar com Sistema de Validação](validation-system.html)



# Sistema de Validação

## Visão Geral

```MERMAID
graph TD
    A[Sistema de Validação] --> B[Validadores]
    A --> C[Resultados]
    A --> D[Feedback]
    
    B --> B1[Tipo Dados]
    B1 --> B11[String]
    B1 --> B12[Número]
    B1 --> B13[Data]
    
    B --> B2[Regras]
    B2 --> B21[Tamanho]
    B2 --> B22[Formato]
    B2 --> B23[Range]
    
    C --> C1[Sucesso]
    C --> C2[Falha]
    C --> C3[Erros]
    
    D --> D1[Mensagens]
    D --> D2[Códigos]
    D --> D3[Detalhes]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style C fill:#1a1a1a,stroke:#33ccff
    style D fill:#1a1a1a,stroke:#33ccff
```

## Implementação Base

```JAVA
public class ValidationSystem {
    private final List<Validator> validators;
    
    public ValidationResult validate(Object data) {
        // Implementação
    }
}
```

## Componentes Principais

### 1. Interface Validator

* Define contrato para validadores

* Método principal de validação

* Retorno padronizado

### 2. ValidationResult

* Status da validação

* Lista de erros

* Mensagens detalhadas

### 3. ValidationBuilder

* Construção fluente

* Encadeamento de validações

* Composição de regras

## Uso Prático

```JAVA
ValidationSystem validator = new ValidationSystem();
validator.addValidator(new EmailValidator());
validator.addValidator(new PasswordValidator());

ValidationResult result = validator.validate(userData);
if (!result.isValid()) {
    System.out.println(result.getErrors());
}
```

## Tipos de Validadores

1. Dados Básicos

* String (comprimento, formato)

* Números (range, precisão)

* Datas (formato, período)

2. Regras de Negócio

* Validações compostas

* Dependências entre campos

* Regras customizadas

3. Validações Assíncronas

* Consultas externas

* Verificações em banco

* APIs de terceiros

## Boas Práticas

1. Desempenho

* Cache de resultados

* Validação lazy

* Otimização de regras

2. Manutenibilidade

* Validadores isolados

* Regras reutilizáveis

* Documentação clara

3. Usabilidade

* Mensagens claras

* Feedback imediato

* Sugestões de correção

## Exercícios Práticos

1. Validador de Formulário

```JAVA
public class FormValidator extends Validator {
    @Override
    public ValidationResult validate(Object data) {
        // Implementar validação
    }
}
```

1. Validador de Documentos

```JAVA
public class DocumentValidator extends Validator {
    @Override
    public ValidationResult validate(Object data) {
        // Implementar validação
    }
}
```

## Próximos Passos

* Implementar novos validadores

* Adicionar suporte a anotações

* Criar validações customizadas

* Integrar com frameworks

[Próximo: Logger de Erros](error-logger.html)



# Logger de Erros

## Visão Geral

```MERMAID
graph TD
    A[Logger de Erros] --> B[Captura]
    A --> C[Formatação]
    A --> D[Persistência]
    
    B --> B1[Exceções]
    B --> B2[Contexto]
    B --> B3[Stack Trace]
    
    C --> C1[Estrutura]
    C --> C2[Níveis]
    C --> C3[Metadados]
    
    D --> D1[Arquivo]
    D --> D2[Banco]
    D --> D3[Serviço]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style C fill:#1a1a1a,stroke:#33ccff
    style D fill:#1a1a1a,stroke:#33ccff
```

## Implementação Base

```JAVA
public class ErrorLogger {
    private final Queue<LogEntry> logQueue;
    
    public void log(Exception e, String context) {
        // Implementação
    }
}
```

## Componentes Principais

### 1. LogEntry

* Timestamp do erro

* Tipo da exceção

* Mensagem detalhada

* Stack trace

### 2. LogProcessor

* Processamento assíncrono

* Formatação de mensagens

* Rotação de arquivos

### 3. LogPersistence

* Estratégias de armazenamento

* Políticas de retenção

* Compressão de logs

## Níveis de Log

1. ERROR

* Erros críticos

* Falhas de sistema

* Exceções não tratadas

2. WARN

* Situações inesperadas

* Degradação de performance

* Retry operations

3. INFO

* Eventos importantes

* Mudanças de estado

* Operações principais

## Boas Práticas

1. Performance

* Logging assíncrono

* Buffer de mensagens

* Compressão eficiente

2. Organização

* Estrutura clara

* Rotação de arquivos

* Categorização

3. Segurança

* Sanitização de dados

* Controle de acesso

* Backup regular

## Uso Prático

```JAVA
ErrorLogger logger = new ErrorLogger();

try {
    // Operação que pode falhar
} catch (Exception e) {
    logger.log(e, "Contexto da operação");
}
```

## Formatos de Log

1. JSON

```JSON
{
    "timestamp": "2024-01-20T10:15:30",
    "level": "ERROR",
    "message": "Falha na operação",
    "stackTrace": "..."
}
```

1. Text

```TEXT
[2024-01-20 10:15:30] ERROR: Falha na operação
Context: Processamento de pagamento
Stack: ...
```

## Monitoramento

1. Métricas

* Taxa de erros

* Tempo de processamento

* Uso de recursos

2. Alertas

* Thresholds

* Notificações

* Escalação

## Exercícios Práticos

1. Implementar Rotação

```JAVA
public class LogRotator {
    public void rotate(String logFile) {
        // Implementar rotação
    }
}
```

1. Criar Formatador

```JAVA
public class LogFormatter {
    public String format(LogEntry entry) {
        // Implementar formatação
    }
}
```

## Próximos Passos

* Implementar agregação de logs

* Adicionar análise em tempo real

* Criar dashboards

* Integrar com APM

[Próximo: Circuit Breaker](circuit-breaker.html)



# Circuit Breaker

## Visão Geral

```MERMAID
graph TD
    A[Circuit Breaker] --> B[Estados]
    A --> C[Monitoramento]
    A --> D[Recuperação]
    
    B --> B1[Fechado]
    B --> B2[Aberto]
    B --> B3[Semi-Aberto]
    
    C --> C1[Falhas]
    C --> C2[Timeouts]
    C --> C3[Métricas]
    
    D --> D1[Fallback]
    D --> D2[Reset]
    D --> D3[Retry]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style C fill:#1a1a1a,stroke:#33ccff
    style D fill:#1a1a1a,stroke:#33ccff
```

## Implementação Base

```JAVA
public class CircuitBreaker {
    private CircuitState state;
    private int failureCount;
    
    public <T> T execute(Supplier<T> operation) {
        // Implementação
    }
}
```

## Estados do Circuit Breaker

### 1. CLOSED (Fechado)

* Estado normal

* Operações permitidas

* Monitoramento de falhas

### 2. OPEN (Aberto)

* Falhas detectadas

* Rejeita requisições

* Timeout para reset

### 3. HALF-OPEN (Semi-Aberto)

* Período de teste

* Limitação de requisições

* Monitoramento intensivo

## Componentes Principais

1. Failure Detection

* Contagem de falhas

* Tipos de erro

* Thresholds

2. State Management

* Transições

* Timeouts

* Reset logic

3. Fallback Mechanism

* Respostas default

* Cache

* Alternativas

## Uso Prático

```JAVA
CircuitBreaker breaker = new CircuitBreaker("payment-service");
breaker.addFallback("process-payment", () -> "Fallback Response");

try {
    String result = breaker.execute("process-payment", 
        () -> paymentService.process());
} catch (CircuitBreakerException e) {
    // Handle exception
}
```

## Configurações

1. Thresholds

```JAVA
public record BreakerConfig(
    int failureThreshold,
    long resetTimeout,
    int halfOpenCalls
) {}
```

1. Métricas

```JAVA
public class BreakerMetrics {
    private long failureCount;
    private long successCount;
    private double errorRate;
}
```

## Padrões de Uso

1. Remote Services

* APIs externas

* Microserviços

* Banco de dados

2. Resource Protection

* Rate limiting

* Load balancing

* Degradação graciosa

## Boas Práticas

1. Configuração

* Thresholds apropriados

* Timeouts adequados

* Fallbacks relevantes

2. Monitoramento

* Logging detalhado

* Métricas em tempo real

* Alertas

3. Recuperação

* Estratégias de retry

* Backoff exponencial

* Cache de fallback

## Exercícios Práticos

1. Implementar Métricas

```JAVA
public class MetricsCollector {
    public void recordSuccess() {
        // Implementar
    }
    
    public void recordFailure() {
        // Implementar
    }
}
```

1. Criar Fallback

```JAVA
public class FallbackRegistry {
    public void register(String operation, Supplier<?> fallback) {
        // Implementar
    }
}
```

## Integração com Sistemas

1. Monitoring

* Prometheus

* Grafana

* Health checks

2. Logging

* Estado changes

* Falhas

* Recuperações

## Próximos Passos

* Implementar circuit breaker distribuído

* Adicionar métricas avançadas

* Criar dashboard de monitoramento

* Integrar com service mesh

[Voltar para Projetos de Erro](error-projects.html)



# Recursos Avançados do Java

## Visão Geral

```MERMAID
mindmap
  root((Recursos<br>Avançados))
    (Generics)
      [Type Erasure]
      [Wildcards]
      [Bounds]
    (Lambda)
      [Functional Interfaces]
      [Method References]
      [Closure]
    (Streams)
      [Pipeline]
      [Collectors]
      [Parallel]
    (Optional)
      [Null Safety]
      [Monadic Operations]
    (Modules)
      [Encapsulation]
      [Dependencies]
    (Reflection)
      [Introspection]
      [Dynamic Invocation]
    (Annotations)
      [Runtime]
      [Compile-time]
    (Projetos)
      [Data Processor]
      [Custom Framework]
```

## Recursos Principais

### Generics

Permite criar classes e métodos type-safe que podem trabalhar com diferentes tipos:

```JAVA
public class Box<T> {
    private T content;
    
    public void set(T content) {
        this.content = content;
    }
    
    public T get() {
        return content;
    }
}
```

### Lambda Expressions

Implementa interfaces funcionais de forma concisa:

```JAVA
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.forEach(name -> System.out.println("Hello, " + name));
```

### Streams API

Processa coleções de forma declarativa:

```JAVA
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
                .filter(n -> n % 2 == 0)
                .mapToInt(Integer::intValue)
                .sum();
```

### Optional

Lida com valores nulos de forma segura:

```JAVA
Optional<String> optional = Optional.ofNullable(getValue());
String result = optional.map(String::toUpperCase)
                       .orElse("default");
```

### Sistema de Módulos

Encapsula e gerencia dependências:

```JAVA
module com.example.app {
    requires java.base;
    requires java.sql;
    
    exports com.example.api;
}
```

### Reflection

Examina e manipula código em runtime:

```JAVA
Class<?> clazz = MyClass.class;
Method method = clazz.getDeclaredMethod("myMethod");
method.invoke(instance);
```

### Annotations

Define metadados para código:

```JAVA
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Transactional {
    boolean readOnly() default false;
}
```

## Aplicações Práticas

### Desenvolvimento de Frameworks

```JAVA
@Controller
@RequestMapping("/api")
public class UserController {
    @Autowired
    private UserService service;
    
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return service.findById(id);
    }
}
```

### Processamento de Dados

```JAVA
public class DataProcessor<T> {
    public List<R> process(
        List<T> data,
        Predicate<T> filter,
        Function<T, R> transformer
    ) {
        return data.stream()
                  .filter(filter)
                  .map(transformer)
                  .collect(Collectors.toList());
    }
}
```

### Plugins Dinâmicos

```JAVA
public class PluginLoader {
    public Plugin loadPlugin(String className) {
        Class<?> pluginClass = Class.forName(className);
        return (Plugin) pluginClass.getDeclaredConstructor()
                                 .newInstance();
    }
}
```

## Melhores Práticas

1. Type Safety

* Use Generics apropriadamente

* Evite raw types

* Aplique bounds quando necessário

2. Performance

* Use Streams paralelos com cautela

* Cache resultados de reflection

* Otimize operações lambda críticas

3. Modularidade

* Defina interfaces claras

* Encapsule implementações

* Gerencie dependências explicitamente

## Próximos Passos

* [Generics](generics.html)

* [Lambda Expressions](lambda.html)

* [Streams API](streams.html)

* [Optional](optional.html)

* [Modules](modules.html)

* [Reflection](reflection.html)

* [Annotations](annotations.html)

* [Advanced Projects](advanced-projects.html)

## Recursos Adicionais

### Documentação Oficial

* [Java Language Specification](https://docs.oracle.com/javase/specs/)

* [JDK Documentation](https://docs.oracle.com/en/java/javase/)

### Ferramentas

* IDEs com suporte avançado

* Analisadores estáticos

* Frameworks de teste

### Comunidade

* Fóruns de discussão

* Repositórios de exemplo

* Blogs técnicos

## Desafios de Aprendizado

1. Implemente um framework de injeção de dependência

2. Crie um processador de anotações customizado

3. Desenvolva um container genérico thread-safe

4. Construa um sistema de plugins dinâmico

[Generics](generics.html)



# Generics: Flexibilidade com Tipo Seguro

```
GENERICS MAP
├── Type Parameters
├── Generic Classes
├── Generic Methods
└── Type Bounds
```

## Conceitos Básicos

### Type Parameters

```JAVA
// T é um type parameter comum
public class Box<T> {
    private T content;
    
    public void store(T item) {
        this.content = item;
    }
    
    public T retrieve() {
        return content;
    }
}
```

### Convenções de Nomenclatura

* `T` - Tipo genérico

* `E` - Elemento

* `K` - Chave

* `V` - Valor

* `N` - Número

## Wildcards

### Upper Bounded

```JAVA
// Aceita Number ou subtipos
public void process(List<? extends Number> numbers) {
    for (Number n : numbers) {
        System.out.println(n.doubleValue());
    }
}
```

### Lower Bounded

```JAVA
// Aceita Integer ou supertipos
public void addNumbers(List<? super Integer> list) {
    list.add(10);
    list.add(20);
}
```

## Type Erasure

O Java usa type erasure para implementar generics:

```JAVA
// Em tempo de compilação
List<String> strings = new ArrayList<String>();

// Em runtime se torna
List strings = new ArrayList();
```

## Práticas Recomendadas

1. Use Generics para Collections

```JAVA
// Ruim
List lista = new ArrayList();

// Bom
List<String> lista = new ArrayList<>();
```

1. Defina Bounds Quando Necessário

```JAVA
public class NumericBox<T extends Number> {
    private T number;
    
    public double getValue() {
        return number.doubleValue();
    }
}
```

## Exercício Prático

Implemente uma classe genérica `Stack<T>`:

```JAVA
public class Stack<T> {
    private List<T> items = new ArrayList<>();
    
    public void push(T item) {
        items.add(item);
    }
    
    public T pop() {
        if (items.isEmpty()) {
            throw new EmptyStackException();
        }
        return items.remove(items.size() - 1);
    }
}
```



# Expressões Lambda: Programação Funcional em Java

```
LAMBDA CONCEPTS
├── Syntax
├── Functional Interfaces
├── Method References
└── Common Use Cases
```

## Sintaxe Básica

### Forma Padrão

```JAVA
// Sintaxe: (parâmetros) -> { corpo }
Runnable r = () -> { System.out.println("Executando"); };

// Versão simplificada
Comparator<String> c = (s1, s2) -> s1.length() - s2.length();
```

## Interfaces Funcionais Comuns

### Function<T,R>

```JAVA
Function<String, Integer> length = str -> str.length();
Integer size = length.apply("NetRunner");
```

### 

Predicate

```JAVA
Predicate<String> isEmpty = str -> str.trim().isEmpty();
boolean result = isEmpty.test("  ");
```

### 

Consumer

```JAVA
Consumer<String> print = msg -> System.out.println(msg);
print.accept("Hello, Runner!");
```

### 

Supplier

```JAVA
Supplier<LocalDateTime> now = () -> LocalDateTime.now();
LocalDateTime time = now.get();
```

## Method References

### Tipos de References

```JAVA
// Referência a método estático
Function<String, Integer> parser = Integer::parseInt;

// Referência a método de instância
String str = "NetRunner";
Supplier<Integer> length = str::length;

// Referência a construtor
Supplier<ArrayList<String>> constructor = ArrayList::new;
```

## Composição de Funções

### Combining Functions

```JAVA
Function<String, String> upper = String::toUpperCase;
Function<String, String> trim = String::trim;
Function<String, String> combined = upper.andThen(trim);
```

## Exemplo Prático

### Stream com Lambda

```JAVA
List<String> hackers = Arrays.asList("Neo", "Trinity", "Morpheus");

hackers.stream()
    .filter(name -> name.length() > 3)
    .map(String::toUpperCase)
    .forEach(System.out::println);
```

## Boas Práticas

1. Mantenha Lambdas Simples

```JAVA
// Ruim
button.setOnAction(e -> {
    // 20 linhas de código aqui
});

// Bom
button.setOnAction(this::handleClick);
```

1. Use Method References

```JAVA
// Menos legível
list.forEach(item -> System.out.println(item));

// Mais legível
list.forEach(System.out::println);
```

## Exercício

Implemente um sistema de filtro usando lambdas:

```JAVA
public class HackerFilter {
    public static List<Hacker> filterBySkill(
        List<Hacker> hackers,
        Predicate<Hacker> criteria
    ) {
        return hackers.stream()
                     .filter(criteria)
                     .collect(Collectors.toList());
    }
}

// Uso
List<Hacker> eliteHackers = filterBySkill(
    hackerList,
    h -> h.getSkillLevel() > 9000
);
```



# Streams API: Processamento de Dados Fluente

```
STREAMS API
├── Creation
├── Intermediate Ops
├── Terminal Ops
└── Parallel Streams
```

## Criando Streams

### Métodos de Criação

```JAVA
// De Collection
List<String> list = Arrays.asList("Neo", "Trinity");
Stream<String> stream = list.stream();

// Stream direto
Stream<String> direct = Stream.of("Morpheus", "Tank");

// Stream infinito
Stream<Integer> infinite = Stream.iterate(0, n -> n + 1);
```

## Operações Intermediárias

### Filter

```JAVA
List<String> hackers = Arrays.asList("Neo", "Trinity", "Morpheus");
hackers.stream()
      .filter(name -> name.length() > 3)
      .collect(Collectors.toList());
```

### Map

```JAVA
List<Integer> lengths = hackers.stream()
    .map(String::length)
    .collect(Collectors.toList());
```

### FlatMap

```JAVA
List<List<String>> nested = Arrays.asList(
    Arrays.asList("Neo", "Trinity"),
    Arrays.asList("Morpheus", "Tank")
);

List<String> flat = nested.stream()
    .flatMap(List::stream)
    .collect(Collectors.toList());
```

## Operações Terminais

### Collect

```JAVA
// Para Lista
List<String> list = stream.collect(Collectors.toList());

// Para Set
Set<String> set = stream.collect(Collectors.toSet());

// Para Map
Map<String, Integer> map = stream.collect(
    Collectors.toMap(
        s -> s,
        String::length
    )
);
```

### Reduce

```JAVA
Optional<Integer> sum = Stream.of(1, 2, 3)
    .reduce((a, b) -> a + b);

int total = Stream.of(1, 2, 3)
    .reduce(0, Integer::sum);
```

## Streams Paralelos

### Processamento Paralelo

```JAVA
// Stream paralelo de Collection
List<String> result = hackers.parallelStream()
    .filter(name -> name.length() > 3)
    .collect(Collectors.toList());

// Converter para paralelo
Stream<String> parallel = stream.parallel();
```

## Exemplos Práticos

### Análise de Dados

```JAVA
class HackerStats {
    public static Map<String, Long> analyzeSkills(List<Hacker> hackers) {
        return hackers.stream()
            .flatMap(h -> h.getSkills().stream())
            .collect(Collectors.groupingBy(
                skill -> skill,
                Collectors.counting()
            ));
    }
}
```

### Pipeline Complexo

```JAVA
List<Hacker> eliteSquad = hackers.stream()
    .filter(h -> h.getLevel() > 50)
    .sorted(Comparator.comparing(Hacker::getSkillLevel).reversed())
    .limit(5)
    .collect(Collectors.toList());
```

## Boas Práticas

1. Use Parallel com Cautela

```JAVA
// Nem sempre mais rápido!
boolean anyMatch = hugeList.parallelStream()
    .anyMatch(predicate);
```

1. Evite Estado Mutável

```JAVA
// Ruim
List<String> results = new ArrayList<>();
stream.forEach(results::add);

// Bom
List<String> results = stream.collect(Collectors.toList());
```

## Exercício

Implemente um sistema de análise de logs:

```JAVA
public class LogAnalyzer {
    public static Map<String, Long> analyzeErrors(
        List<LogEntry> logs
    ) {
        return logs.stream()
            .filter(log -> log.getLevel() == Level.ERROR)
            .collect(Collectors.groupingBy(
                LogEntry::getErrorCode,
                Collectors.counting()
            ));
    }
}
```



# Optional: Tratamento Elegante de Null

```
OPTIONAL API
├── Creation
├── Checking
├── Extraction
└── Transformation
```

## Criando Optionals

### Métodos de Criação

```JAVA
// Valor presente
Optional<String> present = Optional.of("Neo");

// Possivelmente null
Optional<String> nullable = Optional.ofNullable(getValue());

// Definitivamente vazio
Optional<String> empty = Optional.empty();
```

## Verificando Valores

### Métodos de Verificação

```JAVA
Optional<String> opt = Optional.of("Trinity");

// Verifica se há valor
boolean hasValue = opt.isPresent();

// Verifica se está vazio
boolean isEmpty = opt.isEmpty(); // Java 11+
```

## Extraindo Valores

### Métodos de Extração

```JAVA
String value = opt.get(); // Pode lançar NoSuchElementException

// Com valor padrão
String safe = opt.orElse("Default");

// Com supplier
String computed = opt.orElseGet(() -> computeDefault());

// Com exceção
String required = opt.orElseThrow(
    () -> new IllegalStateException("Valor requerido")
);
```

## Transformando Valores

### Map e FlatMap

```JAVA
Optional<String> upper = opt.map(String::toUpperCase);

Optional<Optional<String>> nested = 
    Optional.of(Optional.of("Nested"));
Optional<String> flat = nested.flatMap(o -> o);
```

## Padrões de Uso

### Encadeamento

```JAVA
public class UserService {
    public Optional<String> getEmail(String userId) {
        return findUser(userId)
            .map(User::getProfile)
            .map(Profile::getEmail);
    }
}
```

### Consumindo Valores

```JAVA
opt.ifPresent(value -> System.out.println(value));

// Com ação alternativa (Java 9+)
opt.ifPresentOrElse(
    value -> System.out.println(value),
    () -> System.out.println("Vazio")
);
```

## Boas Práticas

1. Evite Optional.get()

```JAVA
// Ruim
String value = optional.get();

// Bom
String value = optional.orElse("default");
```

1. Não use Optional como Parâmetro

```JAVA
// Ruim
public void process(Optional<String> value) {}

// Bom
public void process(String value) {}
```

1. Use para Retornos

```JAVA
public Optional<User> findUser(String id) {
    User user = database.query(id);
    return Optional.ofNullable(user);
}
```

## Exemplo Prático

### Sistema de Configuração

```JAVA
public class Config {
    private Map<String, String> settings;

    public Optional<String> getSetting(String key) {
        return Optional.ofNullable(settings.get(key));
    }

    public String getSettingWithDefault(String key) {
        return getSetting(key)
            .map(String::trim)
            .filter(s -> !s.isEmpty())
            .orElse("default");
    }
}
```

## Exercício

Implemente um sistema de cache com Optional:

```JAVA
public class Cache<K, V> {
    private Map<K, V> storage = new HashMap<>();

    public Optional<V> get(K key) {
        return Optional.ofNullable(storage.get(key));
    }

    public V getOrCompute(K key, Supplier<V> computer) {
        return get(key)
            .orElseGet(() -> {
                V value = computer.get();
                storage.put(key, value);
                return value;
            });
    }
}
```



# Sistema de Módulos Java

## Visão Geral

O sistema de módulos do Java (Project Jigsaw) foi introduzido no Java 9 para melhorar a modularidade e escalabilidade de aplicações Java.

## Conceitos Fundamentais

### Estrutura de um Módulo

```
MODULE STRUCTURE
├── module-info.java
├── com.example.module
│   ├── internal
│   └── api
└── resources
```

## Declaração de Módulo

### Sintaxe Básica

```JAVA
module com.example.mymodule {
    requires java.base;
    exports com.example.api;
    provides com.example.spi.MyService with com.example.impl.MyServiceImpl;
}
```

## Diretivas Principais

### Exports

* Controla quais pacotes são acessíveis

* Permite exportação seletiva

* Gerencia visibilidade do módulo

### Requires

* Define dependências do módulo

* Especifica módulos necessários

* Controla transitividade

### Provides/Uses

* Implementa serviços

* Define interfaces de serviço

* Permite extensibilidade

## Benefícios

1. Encapsulamento Forte

* Melhor segurança

* Controle de acesso refinado

* Isolamento de implementação

2. Dependências Explícitas

* Clareza nas relações

* Gestão simplificada

* Detecção precoce de problemas

3. Performance

* Carregamento otimizado

* Menor footprint de memória

* Inicialização mais rápida

## Práticas Recomendadas

### Organização

* Módulos coesos

* Interfaces bem definidas

* Dependências mínimas

### Nomenclatura

* Nomes descritivos

* Convenções consistentes

* Hierarquia lógica

## Exemplos Práticos

### Módulo Básico

```JAVA
module com.example.core {
    exports com.example.core.api;
    requires java.logging;
}
```

### Módulo de Serviço

```JAVA
module com.example.service {
    exports com.example.service;
    provides com.example.spi.Service with com.example.service.impl.ServiceImpl;
}
```

## Ferramentas e Comandos

### jmod

```BASH
jmod create --class-path mods/com.example.mymodule
```

### jdeps

```BASH
jdeps --module-path mods com.example.mymodule
```

## Migração para Módulos

### Passos

1. Análise de dependências

2. Criação do module-info

3. Refatoração de código

4. Testes de integração

### Desafios Comuns

* Dependências circulares

* Código legado

* Bibliotecas não modulares

## Recursos Adicionais

### Documentação

* [JEP 261](https://openjdk.java.net/jeps/261)

* Java Platform Module System Specification

* Tutorial oficial do Java

### Ferramentas

* Maven plugins

* Gradle support

* IDE integration



# Reflection API

## Fundamentos

### O que é Reflection?

Reflection é a capacidade de examinar e modificar o comportamento de classes, interfaces e métodos em tempo de execução.

## Principais Componentes

### Class<?>

```JAVA
// Obtendo Class object
Class<?> clazz = MyClass.class;
Class<?> clazz = objeto.getClass();
Class<?> clazz = Class.forName("com.example.MyClass");
```

### Métodos

```JAVA
// Acessando métodos
Method[] methods = clazz.getDeclaredMethods();
Method method = clazz.getDeclaredMethod("methodName", parameterTypes);
```

### Campos

```JAVA
// Acessando campos
Field[] fields = clazz.getDeclaredFields();
Field field = clazz.getDeclaredField("fieldName");
```

## Casos de Uso

### Inspeção de Classes

```JAVA
public void inspectClass(Class<?> clazz) {
    System.out.println("Class: " + clazz.getName());
    System.out.println("Superclass: " + clazz.getSuperclass().getName());
    System.out.println("Interfaces: " + Arrays.toString(clazz.getInterfaces()));
}
```

### Manipulação de Objetos

```JAVA
public Object createInstance(String className) throws Exception {
    Class<?> clazz = Class.forName(className);
    return clazz.getDeclaredConstructor().newInstance();
}
```

## Recursos Avançados

### Anotações

```JAVA
// Lendo anotações
Annotation[] annotations = clazz.getAnnotations();
MyAnnotation annotation = clazz.getAnnotation(MyAnnotation.class);
```

### Generics

```JAVA
// Trabalhando com tipos genéricos
Type[] genericTypes = ((ParameterizedType) field.getGenericType())
    .getActualTypeArguments();
```

## Boas Práticas

### Performance

* Cache de reflection

* Minimizar uso em loops

* Preferir acesso direto quando possível

### Segurança

* Usar setAccessible com cautela

* Validar entrada do usuário

* Considerar políticas de segurança

## Exemplos Práticos

### Framework de Teste

```JAVA
public class TestRunner {
    public void runTests(Class<?> testClass) throws Exception {
        Object instance = testClass.getDeclaredConstructor().newInstance();
        
        for (Method method : testClass.getDeclaredMethods()) {
            if (method.isAnnotationPresent(Test.class)) {
                method.invoke(instance);
            }
        }
    }
}
```

### Injeção de Dependência

```JAVA
public class DependencyInjector {
    public void inject(Object instance) throws Exception {
        Class<?> clazz = instance.getClass();
        
        for (Field field : clazz.getDeclaredFields()) {
            if (field.isAnnotationPresent(Inject.class)) {
                field.setAccessible(true);
                field.set(instance, createDependency(field.getType()));
            }
        }
    }
}
```

## Debugging e Troubleshooting

### Erros Comuns

1. IllegalAccessException

2. NoSuchMethodException

3. InvocationTargetException

### Soluções

```JAVA
// Tratamento de exceções
try {
    method.setAccessible(true);
    method.invoke(object, args);
} catch (Exception e) {
    handleReflectionException(e);
}
```

## Performance

### Otimizações

```JAVA
// Cache de reflection
private static final Map<Class<?>, Method[]> methodCache = new ConcurrentHashMap<>();

public Method[] getMethods(Class<?> clazz) {
    return methodCache.computeIfAbsent(clazz, Class::getDeclaredMethods);
}
```

## Recursos Adicionais

### Documentação

* Java Reflection API Documentation

* Tutorial Oracle sobre Reflection

* Especificação da linguagem Java

### Ferramentas

* ByteBuddy

* Reflections Library

* ASM



# Anotações em Java

## Fundamentos

### O que são Anotações?

Anotações são metadados que podem ser adicionados ao código Java para fornecer informações adicionais sobre o programa.

## Tipos de Anotações

### Built-in Annotations

```JAVA
@Override
@Deprecated
@SuppressWarnings
@FunctionalInterface
@SafeVarargs
```

### Meta-Annotations

```JAVA
@Retention
@Target
@Documented
@Inherited
@Repeatable
```

## Criando Anotações

### Sintaxe Básica

```JAVA
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test {
    String value() default "";
    boolean enabled() default true;
}
```

### Elementos de Anotação

```JAVA
public @interface Configuration {
    String name();              // Elemento obrigatório
    int port() default 8080;    // Elemento com valor default
    String[] protocols();       // Array
}
```

## Criando Annotations Personalizadas

### Anatomia de uma Annotation

```JAVA
@Retention(RetentionPolicy.RUNTIME)           // Quando a annotation está disponível
@Target({ElementType.METHOD, ElementType.TYPE}) // Onde pode ser usada
@Documented                                   // Incluir na documentação JavaDoc
public @interface MinhaAnnotation {
    String value();                // Elemento obrigatório
    int count() default 0;         // Elemento opcional com valor padrão
    String[] tags() default {};    // Array com valor padrão vazio
}
```

### Tipos de Elementos Permitidos

```JAVA
public @interface ConfiguracaoCompleta {
    // Tipos primitivos
    int valor();
    boolean ativo();
    
    // String
    String descricao();
    
    // Class
    Class<?> tipo();
    
    // Enum
    NivelLog nivel() default NivelLog.INFO;
    
    // Annotation
    Override referencia() default @Override;
    
    // Arrays
    String[] tags();
}
```

### Valores Default

```JAVA
public @interface Configuracao {
    // Valor único sem default (obrigatório)
    String nome();
    
    // Valor único com default (opcional)
    int timeout() default 1000;
    
    // Array com default vazio
    String[] perfis() default {};
    
    // Array com valores default
    String[] ambientes() default {"dev", "test"};
}
```

### Annotations Simples vs. Complexas

#### Annotation Simples (Marker)

```JAVA
// Annotation marcadora - sem elementos
public @interface Auditavel {}

// Uso
@Auditavel
public class ContaBancaria {}
```

#### Annotation com Valor Único

```JAVA
public @interface NomeTabela {
    String value();  // Elemento especial 'value'
}

// Uso simplificado
@NomeTabela("usuarios")
public class Usuario {}
```

#### Annotation Complexa

```JAVA
public @interface Entidade {
    String nome();
    String schema() default "";
    boolean auditavel() default false;
    String[] indices() default {};
}

// Uso
@Entidade(
    nome = "produtos",
    schema = "estoque",
    auditavel = true,
    indices = {"idx_nome", "idx_codigo"}
)
public class Produto {}
```

### Annotations Aninhadas

```JAVA
// Annotation interna
public @interface Coluna {
    String nome();
    boolean nullable() default true;
}

// Annotation container
public @interface Colunas {
    Coluna[] value();
}

// Uso
@Colunas({
    @Coluna(nome = "id", nullable = false),
    @Coluna(nome = "nome")
})
public class Exemplo {}
```

### Processamento de Annotations Customizadas

```JAVA
public class ProcessadorAnnotation {
    public void processar(Class<?> classe) {
        // Verificando se a classe tem a annotation
        if (classe.isAnnotationPresent(MinhaAnnotation.class)) {
            // Obtendo a annotation
            MinhaAnnotation annotation = 
                classe.getAnnotation(MinhaAnnotation.class);
            
            // Acessando elementos
            String valor = annotation.value();
            int contador = annotation.count();
            String[] tags = annotation.tags();
            
            // Processamento...
        }
    }
}
```

### Exemplo Completo

```JAVA
// Definição da annotation
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface ServicoRest {
    String path();
    String versao() default "1.0";
    MetodoHttp[] metodos() default {};
    
    public enum MetodoHttp {
        GET, POST, PUT, DELETE
    }
}

// Uso da annotation
@ServicoRest(
    path = "/usuarios",
    versao = "2.0",
    metodos = {
        ServicoRest.MetodoHttp.GET,
        ServicoRest.MetodoHttp.POST
    }
)
public class UsuarioController {
    // Implementação...
}

// Processamento
public class ServicoRestScanner {
    public void scanearServicos(String pacote) {
        // Lógica para encontrar classes no pacote
        Class<?>[] classes = // ...
        
        for (Class<?> classe : classes) {
            if (classe.isAnnotationPresent(ServicoRest.class)) {
                ServicoRest servico = 
                    classe.getAnnotation(ServicoRest.class);
                
                // Registrar endpoint
                registrarEndpoint(
                    servico.path(),
                    servico.versao(),
                    servico.metodos()
                );
            }
        }
    }
    
    private void registrarEndpoint(
        String path, 
        String versao, 
        MetodoHttp[] metodos
    ) {
        // Implementação do registro...
    }
}
```

## Uso de Anotações

### Em Classes

```JAVA
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue
    private Long id;
    
    @Column(nullable = false)
    private String name;
}
```

### Em Métodos

```JAVA
@Test
@Timeout(value = 1000, unit = TimeUnit.MILLISECONDS)
public void testMethod() {
    // Test implementation
}
```

## Processamento de Anotações

### Em Tempo de Compilação

```JAVA
@SupportedAnnotationTypes("com.example.annotations.*")
@SupportedSourceVersion(SourceVersion.RELEASE_17)
public class MyAnnotationProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        // Processamento
        return true;
    }
}
```

### Em Tempo de Execução

```JAVA
public class AnnotationReader {
    public void readAnnotations(Class<?> clazz) {
        for (Method method : clazz.getDeclaredMethods()) {
            if (method.isAnnotationPresent(Test.class)) {
                Test test = method.getAnnotation(Test.class);
                System.out.println("Test: " + test.value());
            }
        }
    }
}
```

## Padrões de Uso

### Validação

```JAVA
@NotNull
@Size(min = 5, max = 50)
private String username;

@Email
@NotBlank
private String email;
```

### Configuração

```JAVA
@Configuration
@EnableCaching
public class AppConfig {
    @Bean
    @Scope("singleton")
    public CacheManager cacheManager() {
        return new ConcurrentMapCacheManager();
    }
}
```

## Boas Práticas

### Nomenclatura

* Nomes descritivos

* Convenções consistentes

* Documentação clara

### Design

* Mantenha simples

* Evite duplicação

* Use valores default apropriados

## Exemplos Avançados

### Anotações Repetíveis

```JAVA
@Repeatable(Roles.class)
public @interface Role {
    String value();
}

public @interface Roles {
    Role[] value();
}

@Role("ADMIN")
@Role("USER")
public class UserController { }
```

### Anotações Compostas

```JAVA
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@SpringBootApplication
@EnableCaching
@EnableScheduling
public @interface MyApplication { }
```

## Casos de Uso

### Framework de Teste

```JAVA
@Test
@DisplayName("Teste de soma")
@Tag("math")
public void testAdd() {
    assertEquals(4, Calculator.add(2, 2));
}
```

### Injeção de Dependência

```JAVA
@Component
public class UserService {
    @Autowired
    private UserRepository repository;
    
    @Transactional
    public void saveUser(User user) {
        repository.save(user);
    }
}
```

## Recursos Adicionais

### Documentação

* Java Annotation Specification

* Tutorial Oracle sobre Annotations

* Processadores de Anotação

### Frameworks

* Spring Annotations

* JUnit Annotations

* Jakarta EE Annotations



# Projetos Avançados

## Visão Geral

```MERMAID
graph TD
    A[Projetos Avançados] --> B[Data Processor]
    A --> C[Functional Calculator]
    A --> D[Custom Framework]
    A --> E[Annotation Processor]
    A --> F[Generic Container]
    A --> G[Reflection Explorer]
    
    style A fill:#1a1a1a,stroke:#00ff00
    style B fill:#1a1a1a,stroke:#33ccff
    style C fill:#1a1a1a,stroke:#33ccff
    style D fill:#1a1a1a,stroke:#33ccff
    style E fill:#1a1a1a,stroke:#33ccff
    style F fill:#1a1a1a,stroke:#33ccff
    style G fill:#1a1a1a,stroke:#33ccff
```

## Estrutura Base dos Projetos

```
PROJETO
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── netrunner/
│   │   │           └── project/
│   │   │               ├── annotations/
│   │   │               ├── processors/
│   │   │               ├── core/
│   │   │               └── util/
│   │   └── resources/
│   │       └── META-INF/
│   │           └── services/
│   └── test/
│       └── java/
└── pom.xml
```

## Data Processor

### Objetivo

Criar um sistema de processamento de dados com anotações personalizadas para validação, transformação e persistência.

### Características

* Anotações para validação de campos

* Transformadores de dados customizáveis

* Pipeline de processamento configurável

* Suporte a diferentes formatos de dados

### Exemplo de Implementação

```JAVA
@Entity
@DataProcessor(version = "1.0")
public class UserData {
    @Validate(pattern = "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,6}$")
    private String email;
    
    @Transform(transformer = EncryptTransformer.class)
    private String password;
    
    @Persist(strategy = "JDBC")
    private UserProfile profile;
}
```

## Functional Calculator

### Objetivo

Implementar uma calculadora avançada usando programação funcional e expressões lambda.

### Características

* Operações encadeadas

* Histórico de operações

* Funções customizáveis

* Suporte a expressões complexas

### Exemplo de Implementação

```JAVA
public class FunctionalCalculator {
    @Operation("SUM")
    public Function<Double, Double> sum(Double a) {
        return b -> a + b;
    }
    
    @Operation("COMPOSE")
    public <T, R> Function<T, R> compose(
        @OperationParam Function<T, R>... functions
    ) {
        return Arrays.stream(functions)
                    .reduce(Function.identity(), Function::andThen);
    }
}
```

## Custom Framework

### Objetivo

Desenvolver um mini-framework usando reflexão e anotações para injeção de dependências.

### Características

* Injeção de dependências

* Gerenciamento de ciclo de vida

* Configuração via anotações

* Suporte a plugins

### Exemplo de Implementação

```JAVA
@Component
@Scope("singleton")
public class ServiceManager {
    @Inject
    private ConfigProvider config;
    
    @Initialize
    public void setup() {
        // Inicialização
    }
    
    @HandleRequest("/api")
    public Response processRequest(Request request) {
        // Processamento
    }
}
```

## Annotation Processor

### Objetivo

Criar um processador de anotações para geração de código em tempo de compilação.

### Características

* Geração de código

* Validação em tempo de compilação

* Documentação automática

* Templates customizáveis

### Exemplo de Implementação

```JAVA
@SupportedAnnotationTypes("com.netrunner.annotations.*")
@SupportedSourceVersion(SourceVersion.RELEASE_17)
public class CustomAnnotationProcessor extends AbstractProcessor {
    @Override
    public boolean process(
        Set<? extends TypeElement> annotations,
        RoundEnvironment roundEnv
    ) {
        // Processamento das anotações
        return true;
    }
}
```

## Generic Container

### Objetivo

Implementar um container genérico com suporte a diferentes tipos de dados e operações.

### Características

* Tipos genéricos

* Operações type-safe

* Validações em tempo de compilação

* Conversões automáticas

### Exemplo de Implementação

```JAVA
@Container
public class DataContainer<T extends Comparable<T>> {
    @Validate
    private List<T> elements;
    
    @Operation
    public <R> Optional<R> transform(
        @Transformer Function<T, R> transformer
    ) {
        // Transformação de dados
    }
}
```

## Reflection Explorer

### Objetivo

Criar uma ferramenta para exploração e manipulação de classes usando reflexão.

### Características

* Inspeção de classes

* Modificação em runtime

* Proxy dinâmico

* Carregamento de classes

### Exemplo de Implementação

```JAVA
public class ReflectionExplorer {
    @Inspect
    public ClassInfo analyze(Class<?> target) {
        return ClassInfo.builder()
                       .methods(getMethods(target))
                       .fields(getFields(target))
                       .annotations(getAnnotations(target))
                       .build();
    }
    
    @Modify
    public Object enhance(
        @Target Object instance,
        @Enhancement Enhancement enhancement
    ) {
        // Modificação dinâmica
    }
}
```

## Desafios Extras

### Data Processor

* Implementar validação assíncrona

* Adicionar suporte a expressões regulares complexas

* Criar pipeline de transformação configurável

* Implementar persistência em diferentes bancos

### Functional Calculator

* Adicionar suporte a operações matemáticas avançadas

* Implementar sistema de plugins para novas operações

* Criar DSL para expressões matemáticas

* Adicionar suporte a cálculos paralelos

### Custom Framework

* Implementar hot reload de componentes

* Adicionar suporte a aspectos

* Criar sistema de plugins dinâmicos

* Implementar balanceamento de carga

### Annotation Processor

* Gerar documentação automática

* Implementar validações complexas

* Criar templates customizáveis

* Adicionar suporte a diferentes linguagens

### Generic Container

* Implementar operações batch

* Adicionar suporte a streams

* Criar sistema de cache inteligente

* Implementar serialização customizada

### Reflection Explorer

* Adicionar suporte a bytecode manipulation

* Implementar hot swapping de classes

* Criar visualização gráfica de hierarquias

* Implementar debugging dinâmico

## Dicas de Implementação

1. Planejamento

* Comece com diagramas UML

* Defina casos de uso claros

* Estabeleça critérios de aceitação

* Planeje a arquitetura

2. Desenvolvimento

* Use TDD/BDD

* Implemente incrementalmente

* Documente decisões importantes

* Mantenha o código limpo

3. Testes

* Crie testes unitários

* Implemente testes de integração

* Realize testes de performance

* Valide edge cases

4. Otimização

* Profile o código

* Otimize pontos críticos

* Monitore uso de recursos

* Implemente caching quando necessário

## Recursos Adicionais

### Documentação

* JavaDoc completo

* Diagramas de arquitetura

* Guias de uso

* Exemplos práticos

### Ferramentas

* IDEs recomendadas

* Plugins úteis

* Frameworks de teste

* Ferramentas de build

### Comunidade

* Fóruns de discussão

* Canais de suporte

* Repositórios de exemplo

* Artigos relacionados



# Data Processor

## Visão Geral

O Data Processor é um projeto avançado que demonstra o uso de anotações personalizadas para criar um sistema flexível de processamento de dados.

## Objetivos

* Implementar um sistema de validação baseado em anotações

* Criar transformadores de dados customizáveis

* Desenvolver um pipeline de processamento configurável

* Suportar diferentes formatos e fontes de dados

## Implementação

### 1. Anotações Base

```JAVA
// Anotação principal para marcar classes processáveis
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface DataProcessor {
    String value() default "";
    String version() default "1.0";
    ProcessingMode mode() default ProcessingMode.SYNC;
    
    public enum ProcessingMode {
        SYNC, ASYNC, BATCH
    }
}

// Anotação para validação de campos
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Validate {
    String pattern() default "";
    boolean required() default true;
    int minLength() default 0;
    int maxLength() default Integer.MAX_VALUE;
    String message() default "";
}

// Anotação para transformação de dados
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Transform {
    Class<? extends DataTransformer<?>> transformer();
    String[] params() default {};
}

// Anotação para persistência
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Persist {
    String strategy() default "DEFAULT";
    boolean async() default false;
}
```

### 2. Interfaces Base

```JAVA
// Interface para transformadores de dados
public interface DataTransformer<T> {
    T transform(T input, String... params);
}

// Interface para validadores
public interface DataValidator {
    boolean validate(Object value, Validate annotation);
    String getErrorMessage();
}

// Interface para persistência
public interface DataPersister {
    void persist(Object data, Persist annotation);
    Object retrieve(String id, Class<?> type);
}
```

### 3. Implementações Principais

```JAVA
// Processador principal
public class DataProcessorEngine {
    private final Map<Class<?>, DataValidator> validators;
    private final Map<Class<?>, DataTransformer<?>> transformers;
    private final Map<String, DataPersister> persisters;

    public <T> ProcessingResult<T> process(T data) {
        Class<?> dataClass = data.getClass();
        
        if (!dataClass.isAnnotationPresent(DataProcessor.class)) {
            throw new IllegalArgumentException("Class not annotated with @DataProcessor");
        }

        ProcessingResult<T> result = new ProcessingResult<>();
        
        // Validação
        validateFields(data, result);
        
        if (!result.isValid()) {
            return result;
        }

        // Transformação
        T transformed = transformFields(data);
        
        // Persistência
        persistFields(transformed);

        result.setProcessedData(transformed);
        return result;
    }

    private <T> void validateFields(T data, ProcessingResult<T> result) {
        // Implementação da validação
    }

    private <T> T transformFields(T data) {
        // Implementação da transformação
    }

    private <T> void persistFields(T data) {
        // Implementação da persistência
    }
}
```

### 4. Implementações de Transformadores

```JAVA
// Transformador de criptografia
public class EncryptTransformer implements DataTransformer<String> {
    @Override
    public String transform(String input, String... params) {
        // Implementação da criptografia
        return encrypt(input, params[0]); // params[0] = chave de criptografia
    }

    private String encrypt(String data, String key) {
        // Lógica de criptografia
        return /* dados criptografados */;
    }
}

// Transformador de formatação de data
public class DateFormatTransformer implements DataTransformer<Date> {
    @Override
    public Date transform(Date input, String... params) {
        String pattern = params[0]; // formato da data
        // Implementação da formatação
        return /* data formatada */;
    }
}
```

### 5. Exemplo de Uso

```JAVA
@DataProcessor(
    value = "userProcessor",
    version = "1.0",
    mode = ProcessingMode.ASYNC
)
public class UserData {
    @Validate(
        pattern = "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,6}$",
        message = "Email inválido"
    )
    private String email;
    
    @Transform(transformer = EncryptTransformer.class)
    @Validate(required = true, minLength = 8)
    private String password;
    
    @Transform(
        transformer = DateFormatTransformer.class,
        params = "yyyy-MM-dd"
    )
    private Date birthDate;
    
    @Persist(strategy = "JDBC", async = true)
    private UserProfile profile;

    // Getters e Setters
}

// Uso do processador
public class UserService {
    private final DataProcessorEngine processor;

    public void registerUser(UserData userData) {
        ProcessingResult<UserData> result = processor.process(userData);
        
        if (result.isValid()) {
            // Usuário processado com sucesso
            UserData processedData = result.getProcessedData();
            // Continuar com o fluxo
        } else {
            // Tratar erros de validação
            List<String> errors = result.getErrors();
            // Tratamento de erros
        }
    }
}
```

## Desafios de Implementação

### 1. Validação Assíncrona

Implementar suporte a validações assíncronas para campos que requerem verificações externas.

```JAVA
@Validate(async = true, validator = EmailExistsValidator.class)
private String email;
```

### 2. Pipeline Customizável

Criar um sistema de pipeline onde a ordem de processamento pode ser configurada.

```JAVA
@DataProcessor(
    pipeline = {
        @Stage(type = VALIDATION, order = 1),
        @Stage(type = TRANSFORMATION, order = 2),
        @Stage(type = PERSISTENCE, order = 3)
    }
)
```

### 3. Transformações Compostas

Permitir múltiplas transformações em sequência para um mesmo campo.

```JAVA
@Transform({
    @SingleTransform(transformer = TrimTransformer.class),
    @SingleTransform(transformer = LowerCaseTransformer.class),
    @SingleTransform(transformer = EncryptTransformer.class)
})
private String data;
```

## Próximos Passos

1. Otimizações

* Implementar cache de reflexão

* Adicionar pool de threads para processamento assíncrono

* Otimizar validações em lote

2. Extensões

* Suporte a expressões regulares complexas

* Validações customizadas via scripts

* Plugins para novos transformadores

3. Monitoramento

* Métricas de processamento

* Logging detalhado

* Rastreamento de transformações

Tip:

Dica: Comece com um conjunto pequeno de validadores e transformadores, e expanda gradualmente conforme as necessidades do projeto.



# Calculadora Funcional

## Visão Geral

A Calculadora Funcional é um projeto avançado que demonstra os princípios da programação funcional em Java, utilizando expressões lambda, funções de ordem superior e composição de funções.

## Objetivos

* Implementar operações matemáticas usando programação funcional

* Demonstrar o uso de expressões lambda e referências de método

* Criar um sistema de composição de operações

* Implementar histórico de operações usando streams

## Implementação

### Estrutura Base

```JAVA
@FunctionalInterface
public interface Operation<T> {
    T apply(T a, T b);
}

public class FunctionalCalculator {
    private final List<String> history = new ArrayList<>();
    
    @Operation("ADD")
    public Function<Double, Double> add(Double a) {
        return b -> {
            double result = a + b;
            logOperation("ADD", a, b, result);
            return result;
        };
    }
    
    @Operation("MULTIPLY")
    public Function<Double, Double> multiply(Double a) {
        return b -> {
            double result = a * b;
            logOperation("MULTIPLY", a, b, result);
            return result;
        };
    }
    
    private void logOperation(String op, Double a, Double b, Double result) {
        history.add(String.format("%s: %f %s %f = %f", 
            op, a, op.toLowerCase(), b, result));
    }
    
    public List<String> getHistory() {
        return Collections.unmodifiableList(history);
    }
}
```

### Composição de Operações

```JAVA
public class OperationComposer {
    @Operation("COMPOSE")
    public <T> Function<T, T> compose(
        @OperationParam Function<T, T>... functions
    ) {
        return Arrays.stream(functions)
                    .reduce(Function.identity(), Function::andThen);
    }
}
```

## Exemplos de Uso

### Operações Básicas

```JAVA
FunctionalCalculator calc = new FunctionalCalculator();

// Operação simples
double result = calc.add(5.0).apply(3.0);  // 8.0

// Composição de operações
Function<Double, Double> operation = calc.compose(
    calc.add(5.0),
    calc.multiply(2.0)
);
double composedResult = operation.apply(3.0);  // 16.0
```

### Histórico de Operações

```JAVA
calc.getHistory().forEach(System.out::println);
// Saída:
// ADD: 5.000000 add 3.000000 = 8.000000
// MULTIPLY: 8.000000 multiply 2.000000 = 16.000000
```

## Exercícios Propostos

1. Implementar operações adicionais:

* Subtração

* Divisão

* Potenciação

* Raiz quadrada

2. Adicionar validações:

* Divisão por zero

* Números negativos em raiz quadrada

* Overflow/Underflow

3. Implementar operações com diferentes tipos:

* Inteiros

* Números complexos

* Vetores

## Desafios Avançados

### 1. Sistema de Plugins

Criar um sistema que permite adicionar novas operações dinamicamente:

```JAVA
public interface OperationPlugin {
    String getName();
    Function<Double, Double> getOperation(Double input);
}
```

### 2. Expressões Matemáticas

Implementar um parser de expressões matemáticas:

```JAVA
public class ExpressionParser {
    public Function<Double, Double> parse(String expression) {
        // Implementação do parser
    }
}
```

### 3. Operações Assíncronas

Adicionar suporte para cálculos assíncronos:

```JAVA
public class AsyncCalculator {
    public CompletableFuture<Double> calculateAsync(
        Function<Double, Double> operation,
        Double input
    ) {
        return CompletableFuture.supplyAsync(
            () -> operation.apply(input)
        );
    }
}
```

## Boas Práticas

1. Imutabilidade

* Use tipos imutáveis

* Evite estado mutável

* Retorne novas instâncias

2. Composição

* Prefira composição sobre herança

* Use funções pequenas e focadas

* Combine funções para operações complexas

3. Tratamento de Erros

* Use Optional para resultados opcionais

* Implemente tratamento de exceções funcional

* Mantenha a transparência referencial

## Recursos Adicionais

* [Documentação Java Stream API](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)

* [Tutorial sobre Programação Funcional](null)

* [Padrões Funcionais](null)

## Próximos Passos

Após completar este projeto, você estará preparado para:

* Desenvolver sistemas mais complexos usando programação funcional

* Implementar operações assíncronas e paralelas

* Criar DSLs (Domain Specific Languages) funcionais



# Framework de Injeção de Dependências Customizado

## Visão Geral

Neste projeto, vamos desenvolver um mini-framework de injeção de dependências usando reflexão e anotações em Java. O framework oferecerá funcionalidades básicas de DI (Dependency Injection) e gerenciamento de ciclo de vida de componentes.

## Principais Características

* Injeção automática de dependências

* Gerenciamento de escopo (singleton/prototype)

* Configuração via anotações

* Inicialização e destruição de componentes

* Suporte a plugins

## Anotações do Framework

### @Component

```JAVA
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Component {
    String value() default "";
    String scope() default "singleton";
}
```

### @Inject

```JAVA
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.CONSTRUCTOR})
public @interface Inject {
}
```

### @Initialize

```JAVA
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Initialize {
    int order() default 0;
}
```

## Container de Dependências

### Implementação Básica

```JAVA
public class DIContainer {
    private Map<Class<?>, Object> singletons = new HashMap<>();
    private Map<Class<?>, Class<?>> bindings = new HashMap<>();

    public <T> void bind(Class<T> interfaceClass, Class<? extends T> implementationClass) {
        bindings.put(interfaceClass, implementationClass);
    }

    public <T> T getInstance(Class<T> type) {
        // Verifica se é singleton
        if (singletons.containsKey(type)) {
            return (T) singletons.get(type);
        }

        // Cria nova instância
        return createInstance(type);
    }

    private <T> T createInstance(Class<T> type) {
        try {
            Constructor<?> constructor = type.getDeclaredConstructor();
            T instance = (T) constructor.newInstance();
            injectDependencies(instance);
            return instance;
        } catch (Exception e) {
            throw new RuntimeException("Erro ao criar instância", e);
        }
    }

    private void injectDependencies(Object instance) {
        Class<?> type = instance.getClass();
        for (Field field : type.getDeclaredFields()) {
            if (field.isAnnotationPresent(Inject.class)) {
                field.setAccessible(true);
                Object dependency = getInstance(field.getType());
                try {
                    field.set(instance, dependency);
                } catch (Exception e) {
                    throw new RuntimeException("Erro ao injetar dependência", e);
                }
            }
        }
    }
}
```

## Exemplo de Uso

### Definição de Componentes

```JAVA
@Component
public class UserService {
    @Inject
    private UserRepository userRepository;
    
    @Initialize
    public void setup() {
        System.out.println("Inicializando UserService");
    }
    
    public User findUser(Long id) {
        return userRepository.findById(id);
    }
}

@Component(scope = "prototype")
public class UserRepository {
    private DatabaseConnection connection;
    
    @Inject
    public UserRepository(DatabaseConnection connection) {
        this.connection = connection;
    }
    
    public User findById(Long id) {
        // Implementação
        return null;
    }
}
```

### Configuração e Uso

```JAVA
public class Application {
    public static void main(String[] args) {
        DIContainer container = new DIContainer();
        
        // Configuração
        container.bind(UserRepository.class, UserRepositoryImpl.class);
        
        // Uso
        UserService userService = container.getInstance(UserService.class);
        User user = userService.findUser(1L);
    }
}
```

## Recursos Avançados

### Plugin System

```JAVA
@Plugin
public interface UserPlugin {
    void onUserCreated(User user);
}

public class PluginManager {
    private List<UserPlugin> plugins = new ArrayList<>();
    
    public void registerPlugin(UserPlugin plugin) {
        plugins.add(plugin);
    }
    
    public void notifyUserCreated(User user) {
        plugins.forEach(plugin -> plugin.onUserCreated(user));
    }
}
```

### Aspect-Like Features

```JAVA
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Transactional {
}

public class TransactionInterceptor {
    public Object intercept(Method method, Object[] args) {
        beginTransaction();
        try {
            Object result = method.invoke(args);
            commitTransaction();
            return result;
        } catch (Exception e) {
            rollbackTransaction();
            throw e;
        }
    }
}
```

## Considerações de Design

### Padrões Utilizados

* Singleton para gerenciamento de instâncias

* Factory Method para criação de objetos

* Observer para sistema de plugins

* Proxy para interceptação de métodos

### Boas Práticas

* Lazy loading de dependências

* Cache de reflexão para performance

* Detecção de ciclos de dependência

* Logging e tratamento de erros

## Próximos Passos

1. Implementar suporte a profiles

2. Adicionar injeção por construtor

3. Desenvolver sistema de eventos

4. Criar mecanismo de configuração externa

5. Implementar lazy injection



# Annotation Processor

## Visão Geral

O Annotation Processor é um mecanismo poderoso do Java que permite processar anotações em tempo de compilação para gerar código, validar restrições e realizar outras tarefas de metaprogramação.

## Fundamentos

### O que é um Annotation Processor?

Um processador de anotações é uma ferramenta que analisa e processa anotações Java durante a compilação. Ele pode:

* Gerar novos arquivos fonte

* Validar uso de anotações

* Produzir mensagens de erro/aviso

* Modificar o processo de compilação

### Estrutura Básica

```JAVA
@SupportedAnnotationTypes("com.example.annotations.*")
@SupportedSourceVersion(SourceVersion.RELEASE_17)
public class CustomProcessor extends AbstractProcessor {
    @Override
    public boolean process(
        Set<? extends TypeElement> annotations,
        RoundEnvironment roundEnv
    ) {
        // Lógica de processamento
        return true;
    }
}
```

## Implementação

### Configuração do Projeto

1. Criar arquivo de serviço:
`META-INF/services/javax.annotation.processing.Processor`

2. Adicionar dependências necessárias

3. Configurar plugin de compilação

### Processamento de Elementos

```JAVA
@Override
public boolean process(
    Set<? extends TypeElement> annotations,
    RoundEnvironment roundEnv
) {
    for (TypeElement annotation : annotations) {
        Set<? extends Element> elements = 
            roundEnv.getElementsAnnotatedWith(annotation);
        
        for (Element element : elements) {
            // Processamento específico
            processElement(element);
        }
    }
    return true;
}
```

### Geração de Código

```JAVA
private void generateCode(Element element) {
    JavaFileObject file = processingEnv.getFiler()
        .createSourceFile("GeneratedClass");
    
    try (PrintWriter out = new PrintWriter(file.openWriter())) {
        out.println("package com.example.generated;");
        out.println("public class GeneratedClass {");
        // Geração do código
        out.println("}");
    }
}
```

## Casos de Uso

### Builder Generator

```JAVA
@Builder
public class User {
    private String name;
    private String email;
    private int age;
}

// Gera:
public class UserBuilder {
    private User user = new User();
    
    public UserBuilder name(String name) {
        user.setName(name);
        return this;
    }
    // ... outros métodos
}
```

### DTO Mapper

```JAVA
@Mapper
public class UserEntity {
    private Long id;
    private String username;
    
    // Gera automaticamente:
    // - UserDTO
    // - UserMapper
}
```

### Validador de Anotações

```JAVA
@ValidateAnnotation
public @interface Route {
    String path();
    String method();
}

// Valida em tempo de compilação:
// - Formato do path
// - Método HTTP válido
```

## Boas Práticas

### Desempenho

* Cache de elementos processados

* Minimizar operações I/O

* Processamento incremental

### Mensagens de Erro

```JAVA
private void reportError(Element element, String message) {
    processingEnv.getMessager().printMessage(
        Diagnostic.Kind.ERROR,
        message,
        element
    );
}
```

### Testes

```JAVA
@Test
public void testProcessor() {
    Compilation compilation = 
        javac()
            .withProcessors(new CustomProcessor())
            .compile(JavaFileObjects.forSourceString(
                "Test",
                "..."
            ));
    
    assertThat(compilation).succeeded();
    // Verificar saída gerada
}
```

## Ferramentas e Bibliotecas

### Utilitárias

* JavaPoet: Geração de código

* Auto Service: Registro de processadores

* Compile Testing: Testes de compilação

### Integração IDE

* Suporte a processamento incremental

* Debugging de processadores

* Visualização de código gerado

## Exemplos Avançados

### Gerador de API REST

```JAVA
@RestController
@RequestMapping("/api")
public class UserController {
    // Gera:
    // - Documentation
    // - Client SDK
    // - Test Cases
}
```

### Gerador de Documentação

```JAVA
@ApiDoc(
    description = "Gerencia usuários",
    version = "1.0"
)
public class UserService {
    // Gera:
    // - Markdown
    // - HTML
    // - OpenAPI spec
}
```

## Recursos Adicionais

### Links Úteis

* [Documentação Oracle](https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html)

* [JavaPoet GitHub](https://github.com/square/javapoet)

* [Annotation Processing Tool](https://docs.oracle.com/javase/8/docs/technotes/tools/windows/apt.html)

### Projetos de Exemplo

* [Lombok](https://github.com/projectlombok/lombok)

* [Dagger](https://github.com/google/dagger)

* [MapStruct](https://github.com/mapstruct/mapstruct)



# Generic Container

![Generic Container](generic-container-banner.png)

## Visão Geral

Um container genérico é uma estrutura de dados flexível que pode armazenar e gerenciar diferentes tipos de objetos de forma type-safe.

## Estrutura Base

### Container Genérico Básico

```JAVA
public class Container<T> {
    private final List<T> elements;
    private final Map<String, T> namedElements;
    
    public Container() {
        this.elements = new ArrayList<>();
        this.namedElements = new HashMap<>();
    }
    
    public void add(T element) {
        elements.add(element);
    }
    
    public void addNamed(String name, T element) {
        namedElements.put(name, element);
    }
    
    public Optional<T> get(int index) {
        return index >= 0 && index < elements.size() 
            ? Optional.of(elements.get(index))
            : Optional.empty();
    }
    
    public Optional<T> getNamed(String name) {
        return Optional.ofNullable(namedElements.get(name));
    }
}
```

## Funcionalidades Avançadas

### Container com Validação

```JAVA
public class ValidatedContainer<T> extends Container<T> {
    private final Predicate<T> validator;
    
    public ValidatedContainer(Predicate<T> validator) {
        super();
        this.validator = validator;
    }
    
    @Override
    public void add(T element) {
        if (validator.test(element)) {
            super.add(element);
        } else {
            throw new IllegalArgumentException("Elemento inválido");
        }
    }
}
```

### Container com Transformação

```JAVA
public class TransformingContainer<T, R> {
    private final Container<T> source;
    private final Function<T, R> transformer;
    
    public TransformingContainer(Container<T> source, Function<T, R> transformer) {
        this.source = source;
        this.transformer = transformer;
    }
    
    public Optional<R> getTransformed(int index) {
        return source.get(index).map(transformer);
    }
}
```

## Casos de Uso

### Gerenciamento de Dados

```JAVA
Container<User> userContainer = new Container<>();
userContainer.add(new User("Alice"));
userContainer.addNamed("admin", new User("Admin"));

ValidatedContainer<Email> emailContainer = 
    new ValidatedContainer<>(Email::isValid);
emailContainer.add(new Email("user@example.com"));
```

### Processamento de Dados

```JAVA
Container<String> stringContainer = new Container<>();
stringContainer.add("123");
stringContainer.add("456");

TransformingContainer<String, Integer> numberContainer =
    new TransformingContainer<>(stringContainer, Integer::parseInt);

Optional<Integer> number = numberContainer.getTransformed(0); // 123
```

## Boas Práticas

1. Type Safety

* Use bounds quando necessário

* Evite type erasure quando possível

* Valide tipos em runtime quando apropriado

2. Performance

* Implemente lazy loading

* Use estruturas de dados apropriadas

* Considere cache para operações custosas

3. Thread Safety

```JAVA
public class ThreadSafeContainer<T> {
    private final Container<T> container;
    private final Lock lock;
    
    public ThreadSafeContainer() {
        this.container = new Container<>();
        this.lock = new ReentrantLock();
    }
    
    public void add(T element) {
        lock.lock();
        try {
            container.add(element);
        } finally {
            lock.unlock();
        }
    }
}
```

## Exercícios Propostos

1. Implemente um container com suporte a eventos (Observer pattern)

2. Crie um container com política de expiração de elementos

3. Desenvolva um container com suporte a operações em batch

4. Adicione funcionalidade de serialização/deserialização

## Próximos Passos

* Explorar integração com Streams API

* Implementar padrões de design adicionais

* Adicionar suporte a persistência

* Desenvolver visualizações de dados

[Annotation Processor](annotation-processor.html)



# Reflection Explorer

## Visão Geral do Projeto

O Reflection Explorer é uma ferramenta avançada para análise e manipulação de classes Java em runtime, permitindo:

* Inspeção detalhada de classes

* Modificação dinâmica de objetos

* Geração de proxies

* Análise de dependências

* Visualização de hierarquias

## Arquitetura

```MERMAID
classDiagram
    class ReflectionExplorer {
        -ClassAnalyzer analyzer
        -ObjectModifier modifier
        -ProxyGenerator proxyGen
        +analyze(Class) ClassInfo
        +modify(Object, Enhancement) Object
        +createProxy(Class, Handler) Object
    }
    
    class ClassAnalyzer {
        -methodCache: Map
        -fieldCache: Map
        +getMethods(Class) Method[]
        +getFields(Class) Field[]
        +getAnnotations(Class) Annotation[]
    }
    
    class ObjectModifier {
        +enhance(Object) Object
        +inject(Object, Object) void
        +intercept(Object, Method) Object
    }
    
    class ProxyGenerator {
        +createProxy(Class) Object
        +addHandler(Object, Handler) void
    }
    
    ReflectionExplorer --> ClassAnalyzer
    ReflectionExplorer --> ObjectModifier
    ReflectionExplorer --> ProxyGenerator
```

## Implementação Core

### Analisador de Classes

```JAVA
public class ClassAnalyzer {
    private final Map<Class<?>, Method[]> methodCache = new ConcurrentHashMap<>();
    private final Map<Class<?>, Field[]> fieldCache = new ConcurrentHashMap<>();
    
    @Inspect
    public ClassInfo analyze(Class<?> target) {
        return ClassInfo.builder()
            .name(target.getName())
            .methods(getMethods(target))
            .fields(getFields(target))
            .annotations(getAnnotations(target))
            .superclass(target.getSuperclass())
            .interfaces(target.getInterfaces())
            .modifiers(target.getModifiers())
            .build();
    }
    
    private Method[] getMethods(Class<?> clazz) {
        return methodCache.computeIfAbsent(clazz, Class::getDeclaredMethods);
    }
    
    private Field[] getFields(Class<?> clazz) {
        return fieldCache.computeIfAbsent(clazz, Class::getDeclaredFields);
    }
}
```

### Modificador de Objetos

```JAVA
public class ObjectModifier {
    @Modify
    public Object enhance(
        @Target Object instance,
        @Enhancement Enhancement enhancement
    ) {
        Class<?> clazz = instance.getClass();
        
        // Aplicar modificações
        for (Field field : clazz.getDeclaredFields()) {
            if (enhancement.shouldModify(field)) {
                field.setAccessible(true);
                field.set(instance, enhancement.getNewValue(field));
            }
        }
        
        return instance;
    }
    
    @Intercept
    public Object interceptMethod(
        Object instance,
        Method method,
        Object[] args,
        MethodHandler handler
    ) throws Exception {
        // Pré-processamento
        handler.beforeInvocation(method, args);
        
        // Invocação do método
        Object result = method.invoke(instance, args);
        
        // Pós-processamento
        return handler.afterInvocation(method, result);
    }
}
```

### Gerador de Proxy

```JAVA
public class ProxyGenerator {
    public <T> T createProxy(
        Class<T> interfaceType,
        InvocationHandler handler
    ) {
        return (T) Proxy.newProxyInstance(
            interfaceType.getClassLoader(),
            new Class<?>[] { interfaceType },
            handler
        );
    }
    
    public class LoggingHandler implements InvocationHandler {
        private final Object target;
        
        public LoggingHandler(Object target) {
            this.target = target;
        }
        
        @Override
        public Object invoke(
            Object proxy,
            Method method,
            Object[] args
        ) throws Throwable {
            System.out.println("Before: " + method.getName());
            Object result = method.invoke(target, args);
            System.out.println("After: " + method.getName());
            return result;
        }
    }
}
```

## Recursos Avançados

### Visualizador de Hierarquia

```JAVA
public class HierarchyVisualizer {
    public String generateDotGraph(Class<?> rootClass) {
        StringBuilder dot = new StringBuilder();
        dot.append("digraph Hierarchy {\n");
        
        // Adiciona nós
        addClassNode(dot, rootClass);
        
        // Adiciona relacionamentos
        addRelationships(dot, rootClass);
        
        dot.append("}");
        return dot.toString();
    }
    
    private void addClassNode(StringBuilder dot, Class<?> clazz) {
        dot.append(String.format(
            "  %s [label=\"%s\"];\n",
            clazz.getSimpleName(),
            clazz.getName()
        ));
    }
}
```

### Cache Inteligente

```JAVA
public class ReflectionCache {
    private static final Map<Class<?>, ClassInfo> CLASS_INFO_CACHE = 
        new ConcurrentHashMap<>();
    
    public static ClassInfo getClassInfo(Class<?> clazz) {
        return CLASS_INFO_CACHE.computeIfAbsent(
            clazz,
            ReflectionCache::analyzeClass
        );
    }
    
    private static ClassInfo analyzeClass(Class<?> clazz) {
        // Análise detalhada da classe
        return new ClassAnalyzer().analyze(clazz);
    }
}
```

## Exemplos de Uso

### Análise de Dependências

```JAVA
public class DependencyAnalyzer {
    public Set<Class<?>> findDependencies(Class<?> targetClass) {
        Set<Class<?>> dependencies = new HashSet<>();
        
        // Analisa campos
        for (Field field : targetClass.getDeclaredFields()) {
            dependencies.add(field.getType());
        }
        
        // Analisa métodos
        for (Method method : targetClass.getDeclaredMethods()) {
            dependencies.addAll(Arrays.asList(method.getParameterTypes()));
            dependencies.add(method.getReturnType());
        }
        
        return dependencies;
    }
}
```

### Injeção Dinâmica

```JAVA
public class DependencyInjector {
    public void inject(Object instance) {
        Class<?> clazz = instance.getClass();
        
        for (Field field : clazz.getDeclaredFields()) {
            if (field.isAnnotationPresent(Inject.class)) {
                field.setAccessible(true);
                field.set(instance, createDependency(field.getType()));
            }
        }
    }
}
```

## Testes

### Testes Unitários

```JAVA
@Test
public void testClassAnalysis() {
    ClassAnalyzer analyzer = new ClassAnalyzer();
    ClassInfo info = analyzer.analyze(TestClass.class);
    
    assertNotNull(info);
    assertEquals("TestClass", info.getName());
    assertTrue(info.getMethods().length > 0);
}

@Test
public void testObjectModification() {
    ObjectModifier modifier = new ObjectModifier();
    TestClass instance = new TestClass();
    
    Enhancement enhancement = new Enhancement("value", "newValue");
    Object modified = modifier.enhance(instance, enhancement);
    
    assertEquals("newValue", ((TestClass)modified).getValue());
}
```

## Considerações de Performance

1. Caching

* Cache de reflection metadata

* Reutilização de instâncias

* Lazy loading de informações

2. Otimizações

* Batch processing

* Minimizar reflection em loops

* Usar streams para processamento paralelo

3. Memória

* Limpeza periódica de cache

* Weak references para objetos

* Pooling de instâncias comuns

## Próximos Passos

1. Implementar visualização gráfica

2. Adicionar suporte a bytecode manipulation

3. Criar sistema de plugins

4. Integrar com IDEs populares

## Recursos Adicionais

* [Java Reflection API Documentation](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html)

* [ASM Library](https://asm.ow2.io/)

* [ByteBuddy](https://bytebuddy.net/)

[Annotation Processor](annotation-processor.html)



# Recursos de Aprendizado Java

## Visão Geral

Este guia compila os melhores recursos para aprofundar seu conhecimento em Java.

## Categorias Principais

```
RECURSOS JAVA
├── Documentação Oficial
├── Livros Recomendados
├── Cursos Online
├── Comunidade
├── Ferramentas
├── Cheat Sheets
└── Glossário
```

## Como Usar Este Guia

1. Comece pela documentação oficial para fundamentos sólidos

2. Escolha livros ou cursos baseados em seu nível

3. Participe da comunidade para networking

4. Utilize ferramentas para aumentar produtividade

5. Consulte cheat sheets para referência rápida

6. Use o glossário para termos técnicos

## Mantenha-se Atualizado

* Siga blogs técnicos

* Participe de conferências

* Acompanhe releases do Java

* Pratique regularmente



# Documentação Oficial

## Oracle Java SE Documentation

* [Java SE Documentation](https://docs.oracle.com/en/java/javase/index.html)

* [Java Language Specification](https://docs.oracle.com/javase/specs/jls/se17/html/index.html)

* [Java Virtual Machine Specification](https://docs.oracle.com/javase/specs/jvms/se17/html/index.html)

* [JavaDoc API Documentation](https://docs.oracle.com/en/java/javase/17/docs/api/index.html)

## Tutoriais Oracle

* The Java Tutorials

* Java EE Documentation

* Security Documentation

* JVM Tuning Guide

## OpenJDK Documentation

* Project Documentation

* Enhancement Proposals

* Release Notes

* Migration Guides

## Especificações

* Java Language

* Java Memory Model

* Java Native Interface

* Java Debug Interface



# Livros Recomendados

## Iniciante

1. Head First Java

* Autores: Kathy Sierra & Bert Bates

* Foco: Fundamentos de forma didática

2. Core Java Volume I

* Autor: Cay S. Horstmann

* Foco: Fundamentos aprofundados

## Intermediário

1. Effective Java

* Autor: Joshua Bloch

* Foco: Boas práticas e padrões

2. Clean Code

* Autor: Robert C. Martin

* Foco: Qualidade de código

## Avançado

1. Java Concurrency in Practice

* Autor: Brian Goetz

* Foco: Programação concorrente

2. Java Performance

* Autor: Scott Oaks

* Foco: Otimização e performance

## Especializado

1. Spring in Action

* Autor: Craig Walls

* Foco: Framework Spring

2. Microservices Patterns

* Autor: Chris Richardson

* Foco: Arquitetura moderna



# Cursos Online

## Plataformas Gratuitas

1. Coursera

* Java Programming Specialization

* Object Oriented Java Programming

* Android App Development

2. edX

* Introduction to Java Programming

* Object-Oriented Programming

* Data Structures and Algorithms

## Plataformas Pagas

1. Udemy

* Complete Java Masterclass

* Java Spring Boot

* Microservices with Spring Boot

2. PluralSight

* Java Fundamentals

* Spring Framework Path

* Enterprise Architecture

## Bootcamps

1. Coding Dojo

* Java Stack

* Spring Boot

* Full Stack Development

2. General Assembly

* Java Development

* Enterprise Solutions

* Web Development

## Recursos Interativos

1. CodeCademy

* Learn Java

* Build Basic Java Apps

* Practice Exercises

2. HackerRank

* Java Practice

* Problem Solving

* Interview Preparation



# Comunidade Java

## Fóruns e Q&A

1. Stack Overflow

* Tags: java, spring, hibernate

* Como participar efetivamente

* Guidelines para perguntas

2. Reddit

* r/java

* r/learnjava

* r/javahelp

## Grupos e Meetups

1. Meetup.com

* Java User Groups (JUGs)

* Coding Dojos

* Tech Talks

2. Discord

* Java Community

* Spring Developers

* Android Dev

## Conferências

1. Principais Eventos

* JavaOne

* Devoxx

* JFokus

* QCon

2. Eventos Brasileiros

* TDC

* QCon SP

* DevOpsDays

## Contribuição

1. Open Source

* Como começar

* Projetos para iniciantes

* Boas práticas

2. Mentoria

* Programas disponíveis

* Como encontrar mentor

* Como ser mentor



# Ferramentas Java

## IDEs

1. IntelliJ IDEA

* Community Edition

* Ultimate Edition

* Plugins essenciais

2. Eclipse

* Instalação

* Configuração

* Extensões populares

3. VS Code

* Extensões Java

* Configuração

* Debugging

## Build Tools

1. Maven

* Configuração básica

* Gerenciamento de dependências

* Plugins úteis

2. Gradle

* Setup inicial

* Scripts básicos

* Tarefas customizadas

## Testing Tools

1. JUnit

* JUnit 5

* Assertions

* Test Lifecycle

2. Mockito

* Mocks

* Stubs

* Verificações

## Profiling

1. JProfiler

* Análise de memória

* CPU profiling

* Threads

2. VisualVM

* Monitoramento

* Heap dump

* Thread dump



# Cheat Sheets

## Sintaxe Básica

```JAVA
// Declarações
int numero = 10;
String texto = "Hello";
final double PI = 3.14;

// Controle de fluxo
if (condicao) {
    // código
} else {
    // código
}

for (int i = 0; i < 10; i++) {
    // código
}
```

## Collections Framework

```JAVA
// List
List<String> lista = new ArrayList<>();
lista.add("item");

// Map
Map<String, Integer> mapa = new HashMap<>();
mapa.put("chave", 1);

// Set
Set<Integer> conjunto = new HashSet<>();
conjunto.add(1);
```

## Lambda Expressions

```JAVA
// Básico
Runnable r = () -> System.out.println("Hello");

// Com parâmetros
Consumer<String> c = (s) -> System.out.println(s);

// Com múltiplas linhas
Comparator<String> comp = (s1, s2) -> {
    if (s1 == null) return -1;
    if (s2 == null) return 1;
    return s1.compareTo(s2);
};
```

## Stream API

```JAVA
// Operações comuns
list.stream()
    .filter(x -> x > 0)
    .map(x -> x * 2)
    .collect(Collectors.toList());

// Redução
int sum = numbers.stream()
    .reduce(0, Integer::sum);
```

## Optional

```JAVA
// Criação
Optional<String> opt = Optional.of("value");
Optional<String> empty = Optional.empty();

// Uso
String value = opt.orElse("default");
opt.ifPresent(System.out::println);
```

## Files e I/O

```JAVA
// Leitura
List<String> lines = Files.readAllLines(Path.of("file.txt"));

// Escrita
Files.write(Path.of("output.txt"), content.getBytes());

// Try-with-resources
try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"))) {
    // código
}
```



# Glossário Java

## A

* Abstract Class: Classe que não pode ser instanciada e pode conter métodos abstratos

* Annotation: Metadados que podem ser adicionados ao código Java

* API: Application Programming Interface

## B

* Bytecode: Código intermediário gerado pela compilação Java

* Bean: Objeto Java que segue convenções específicas

## C

* Class: Modelo para criar objetos

* Classpath: Caminho onde o Java procura por classes

* Collection: Interface para grupo de objetos

## D

* DAO: Data Access Object

* Dependency Injection: Padrão de design para inversão de controle

* DTOs: Data Transfer Objects

## E

* Encapsulation: Princípio de OOP para esconder implementações

* Exception: Evento que ocorre durante a execução

## F

* Framework: Estrutura de suporte predefinida

* Final: Modificador para constantes e métodos não sobrescritíveis

## G

* Garbage Collection: Gerenciamento automático de memória

* Generic: Tipo parametrizado

## H

* Heap: Área de memória para objetos

* HTTP: Hypertext Transfer Protocol

## I

* Interface: Contrato para implementação de métodos

* Iterator: Padrão para percorrer coleções

## J

* JAR: Java Archive

* JVM: Java Virtual Machine

* JRE: Java Runtime Environment

* JDK: Java Development Kit

## L

* Lambda: Função anônima

* LINQ: Language Integrated Query

## M

* Maven: Ferramenta de build

* Middleware: Software intermediário

* MVC: Model-View-Controller

## O

* OOP: Object-Oriented Programming

* ORM: Object-Relational Mapping

## P

* Package: Namespace para organizar classes

* POJO: Plain Old Java Object

## R

* Reflection: API para examinar/modificar código em runtime

* REST: Representational State Transfer

## S

* Serialization: Conversão de objeto em bytes

* Spring: Framework Java popular

* Stream: Sequência de elementos

## T

* Thread: Unidade de execução

* Transaction: Unidade atômica de trabalho

## V

* Varargs: Número variável de argumentos

* Virtual Method: Método que pode ser sobrescrito



